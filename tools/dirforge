#!/usr/bin/env bash
set -euo pipefail

# dirforge - create standardized directory structures per DirForge Constitution
# Minimal, portable bash CLI that implements `dirforge init <world-type>`

PROG_NAME="dirforge"

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Detect library directory (development vs installed)
if [ -d "$SCRIPT_DIR/../lib" ]; then
    # Development mode - script is in tools/, libraries in lib/
    LIB_DIR="$(cd "$SCRIPT_DIR/../lib" && pwd)"
elif [ -d "$HOME/.local/lib/dirforge" ]; then
    # Local installation mode  
    LIB_DIR="$HOME/.local/lib/dirforge"
elif [ -d "/usr/local/lib/dirforge" ]; then
    # System installation mode
    LIB_DIR="/usr/local/lib/dirforge"
else
    # Fallback - try relative path anyway
    LIB_DIR="$SCRIPT_DIR/../lib"
fi

# Detect templates directory (development vs installed)
if [ -d "$SCRIPT_DIR/../templates" ]; then
    # Development mode - templates in templates/
    TEMPLATES_DIR="$(cd "$SCRIPT_DIR/../templates" && pwd)"
elif [ -d "$HOME/.local/share/dirforge/templates" ]; then
    # Local installation mode
    TEMPLATES_DIR="$HOME/.local/share/dirforge/templates"
elif [ -d "/usr/local/share/dirforge/templates" ]; then
    # System installation mode
    TEMPLATES_DIR="/usr/local/share/dirforge/templates"
else
    # Fallback
    TEMPLATES_DIR="$SCRIPT_DIR/../templates"
fi

# Source help system libraries if available
if [ -f "$LIB_DIR/terminal.sh" ]; then
    source "$LIB_DIR/terminal.sh"
fi
if [ -f "$LIB_DIR/colors.sh" ]; then
    source "$LIB_DIR/colors.sh"
    init_colors 2>/dev/null || true
fi
if [ -f "$LIB_DIR/help.sh" ]; then
    source "$LIB_DIR/help.sh"
fi
if [ -f "$LIB_DIR/error.sh" ]; then
    source "$LIB_DIR/error.sh"
fi

CONSTITUTION_VERSION="v1.0.21"

# Dry-run flag (preview mode). When true, filesystem changes are not written; actions are printed.
DRY_RUN=false
# JSON output flag. When true with DRY_RUN, output machine-readable JSON plan.
JSON_OUTPUT=false
# Force flag. When true, overwrite existing projects without prompting.
FORCE=false
# Backup flag. When true, create timestamped backups before overwriting.
BACKUP=false
# Yes flag. When true, skip interactive prompts and proceed.
YES=false

# JSON plan accumulator (used when JSON_OUTPUT=true)
JSON_DIRS=()
JSON_FILES=()

json_escape() {
  # Escape string for JSON (basic escaping, remove trailing newline)
  printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g'
}

do_mkdir_p() {
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = true ]; then
      for dir in "$@"; do
        JSON_DIRS+=("$dir")
      done
    else
      echo "DRY RUN: mkdir -p $*"
    fi
  else
    mkdir -p "$@"
  fi
}

write_file() {
  # usage: write_file <dest> <<'EOF'...EOF
  local dest="$1"
  shift
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = true ]; then
      # Capture file content for JSON
      local content
      content=$(cat)
      JSON_FILES+=("$dest")
    else
      echo "DRY RUN: would write file: $dest"
      # print a snippet of the content for visibility
      awk '{ if (NR<=20) print "    " $0 }' || true
      # consume stdin
      cat >/dev/null
    fi
  else
    mkdir -p "$(dirname "$dest")"
    cat > "$dest"
  fi
}

render_template() {
  # usage: render_template <template_file> <dest> [VAR=value ...]
  local template_file="$1"
  local dest="$2"
  shift 2
  # Verify template exists
  if [ ! -f "$template_file" ]; then
    show_template_not_found_error "$template_file"
    return 1
  fi

  local content
  content=$(cat "$template_file")
  for var in "$@"; do
    local name="${var%%=*}"
    local value="${var#*=}"
    # Escape backslashes, pipes and ampersands for safe sed substitution
    local esc
    esc=$(printf '%s' "$value" | sed -e 's/\\/\\\\/g' -e 's/|/\\|/g' -e 's/&/\\&/g')
    content=$(printf "%s" "$content" | sed "s|{{${name}}}|${esc}|g")
  done
  write_file "$dest" <<< "$content"
}

to_snake_case() {
  # Convert a string to lower_snake_case: transliterate, lowercase, replace non-alnum with _, trim
  local s="$*"
  # Use iconv if available for transliteration, else rely on sed
  if command -v iconv >/dev/null 2>&1; then
    s=$(printf "%s" "$s" | iconv -f utf8 -t ascii//TRANSLIT 2>/dev/null)
  fi
  printf "%s" "$s" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9_-]+/_/g' | sed -E 's/^_+|_+$//g'
}

strip_year_prefix() {
  local id="$1"
  echo "$id" | sed -E 's/^[0-9]{4}_//'
}

backup_directory() {
  local src="$1"
  local timestamp
  timestamp=$(date +%Y%m%d-%H%M%S)
  local backup_dir="${src}.backup-${timestamp}"
  
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create backup: $backup_dir"
    fi
  else
    cp -R "$src" "$backup_dir"
    echo "Created backup: $backup_dir"
  fi
}

prompt_overwrite() {
  local project_path="$1"
  
  # Skip prompt if --yes or --force is set
  if [ "$YES" = true ] || [ "$FORCE" = true ]; then
    return 0
  fi
  
  echo "WARNING: Project already exists at $project_path" >&2
  if [ "$BACKUP" = true ]; then
    echo "A backup will be created before overwriting." >&2
  fi
  read -r -p "Overwrite existing project? [y/N] " response
  case "$response" in
    [yY][eE][sS]|[yY]) 
      return 0
      ;;
    *)
      echo "Operation cancelled." >&2
      exit 1
      ;;
  esac
}

conda_env_exists() {
  local name="$1"
  if ! command -v conda >/dev/null 2>&1; then
    return 1
  fi
  conda info --envs 2>/dev/null | awk '{print $1}' | grep -xq "$name" || return 1
}

# Detect if init is in parent-only mode for a world-type
# Returns 0 (true) if only <world-type> is given, no project/study flags
# Usage: is_parent_only_mode <world-type> <args>
is_parent_only_mode() {
  local world_type="$1"; shift
  # If no args, parent-only mode
  if [ "$#" -eq 0 ]; then
    return 0
  fi
  # For research: must NOT have --name, --project, --study
  case "$world_type" in
    research)
      for arg in "$@"; do
        case "$arg" in
          --name|--project|--study|-n|-p|-s)
            return 1
            ;;
        esac
      done
      return 0
      ;;
    journal)
      # For journal, must NOT have project-specific flags
      for arg in "$@"; do
        case "$arg" in
          --name|--id|--first|--coauthor|--service|--year|-n|-i|-f|-c|-s|-y)
            return 1
            ;;
        esac
      done
      return 0
      ;;
    lecture)
      # For lecture, must NOT have --name, --term, --code
      for arg in "$@"; do
        case "$arg" in
          --name|--term|--code|-n)
            return 1
            ;;
        esac
      done
      return 0
      ;;
    coding)
      # For coding, must NOT have --language, --project, --name
      for arg in "$@"; do
        case "$arg" in
          --language|--project|--name|-l|-p|-n)
            return 1
            ;;
        esac
      done
      return 0
      ;;
    office|private)
      # Office and private always create standard structure (no project-specific flags)
      # Any flags would be invalid for these world types
      return 0
      ;;
    *)
      # Default: parent-only if no --name/-n
      for arg in "$@"; do
        case "$arg" in
          --name|-n)
            return 1
            ;;
        esac
      done
      return 0
      ;;
  esac
}

# Create only the parent directory for a given world-type (no subfolders, no prompts)
# Usage: create_world_parent <world-type>
create_world_parent() {
  local world_type="$1"
  case "$world_type" in
    research)
      do_mkdir_p "RESEARCH_WORLD"
      if [ "$DRY_RUN" = true ]; then
        if [ "$JSON_OUTPUT" = false ]; then
          echo "DRY RUN: would create parent directory: RESEARCH_WORLD"
        fi
      else
        echo "Created parent directory: RESEARCH_WORLD"
      fi
      ;;
    journal)
      do_mkdir_p "JOURNAL_WORLD"
      if [ "$DRY_RUN" = true ]; then
        if [ "$JSON_OUTPUT" = false ]; then
          echo "DRY RUN: would create parent directory: JOURNAL_WORLD"
        fi
      else
        echo "Created parent directory: JOURNAL_WORLD"
      fi
      ;;
    lecture)
      do_mkdir_p "LECTURE_WORLD"
      if [ "$DRY_RUN" = true ]; then
        if [ "$JSON_OUTPUT" = false ]; then
          echo "DRY RUN: would create parent directory: LECTURE_WORLD"
        fi
      else
        echo "Created parent directory: LECTURE_WORLD"
      fi
      ;;
    coding)
      do_mkdir_p "CODING_WORLD"
      if [ "$DRY_RUN" = true ]; then
        if [ "$JSON_OUTPUT" = false ]; then
          echo "DRY RUN: would create parent directory: CODING_WORLD"
        fi
      else
        echo "Created parent directory: CODING_WORLD"
      fi
      ;;
    office)
      # Office creates standard structure even in parent-only mode
      echo "Creating OFFICE_WORLD standard folders..."
      for d in 00_admin 01_finance 02_hr_administration 03_faculty 04_inventory_equipment 05_software_licenses 06_public_relations; do
        do_mkdir_p "OFFICE_WORLD/$d"
      done
      if [ "$DRY_RUN" = true ]; then
        if [ "$JSON_OUTPUT" = false ]; then
          echo "DRY RUN: would create OFFICE_WORLD/"
        fi
      else
        echo "Created OFFICE_WORLD/"
      fi
      ;;
    private)
      # Private creates standard structure even in parent-only mode
      echo "Creating PRIVATE_WORLD standard folders..."
      for d in 00_admin 01_credentials 02_id_contracts 03_finance 04_documents 05_photos 06_movies 07_hiking 09_installers 90_archive; do
        do_mkdir_p "PRIVATE_WORLD/$d"
      done
      if [ "$DRY_RUN" = true ]; then
        if [ "$JSON_OUTPUT" = false ]; then
          echo "DRY RUN: would create PRIVATE_WORLD/"
        fi
      else
        echo "Created PRIVATE_WORLD/"
      fi
      ;;
    *)
      echo "Unknown world type: $world_type" >&2
      return 1
      ;;
  esac
}

# Detect if current directory is within a JOURNAL_WORLD structure
# Returns 0 (true) if current or any parent directory contains JOURNAL_WORLD
# Usage: is_in_journal_world
is_in_journal_world() {
  local current_dir
  current_dir="$(pwd)"
  
  # Walk up the directory tree looking for JOURNAL_WORLD
  while [ "$current_dir" != "/" ]; do
    # Check if current directory IS JOURNAL_WORLD
    if [ "$(basename "$current_dir")" = "JOURNAL_WORLD" ]; then
      return 0
    fi
    
    # Check if current directory contains JOURNAL_WORLD
    if [ -d "$current_dir/JOURNAL_WORLD" ]; then
      return 0
    fi
    
    # Move up one directory
    current_dir="$(dirname "$current_dir")"
  done
  
  # Not found
  return 1
}

# Validate role-based directory structure requirements
# Returns 0 if valid, 1 if invalid (with error messages to stderr)
# Usage: validate_journal_structure
validate_journal_structure() {
  # Check if we're in or have access to JOURNAL_WORLD
  if ! is_in_journal_world; then
    echo "Error: Not in JOURNAL_WORLD structure. Run 'dirforge init journal' first." >&2
    return 1
  fi
  
  # Find JOURNAL_WORLD root
  local journal_root
  journal_root="$(find_journal_world_root)"
  if [ -z "$journal_root" ]; then
    echo "Error: Could not locate JOURNAL_WORLD root directory." >&2
    return 1
  fi
  
  # Validate role directories exist
  local expected_roles=("00_admin" "01_primary_authorship" "02_coauthor_invites" "03_journal_service")
  local missing_roles=()
  
  for role in "${expected_roles[@]}"; do
    if [ ! -d "$journal_root/$role" ]; then
      missing_roles+=("$role")
    fi
  done
  
  if [ ${#missing_roles[@]} -gt 0 ]; then
    echo "Warning: Missing role directories in JOURNAL_WORLD:" >&2
    printf "  %s\n" "${missing_roles[@]}" >&2
    echo "Consider running 'dirforge init journal' to create missing structure." >&2
    return 1
  fi
  
  return 0
}

# Find the JOURNAL_WORLD root directory
# Returns the absolute path to JOURNAL_WORLD or empty if not found
# Usage: journal_root=$(find_journal_world_root)
find_journal_world_root() {
  local current_dir
  current_dir="$(pwd)"
  
  # Walk up the directory tree looking for JOURNAL_WORLD
  while [ "$current_dir" != "/" ]; do
    # Check if current directory IS JOURNAL_WORLD
    if [ "$(basename "$current_dir")" = "JOURNAL_WORLD" ]; then
      echo "$current_dir"
      return 0
    fi
    
    # Check if current directory contains JOURNAL_WORLD
    if [ -d "$current_dir/JOURNAL_WORLD" ]; then
      echo "$current_dir/JOURNAL_WORLD"
      return 0
    fi
    
    # Move up one directory
    current_dir="$(dirname "$current_dir")"
  done
  
  # Not found
  return 1
}

# Validate paper name format and convert to valid directory name with comprehensive error messages
# Returns 0 if valid, 1 if invalid (with detailed error to stderr)
# Outputs sanitized name to stdout
# Usage: sanitized_name=$(validate_paper_name "Paper Name")
validate_paper_name() {
  local paper_name="$1"
  
  # Check for empty input
  if [ -z "$paper_name" ]; then
    echo "Error: Paper name cannot be empty." >&2
    echo "  Expected format: descriptive name like 'thermal_conductivity_review' or 'seismic_hazard_analysis'" >&2
    echo "  Example: --name \"thermal_conductivity_review\"" >&2
    return 1
  fi
  
  # Check minimum length (at least 3 characters for meaningful names)
  if [ ${#paper_name} -lt 3 ]; then
    echo "Error: Paper name must be at least 3 characters long." >&2
    echo "  Current: '$paper_name' (${#paper_name} characters)" >&2
    echo "  Example: --name \"thermal_review\" (meaningful descriptive name)" >&2
    return 1
  fi
  
  # Check maximum length (filesystem limits and readability)
  if [ ${#paper_name} -gt 200 ]; then
    echo "Error: Paper name is too long (${#paper_name} characters, maximum 200)." >&2
    echo "  Try using a shorter, more focused description." >&2
    echo "  Example: Instead of a full title, use key terms like 'thermal_conductivity_review'" >&2
    return 1
  fi
  
  # Check for invalid characters with specific guidance
  if echo "$paper_name" | grep -q '[<>:"|?*\\]'; then
    echo "Error: Paper name contains invalid filesystem characters." >&2
    echo "  Invalid characters found: $(echo "$paper_name" | grep -o '[<>:"|?*\\]' | tr '\n' ' ')" >&2
    echo "  These characters are not allowed in directory names: < > : \" | ? * \\" >&2
    echo "  Example: Use 'thermal_analysis' instead of 'thermal:analysis'" >&2
    return 1
  fi
  
  # Check for problematic patterns
  if echo "$paper_name" | grep -q '^\.\|/$\|/\.\|\./$'; then
    echo "Error: Paper name contains problematic path patterns." >&2
    echo "  Cannot start with '.', end with '/', or contain './' or './'" >&2
    echo "  Example: Use 'thermal_review' instead of './thermal_review'" >&2
    return 1
  fi
  
  # Check for multiple consecutive separators before sanitization
  if echo "$paper_name" | grep -q '  \|__\|--\|\.\.'; then
    echo "Warning: Paper name contains multiple consecutive separators." >&2
    echo "  These will be cleaned up: '  ' -> '_', '__' -> '_', '--' -> '_'" >&2
  fi
  
  # Check for year prefix format if provided
  if echo "$paper_name" | grep -q '^[0-9]\{4\}_'; then
    local year_part
    year_part=$(echo "$paper_name" | cut -d'_' -f1)
    if [ "$year_part" -lt 1900 ] || [ "$year_part" -gt 2100 ]; then
      echo "Error: Year prefix '$year_part' is outside reasonable range (1900-2100)." >&2
      echo "  Current format: '$paper_name'" >&2
      echo "  Example: Use '2025_thermal_review' for 2025 papers" >&2
      return 1
    fi
  fi
  
  # Check for characters beyond the allowed set: letters, numbers, spaces, hyphens, underscores
  if echo "$paper_name" | grep -q '[^a-zA-Z0-9 _-]'; then
    echo "Error: Paper name contains characters beyond the allowed set." >&2
    echo "  Allowed: letters, numbers, spaces, hyphens, underscores" >&2
    echo "  Invalid characters found: $(echo "$paper_name" | grep -o '[^a-zA-Z0-9 _-]' | tr '\n' ' ' | sed 's/ *$//')" >&2
    echo "  Example: Use 'thermal_analysis' instead of 'thermal@analysis'" >&2
    return 1
  fi
  
  # Convert to lowercase with underscores (standard format)
  local sanitized
  sanitized=$(echo "$paper_name" | tr '[:upper:]' '[:lower:]' | tr ' -' '_' | sed 's/[^a-z0-9_]/_/g' | sed 's/__*/_/g' | sed 's/^_\|_$//g')
  
  # Check if sanitization resulted in empty string
  if [ -z "$sanitized" ]; then
    echo "Error: Paper name results in empty directory name after sanitization." >&2
    echo "  Original: '$paper_name'" >&2
    echo "  After cleanup: empty" >&2
    echo "  Try using more letters and numbers, avoiding only special characters." >&2
    echo "  Example: --name \"thermal_analysis\" (uses letters and underscores)" >&2
    return 1
  fi
  
  # Check if sanitized name is too short after cleanup
  if [ ${#sanitized} -lt 2 ]; then
    echo "Error: Paper name becomes too short after sanitization." >&2
    echo "  Original: '$paper_name'" >&2
    echo "  After cleanup: '$sanitized' (${#sanitized} characters)" >&2
    echo "  Use a longer, more descriptive name with letters and numbers." >&2
    echo "  Example: --name \"thermal_review\" (results in 'thermal_review')" >&2
    return 1
  fi
  
  # Check for reserved names that might conflict with system directories
  case "$sanitized" in
    "admin"|"manuscript"|"reviews"|"correspondence"|"tmp"|"temp"|"test"|"src"|"bin"|"lib"|"etc")
      echo "Error: Paper name '$sanitized' conflicts with system directory names." >&2
      echo "  Reserved names: admin, manuscript, reviews, correspondence, tmp, temp, test, src, bin, lib, etc" >&2
      echo "  Example: Use 'thermal_admin_study' instead of 'admin'" >&2
      return 1
      ;;
  esac
  
  # Success: output sanitized name
  echo "$sanitized"
  return 0
}

# Validate year format (4-digit YYYY)
# Returns 0 if valid, 1 if invalid (with error to stderr)
# Usage: validate_year_format "2025"
validate_year_format() {
  local year="$1"
  
  if [ -z "$year" ]; then
    echo "Error: Year cannot be empty." >&2
    return 1
  fi
  
  # Check if it's exactly 4 digits
  if ! echo "$year" | grep -q '^[0-9]\{4\}$'; then
    echo "Error: Year must be a 4-digit number (YYYY)." >&2
    return 1
  fi
  
  # Basic sanity check for reasonable year range
  if [ "$year" -lt 1990 ] || [ "$year" -gt 2030 ]; then
    echo "Warning: Year '$year' seems unusual (expected 1990-2030)." >&2
  fi
  
  return 0
}

# Validate journal name for service structure
# Returns 0 if valid, 1 if invalid (with detailed error to stderr)
# Outputs sanitized journal name to stdout
# Usage: sanitized_journal=$(validate_journal_name "Journal Name")
validate_journal_name() {
  local journal_name="$1"
  
  # Check for empty input
  if [ -z "$journal_name" ]; then
    echo "Error: Journal name cannot be empty." >&2
    echo "  Expected format: descriptive journal name like 'nature_geoscience' or 'journal_structural_geology'" >&2
    echo "  Example: --name \"nature_geoscience\"" >&2
    return 1
  fi
  
  # Check minimum length (at least 3 characters for meaningful names)
  if [ ${#journal_name} -lt 3 ]; then
    echo "Error: Journal name must be at least 3 characters long." >&2
    echo "  Current: '$journal_name' (${#journal_name} characters)" >&2
    echo "  Example: --name \"nature\" (short journal name)" >&2
    return 1
  fi
  
  # Check maximum length (filesystem limits and readability)
  if [ ${#journal_name} -gt 100 ]; then
    echo "Error: Journal name is too long (${#journal_name} characters, maximum 100)." >&2
    echo "  Try using a shorter journal name or abbreviation." >&2
    echo "  Example: Use 'nature_geosci' instead of full journal title" >&2
    return 1
  fi
  
  # Check for invalid characters with specific guidance
  if echo "$journal_name" | grep -q '[<>:"|?*\\]'; then
    echo "Error: Journal name contains invalid filesystem characters." >&2
    echo "  Invalid characters found: $(echo "$journal_name" | grep -o '[<>:"|?*\\]' | tr '\n' ' ')" >&2
    echo "  These characters are not allowed in directory names: < > : \" | ? * \\" >&2
    echo "  Example: Use 'nature_geoscience' instead of 'nature:geoscience'" >&2
    return 1
  fi
  
  # Convert to lowercase with underscores, removing special chars
  local sanitized
  sanitized=$(echo "$journal_name" | tr '[:upper:]' '[:lower:]' | tr ' -' '_' | sed 's/[^a-z0-9_]/_/g' | sed 's/__*/_/g' | sed 's/^_\|_$//g')
  
  # Check if sanitization resulted in empty string
  if [ -z "$sanitized" ]; then
    echo "Error: Journal name results in empty directory name after sanitization." >&2
    echo "  Original: '$journal_name'" >&2
    echo "  After cleanup: empty" >&2
    echo "  Try using more letters and numbers, avoiding only special characters." >&2
    echo "  Example: --name \"nature_geoscience\" (uses letters and underscores)" >&2
    return 1
  fi
  
  # Check if sanitized name is too short after cleanup
  if [ ${#sanitized} -lt 2 ]; then
    echo "Error: Journal name becomes too short after sanitization." >&2
    echo "  Original: '$journal_name'" >&2
    echo "  After cleanup: '$sanitized' (${#sanitized} characters)" >&2
    echo "  Use a longer, more descriptive journal name with letters and numbers." >&2
    echo "  Example: --name \"nature\" (results in 'nature')" >&2
    return 1
  fi
  
  # Success: output sanitized name
  echo "$sanitized"
  return 0
}

# Validate manuscript ID format for service structure
# Returns 0 if valid, 1 if invalid (with detailed error to stderr)
# Usage: validate_manuscript_id "GJI-S-25-0928"
validate_manuscript_id() {
  local manuscript_id="$1"
  
  # Check for empty input
  if [ -z "$manuscript_id" ]; then
    echo "Error: Manuscript ID cannot be empty." >&2
    echo "  Expected format: journal manuscript ID like 'GJI-S-25-0928' or 'NATURE-2024-12345'" >&2
    echo "  Example: --id \"GJI-S-25-0928\"" >&2
    return 1
  fi
  
  # Check minimum length (at least 3 characters for meaningful IDs)
  if [ ${#manuscript_id} -lt 3 ]; then
    echo "Error: Manuscript ID must be at least 3 characters long." >&2
    echo "  Current: '$manuscript_id' (${#manuscript_id} characters)" >&2
    echo "  Example: --id \"ABC123\" (short manuscript ID)" >&2
    return 1
  fi
  
  # Check maximum length (filesystem limits)
  if [ ${#manuscript_id} -gt 50 ]; then
    echo "Error: Manuscript ID is too long (${#manuscript_id} characters, maximum 50)." >&2
    echo "  Try using a shorter manuscript ID." >&2
    echo "  Example: Use 'GJI-2025-123' instead of very long IDs" >&2
    return 1
  fi
  
  # Check for invalid filesystem characters
  if echo "$manuscript_id" | grep -q '[<>:"|?*\\]'; then
    echo "Error: Manuscript ID contains invalid filesystem characters." >&2
    echo "  Invalid characters found: $(echo "$manuscript_id" | grep -o '[<>:"|?*\\]' | tr '\n' ' ')" >&2
    echo "  These characters are not allowed in directory names: < > : \" | ? * \\" >&2
    echo "  Example: Use 'GJI-S-25-0928' instead of 'GJI:S:25:0928'" >&2
    return 1
  fi
  
  # Check for characters beyond the allowed set: letters, numbers, dots, hyphens, underscores
  if echo "$manuscript_id" | grep -q '[^a-zA-Z0-9._-]'; then
    echo "Error: Manuscript ID contains characters beyond the allowed set." >&2
    echo "  Allowed: letters, numbers, dots, hyphens, underscores" >&2
    echo "  Invalid characters found: $(echo "$manuscript_id" | grep -o '[^a-zA-Z0-9._-]' | tr '\n' ' ' | sed 's/ *$//')" >&2
    echo "  Example: Use 'GJI-S-25-0928' instead of 'GJI@S@25@0928'" >&2
    return 1
  fi
  
  # Validate that it contains at least some letters or numbers (not just separators)
  if ! echo "$manuscript_id" | grep -q '[a-zA-Z0-9]'; then
    echo "Error: Manuscript ID must contain at least one letter or number." >&2
    echo "  Current: '$manuscript_id' (only separators)" >&2
    echo "  Example: --id \"GJI-123\" (contains letters and numbers)" >&2
    return 1
  fi
  
  return 0
}

# Create role-based JOURNAL_WORLD directory structure
# Returns 0 if successful, 1 if error (with error to stderr)
# Usage: create_journal_role_structure
create_journal_role_structure() {
  # Find or create JOURNAL_WORLD root
  local journal_root
  journal_root="$(find_journal_world_root)"
  
  if [ -z "$journal_root" ]; then
    # Create JOURNAL_WORLD parent directory
    do_mkdir_p "JOURNAL_WORLD"
    journal_root="$(pwd)/JOURNAL_WORLD"
    
    if [ "$DRY_RUN" = true ]; then
      if [ "$JSON_OUTPUT" = false ]; then
        echo "DRY RUN: would create JOURNAL_WORLD structure"
      fi
    else
      echo "Created JOURNAL_WORLD directory"
    fi
  fi
  
  # Create all role directories
  local role_dirs=("00_admin" "01_primary_authorship" "02_coauthor_invites" "03_journal_service")
  for role in "${role_dirs[@]}"; do
    do_mkdir_p "$journal_root/$role"
  done
  
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create role-based structure in $journal_root"
    fi
  else
    echo "Created role-based directory structure in $journal_root"
  fi
  
  return 0
}

# Create primary authorship project directory with standard subdirectories
# Returns 0 if successful, 1 if error (with error to stderr)
# Usage: create_primary_authorship_project <paper_name> <year>
create_primary_authorship_project() {
  local paper_name="$1"
  local year="$2"
  
  # Use path construction utility to build project path
  local project_path
  if ! project_path="$(construct_primary_authorship_path "$paper_name" "$year")"; then
    return 1
  fi
  
  # Check for conflicts (only in non-dry-run mode)
  if [ "$DRY_RUN" = false ] && [ -d "$project_path" ]; then
    echo "Error: Primary authorship project already exists: $project_path" >&2
    return 1
  fi
  
  # Create project directory first
  do_mkdir_p "$project_path"
  
  # Create standard subdirectories with comprehensive validation
  if ! create_standard_subdirectories "$project_path"; then
    return 1
  fi
  
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create primary authorship project: $project_path"
    fi
  else
    echo "Created primary authorship project: $project_path"
  fi
  
  return 0
}

# Create co-author collaboration project directory with standard subdirectories  
# Returns 0 if successful, 1 if error (with error to stderr)
# Usage: create_coauthor_project <paper_name> <year>
create_coauthor_project() {
  local paper_name="$1"
  local year="$2"
  
  # Use path construction utility to build project path
  local project_path
  if ! project_path="$(construct_coauthor_path "$paper_name" "$year")"; then
    return 1
  fi
  
  # Check for conflicts (only in non-dry-run mode)
  if [ "$DRY_RUN" = false ] && [ -d "$project_path" ]; then
    echo "Error: Co-author project already exists: $project_path" >&2
    return 1
  fi
  
  # Create project directory first
  do_mkdir_p "$project_path"
  
  # Create standard subdirectories with comprehensive validation
  if ! create_standard_subdirectories "$project_path"; then
    return 1
  fi
  
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create co-author project: $project_path"
    fi
  else
    echo "Created co-author project: $project_path"
  fi
  
  return 0
}

# Create journal service project directory with two-level structure
# Returns 0 if successful, 1 if error (with error to stderr)
# Usage: create_journal_service_project <journal_name> <manuscript_id>
create_journal_service_project() {
  local journal_name="$1"
  local manuscript_id="$2"
  
  # Use path construction utility to build project path
  local project_path
  if ! project_path="$(construct_service_path "$journal_name" "$manuscript_id")"; then
    return 1
  fi
  
  # Check for conflicts (only in non-dry-run mode)
  if [ "$DRY_RUN" = false ] && [ -d "$project_path" ]; then
    echo "Error: Journal service project already exists: $project_path" >&2
    return 1
  fi
  
  # Create project directory first
  do_mkdir_p "$project_path"
  
  # Create standard subdirectories with comprehensive validation
  if ! create_standard_subdirectories "$project_path"; then
    return 1
  fi
  
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create journal service project: $project_path"
    fi
  else
    echo "Created journal service project: $project_path"
  fi
  
  return 0
}

# Extract year from paper name if embedded (YYYY_ prefix format)
# Returns extracted year or current year as fallback
# Usage: year=$(extract_year_from_paper_name "2021_elastic_properties")
extract_year_from_paper_name() {
  local paper_name="$1"
  
  # Check for YYYY_ prefix pattern
  if echo "$paper_name" | grep -q '^[0-9]\{4\}_'; then
    # Extract the year prefix
    echo "$paper_name" | cut -d'_' -f1
  else
    # Return current year as default
    date +%Y
  fi
}

# Strip year prefix from paper name if present
# Returns paper name without year prefix
# Usage: clean_name=$(strip_year_from_paper_name "2021_elastic_properties")
strip_year_from_paper_name() {
  local paper_name="$1"
  
  # Check for YYYY_ prefix pattern
  if echo "$paper_name" | grep -q '^[0-9]\{4\}_'; then
    # Remove the year prefix
    echo "$paper_name" | sed 's/^[0-9]\{4\}_//'
  else
    # Return unchanged if no year prefix
    echo "$paper_name"
  fi
}

# Role-based path construction utilities
# These functions implement the Path Resolution Algorithm from the contracts

# Construct primary authorship project path
# Returns the full path to the project directory
# Usage: path=$(construct_primary_authorship_path <paper_name> <year>)
construct_primary_authorship_path() {
  local paper_name="$1"
  local year="$2"
  local journal_root="${3:-}"
  
  # Validate inputs
  local sanitized_name
  if ! sanitized_name="$(validate_paper_name "$paper_name")"; then
    return 1
  fi
  
  if ! validate_year_format "$year"; then
    return 1
  fi
  
  # Use provided journal root or find it
  if [ -z "$journal_root" ]; then
    journal_root="$(find_journal_world_root)"
    if [ -z "$journal_root" ]; then
      if [ "$DRY_RUN" = true ]; then
        journal_root="$(pwd)/JOURNAL_WORLD"
      else
        echo "Error: JOURNAL_WORLD not found" >&2
        return 1
      fi
    fi
  fi
  
  # Algorithm: "01_primary_authorship/{year}_{paper_name}/"
  echo "$journal_root/01_primary_authorship/${year}_${sanitized_name}"
  return 0
}

# Construct co-author collaboration project path
# Returns the full path to the project directory  
# Usage: path=$(construct_coauthor_path <paper_name> <year>)
construct_coauthor_path() {
  local paper_name="$1"
  local year="$2"
  local journal_root="${3:-}"
  
  # Validate inputs
  local sanitized_name
  if ! sanitized_name="$(validate_paper_name "$paper_name")"; then
    return 1
  fi
  
  if ! validate_year_format "$year"; then
    return 1
  fi
  
  # Use provided journal root or find it
  if [ -z "$journal_root" ]; then
    journal_root="$(find_journal_world_root)"
    if [ -z "$journal_root" ]; then
      if [ "$DRY_RUN" = true ]; then
        journal_root="$(pwd)/JOURNAL_WORLD"
      else
        echo "Error: JOURNAL_WORLD not found" >&2
        return 1
      fi
    fi
  fi
  
  # Algorithm: "02_coauthor_invites/{year}_{paper_name}/"
  echo "$journal_root/02_coauthor_invites/${year}_${sanitized_name}"
  return 0
}

# Construct journal service project path
# Returns the full path to the project directory
# Usage: path=$(construct_service_path <journal_name> <manuscript_id>)
construct_service_path() {
  local journal_name="$1"
  local manuscript_id="$2"
  local journal_root="${3:-}"
  
  # Validate inputs
  local sanitized_journal
  if ! sanitized_journal="$(validate_journal_name "$journal_name")"; then
    return 1
  fi
  
  if ! validate_manuscript_id "$manuscript_id"; then
    return 1
  fi
  
  # Use provided journal root or find it
  if [ -z "$journal_root" ]; then
    journal_root="$(find_journal_world_root)"
    if [ -z "$journal_root" ]; then
      if [ "$DRY_RUN" = true ]; then
        journal_root="$(pwd)/JOURNAL_WORLD"
      else
        echo "Error: JOURNAL_WORLD not found" >&2
        return 1
      fi
    fi
  fi
  
  # Algorithm: "03_journal_service/{journal_lower}/{manuscript_id}/"
  echo "$journal_root/03_journal_service/${sanitized_journal}/${manuscript_id}"
  return 0
}

# Construct standard subdirectory paths for any journal project
# Returns array of subdirectory paths  
# Usage: subdirs=($(construct_standard_subdirs <project_path>))
construct_standard_subdirs() {
  local project_path="$1"
  
  if [ -z "$project_path" ]; then
    echo "Error: Project path cannot be empty" >&2
    return 1
  fi
  
  # Standard subdirectories according to contracts
  echo "$project_path/01_manuscript"
  echo "$project_path/02_reviews"
  echo "$project_path/03_correspondence"
  return 0
}

# Create standard subdirectories with comprehensive permission and conflict validation
# Returns 0 if successful, 1 if error (with detailed error messages to stderr)
# Usage: create_standard_subdirectories <project_path> [--force-overwrite]
create_standard_subdirectories() {
  local project_path="$1"
  local force_overwrite=false
  
  # Parse optional arguments
  shift
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --force-overwrite)
        force_overwrite=true
        ;;
      *)
        echo "Error: Unknown argument to create_standard_subdirectories: $1" >&2
        return 1
        ;;
    esac
    shift
  done
  
  if [ -z "$project_path" ]; then
    echo "Error: Project path cannot be empty" >&2
    return 1
  fi
  
  # Validate project path exists or can be created
  if [ "$DRY_RUN" = false ]; then
    if [ ! -d "$project_path" ]; then
      echo "Error: Project directory does not exist: $project_path" >&2
      return 1
    fi
    
    # Check write permission on project directory
    if [ ! -w "$project_path" ]; then
      echo "Error: No write permission for project directory: $project_path" >&2
      return 1
    fi
  fi
  
  # Get standard subdirectory paths
  local subdirs
  subdirs=($(construct_standard_subdirs "$project_path"))
  if [ $? -ne 0 ]; then
    return 1
  fi
  
  # Check for conflicts and permission issues
  local conflicts=()
  local permission_issues=()
  
  for subdir in "${subdirs[@]}"; do
    if [ "$DRY_RUN" = false ]; then
      # Check if subdirectory already exists
      if [ -d "$subdir" ]; then
        if [ "$force_overwrite" = false ]; then
          conflicts+=("$subdir")
        fi
      fi
      
      # Check if parent directory is writable
      local parent_dir
      parent_dir="$(dirname "$subdir")"
      if [ -d "$parent_dir" ] && [ ! -w "$parent_dir" ]; then
        permission_issues+=("$parent_dir (cannot create $subdir)")
      fi
      
      # Check if subdirectory exists but is not a directory (e.g., a file)
      if [ -e "$subdir" ] && [ ! -d "$subdir" ]; then
        echo "Error: Path exists but is not a directory: $subdir" >&2
        return 1
      fi
    fi
  done
  
  # Report conflicts if any
  if [ ${#conflicts[@]} -gt 0 ]; then
    echo "Error: Standard subdirectories already exist:" >&2
    for conflict in "${conflicts[@]}"; do
      echo "  $conflict" >&2
    done
    echo "Use --force-overwrite to proceed anyway, or remove existing directories." >&2
    return 1
  fi
  
  # Report permission issues if any
  if [ ${#permission_issues[@]} -gt 0 ]; then
    echo "Error: Permission denied for subdirectory creation:" >&2
    for issue in "${permission_issues[@]}"; do
      echo "  $issue" >&2
    done
    echo "Check directory permissions and ownership." >&2
    return 1
  fi
  
  # Create subdirectories
  for subdir in "${subdirs[@]}"; do
    do_mkdir_p "$subdir"
  done
  
  # Validate creation success (in non-dry-run mode)
  if [ "$DRY_RUN" = false ]; then
    local creation_failures=()
    for subdir in "${subdirs[@]}"; do
      if [ ! -d "$subdir" ]; then
        creation_failures+=("$subdir")
      fi
    done
    
    if [ ${#creation_failures[@]} -gt 0 ]; then
      echo "Error: Failed to create subdirectories:" >&2
      for failure in "${creation_failures[@]}"; do
        echo "  $failure" >&2
      done
      return 1
    fi
    
    # Verify permissions on created directories
    local permission_failures=()
    for subdir in "${subdirs[@]}"; do
      if [ ! -w "$subdir" ] || [ ! -r "$subdir" ]; then
        permission_failures+=("$subdir")
      fi
    done
    
    if [ ${#permission_failures[@]} -gt 0 ]; then
      echo "Warning: Created subdirectories have unexpected permissions:" >&2
      for failure in "${permission_failures[@]}"; do
        echo "  $failure (check read/write permissions)" >&2
      done
      # Don't return error for this - it's a warning
    fi
  fi
  
  return 0
}

# Validate role-based path structure
# Returns 0 if valid role-based path, 1 if invalid  
# Usage: validate_role_path <path>
validate_role_path() {
  local path="$1"
  
  if [ -z "$path" ]; then
    echo "Error: Path cannot be empty" >&2
    return 1
  fi
  
  # Check if path contains JOURNAL_WORLD
  if ! echo "$path" | grep -q "JOURNAL_WORLD"; then
    echo "Error: Path must be within JOURNAL_WORLD structure" >&2
    return 1
  fi
  
  # Check for valid role directory pattern
  if echo "$path" | grep -q "JOURNAL_WORLD/01_primary_authorship/[0-9]\{4\}_[a-z0-9_]\+"; then
    return 0  # Primary authorship path
  elif echo "$path" | grep -q "JOURNAL_WORLD/02_coauthor_invites/[0-9]\{4\}_[a-z0-9_]\+"; then
    return 0  # Co-author path
  elif echo "$path" | grep -q "JOURNAL_WORLD/03_journal_service/[a-z0-9_]\+/[a-zA-Z0-9._-]\+"; then
    return 0  # Journal service path
  elif echo "$path" | grep -q "JOURNAL_WORLD/00_admin"; then
    return 0  # Admin path (manual creation)
  else
    echo "Error: Path does not match any valid role-based pattern" >&2
    return 1
  fi
}

# Extract role type from journal path
# Returns role name (primary_authorship, coauthor_invites, journal_service, admin)
# Usage: role=$(extract_role_from_path <path>)
extract_role_from_path() {
  local path="$1"
  
  if [ -z "$path" ]; then
    echo "Error: Path cannot be empty" >&2
    return 1
  fi
  
  if echo "$path" | grep -q "/01_primary_authorship/"; then
    echo "primary_authorship"
  elif echo "$path" | grep -q "/02_coauthor_invites/"; then
    echo "coauthor_invites"
  elif echo "$path" | grep -q "/03_journal_service/"; then
    echo "journal_service"
  elif echo "$path" | grep -q "/00_admin/"; then
    echo "admin"
  else
    echo "Error: Cannot determine role from path: $path" >&2
    return 1
  fi
}

# Get the role directory for a given role type
# Returns the role directory name (e.g., "01_primary_authorship")
# Usage: role_dir=$(get_role_directory <role_name>)
get_role_directory() {
  local role_name="$1"
  
  case "$role_name" in
    primary_authorship|primary|first)
      echo "01_primary_authorship"
      ;;
    coauthor_invites|coauthor|collaboration)
      echo "02_coauthor_invites" 
      ;;
    journal_service|service|editorial)
      echo "03_journal_service"
      ;;
    admin|administrative)
      echo "00_admin"
      ;;
    *)
      echo "Error: Unknown role name: $role_name" >&2
      return 1
      ;;
  esac
}

create_conda_env() {
  local env_name="$1"; shift
  local py_ver="$1"; shift
  local packages="$*"
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create conda environment: $env_name (python=$py_ver)"
    fi
    return 0
  fi
  if ! command -v conda >/dev/null 2>&1; then
    echo "Conda not found in PATH â€” skipping env creation (or use --no-conda to suppress)." >&2
    return 0
  fi
  if conda_env_exists "$env_name"; then
    echo "Conda environment '$env_name' already exists - skipping creation."
    return 0
  fi
  echo "Creating conda environment: $env_name"
  conda create -n "$env_name" python="$py_ver" $packages -y
}

export_environment_yaml() {
  local env_name="$1"; shift
  local dest="$1"; shift
  local py_ver="$1"; shift
  local packages="$*"
  do_mkdir_p "$(dirname "$dest")"
  write_file "$dest" <<EOF
name: $env_name
channels:
  - defaults
dependencies:
  - python=$py_ver
$(for p in $packages; do echo "  - $p"; done)
EOF
}

init_research() {
  local name="${NAME:-}" project_id="" study_name="" py_ver="${PY:-3.11}" no_conda=false extra_pkgs=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --name|-n) shift; name="$1";;
      --project|-p) shift; project_id="$1";;
      --study|-s) shift; study_name="$1";;
      --python) shift; py_ver="$1";;
      --no-conda) no_conda=true;;
      --conda-packages) shift; extra_pkgs="$1";;
      *) echo "Unknown arg: $1"; exit 1;;
    esac
    shift
  done
  
  # Determine operation mode
  if [ -n "$project_id" ] && [ -n "$study_name" ]; then
    # Study creation mode
    init_research_study --project "$project_id" --study "$study_name"
    return
  elif [ -n "$name" ] && [ -n "$study_name" ]; then
    # Combined project + study creation
    # First create project, then create study
    local args=()
    [ -n "$name" ] && args+=(--name "$name")
    [ -n "$py_ver" ] && args+=(--python "$py_ver")
    [ "$no_conda" = true ] && args+=(--no-conda)
    [ -n "$extra_pkgs" ] && args+=(--conda-packages "$extra_pkgs")
    init_research_project_only "${args[@]}"
    # Extract project ID from what was just created
    local id_raw
    id_raw=$(to_snake_case "$name")
    local year
    year=$(date +%Y)
    if [[ "$id_raw" =~ ^[0-9]{4}_ ]]; then
      project_id="$id_raw"
    else
      project_id="${year}_$id_raw"
    fi
    init_research_study --project "$project_id" --study "$study_name"
    return
  elif [ -n "$name" ]; then
    # Project creation mode
    local args=()
    [ -n "$name" ] && args+=(--name "$name")
    [ -n "$py_ver" ] && args+=(--python "$py_ver")
    [ "$no_conda" = true ] && args+=(--no-conda)
    [ -n "$extra_pkgs" ] && args+=(--conda-packages "$extra_pkgs")
    init_research_project_only "${args[@]}"
    return
  else
    show_research_missing_args_error "$PROG_NAME"
    exit 1
  fi
}

init_research_project_only() {
  local name="" py_ver="${PY:-3.11}" no_conda=false extra_pkgs=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --name|-n) shift; name="$1";;
      --python) shift; py_ver="$1";;
      --no-conda) no_conda=true;;
      --conda-packages) shift; extra_pkgs="$1";;
      *) echo "Unknown arg: $1"; exit 1;;
    esac
    shift
  done
  if [ -z "$name" ]; then
    read -r -p "Project name: " name
  fi
  local title="$name"  # Set title for template rendering
  local id_raw
  id_raw=$(to_snake_case "$name")
  # prefix with year if not present
  local year
  year=$(date +%Y)
  if [[ "$id_raw" =~ ^[0-9]{4}_ ]]; then
    PROJECT_ID="$id_raw"
  else
    PROJECT_ID="${year}_$id_raw"
  fi
  # conda env name
  local id_no_year
  id_no_year=$(strip_year_prefix "$PROJECT_ID")
  CONDA_NAME="research_${id_no_year}"

  RESEARCH_ROOT="RESEARCH_WORLD/$PROJECT_ID"
  if [ -d "$RESEARCH_ROOT" ]; then
    if [ "$FORCE" = false ] && [ "$BACKUP" = false ]; then
      echo "Project '$PROJECT_ID' already exists at $RESEARCH_ROOT" >&2
      echo "Use --force to overwrite or --backup to create a backup before overwriting" >&2
      exit 1
    fi
    
    # Prompt for confirmation unless --yes is set
    prompt_overwrite "$RESEARCH_ROOT"
    
    # Create backup if requested
    if [ "$BACKUP" = true ]; then
      backup_directory "$RESEARCH_ROOT"
    fi
    
    # Remove existing directory
    if [ "$DRY_RUN" = false ]; then
      rm -rf "$RESEARCH_ROOT"
    fi
  fi
  do_mkdir_p "$RESEARCH_ROOT"
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create directory: $RESEARCH_ROOT"
    fi
  else
    echo "Created directory: $RESEARCH_ROOT"
  fi

  # create numbered subfolders
  for d in 00_admin 01_project_management 02_studies; do
    do_mkdir_p "$RESEARCH_ROOT/$d"
  done

  # Create project management subdirectories
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/01_proposal/01_draft"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/01_proposal/02_submission"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/01_proposal/03_review"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/01_proposal/04_final"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/02_finance"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/03_reports"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/04_presentations"

  # Create .integrity directories (constitution v1.0.12)
  do_mkdir_p "$RESEARCH_ROOT/.integrity/checksums"
  do_mkdir_p "$RESEARCH_ROOT/.integrity/manifests"

  # create files
  write_file "$RESEARCH_ROOT/README.md" <<EOF
# $PROJECT_ID

Created: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
Conda env: $CONDA_NAME

## Project Structure

This research project follows the DirForge Constitution v1.0.17 study-based organization:

- \`00_admin/\` - Project contracts, ethics, agreements
- \`01_project_management/\` - Proposals, reports, budgets
- \`02_studies/\` - Container for individual research studies

## Creating Studies

Add studies to this project using:
\`\`\`bash
dirforge init research --project $PROJECT_ID --study "Study Name"
\`\`\`

Each study will be created in \`02_studies/<study_name>/\` with its own protocols, code, data, outputs, and publications.
EOF

  write_file "$RESEARCH_ROOT/project.yaml" <<'EOF'
owner: "<owner name>"
contact: "<email@example.org>"
license: "CC-BY-4.0"
sync_policy: "iCloud: active, External: raw_data_on_nas"
conda_env: "$CONDA_NAME"
EOF

  # Render project management templates
  render_template "$TEMPLATES_DIR/research/01_project_management/README.md.template" "$RESEARCH_ROOT/01_project_management/README.md" "PROJECT_NAME=$title" "PROJECT_ID=$PROJECT_ID"
  render_template "$TEMPLATES_DIR/research/01_project_management/01_proposal/README.md.template" "$RESEARCH_ROOT/01_project_management/01_proposal/README.md" "PROJECT_NAME=$title" "PROJECT_ID=$PROJECT_ID"
  render_template "$TEMPLATES_DIR/research/01_project_management/02_finance/README.md.template" "$RESEARCH_ROOT/01_project_management/02_finance/README.md" "PROJECT_NAME=$title" "PROJECT_ID=$PROJECT_ID"
  render_template "$TEMPLATES_DIR/research/01_project_management/03_reports/README.md.template" "$RESEARCH_ROOT/01_project_management/03_reports/README.md" "PROJECT_NAME=$title" "PROJECT_ID=$PROJECT_ID"
  render_template "$TEMPLATES_DIR/research/01_project_management/04_presentations/README.md.template" "$RESEARCH_ROOT/01_project_management/04_presentations/README.md" "PROJECT_NAME=$title" "PROJECT_ID=$PROJECT_ID"

  # Conda
  if [ "$no_conda" = false ]; then
    local base_pkgs="numpy matplotlib pandas jupyter pyyaml"
    if [ -n "$extra_pkgs" ]; then
      base_pkgs="$base_pkgs $extra_pkgs"
    fi
    create_conda_env "$CONDA_NAME" "$py_ver" $base_pkgs || true
    export_environment_yaml "$CONDA_NAME" "$RESEARCH_ROOT/environment.yaml" "$py_ver" $base_pkgs
    echo "Activate with: conda activate $CONDA_NAME"
  else
    if [ "$JSON_OUTPUT" = false ]; then
      echo "--no-conda specified: skipping conda creation"
    fi
  fi

  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create research project '$PROJECT_ID' in $RESEARCH_ROOT"
    fi
  else
    echo "Created research project '$PROJECT_ID' in $RESEARCH_ROOT"
  fi
}

init_research_study() {
  local project_id="" study_name=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --project|-p) shift; project_id="$1";;
      --study|-s) shift; study_name="$1";;
      *) echo "Unknown arg for study: $1"; exit 1;;
    esac
    shift
  done

  if [ -z "$project_id" ]; then
    show_required_arg_error "--project" "$PROG_NAME" "research"
    exit 1
  fi
  if [ -z "$study_name" ]; then
    show_required_arg_error "--study" "$PROG_NAME" "research"
    exit 1
  fi

  local PROJECT_ROOT="RESEARCH_WORLD/$project_id"
  
  # Check if project exists (skip in dry-run mode for combined operations)
  if [ "$DRY_RUN" = false ] && [ ! -d "$PROJECT_ROOT" ]; then
    show_project_not_found_error "$project_id" "$PROJECT_ROOT"
    exit 1
  fi
  
  # Sanitize study name
  local study_id
  study_id=$(to_snake_case "$study_name")
  
  local STUDY_ROOT="$PROJECT_ROOT/02_studies/$study_id"
  if [ -d "$STUDY_ROOT" ]; then
    if [ "$FORCE" = false ] && [ "$BACKUP" = false ]; then
      echo "Study '$study_id' already exists at $STUDY_ROOT" >&2
      echo "Use --force to overwrite or --backup to create a backup before overwriting" >&2
      exit 1
    fi
    
    prompt_overwrite "$STUDY_ROOT"
    
    if [ "$BACKUP" = true ]; then
      backup_directory "$STUDY_ROOT"
    fi
    
    if [ "$DRY_RUN" = false ]; then
      rm -rf "$STUDY_ROOT"
    fi
  fi
  
  do_mkdir_p "$STUDY_ROOT"
  
  # Create study subdirectories
  for d in 00_protocols 01_code 02_data 03_outputs 04_publication 05_presentations; do
    do_mkdir_p "$STUDY_ROOT/$d"
  done
  
  # Create study .integrity directories
  do_mkdir_p "$STUDY_ROOT/.integrity/checksums"
  do_mkdir_p "$STUDY_ROOT/.integrity/manifests"
  
  # Create study README.md
  write_file "$STUDY_ROOT/README.md" <<EOF
# $study_name ($study_id)

Created: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
Project: $project_id

## Study Overview

**Research Question:** [Brief description of the specific research question this study addresses]

**Methods:** [Brief description of experimental/computational methods]

**Expected Outcomes:** [What results or insights this study aims to produce]

## Directory Structure

- \`00_protocols/\` - Experimental protocols, calibration notes, instrument configurations
- \`01_code/\` - Analysis scripts, notebooks, environment.yml
- \`02_data/\` - Raw and processed datasets, metadata.yaml files
- \`03_outputs/\` - Processed results, figures, tables
- \`04_publication/\` - Manuscript drafts, supplementary materials
- \`05_presentations/\` - Slides and presentations for conferences, meetings
- \`.integrity/\` - Checksums and manifest validation files
EOF

  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create research study '$study_id' in $STUDY_ROOT"
    fi
  else
    echo "Created research study '$study_id' in $STUDY_ROOT"
  fi
}

init_lecture() {
  local name="" py_ver="${PY:-3.11}" no_conda=false extra_pkgs=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --name|-n) shift; name="$1";;
      --python) shift; py_ver="$1";;
      --no-conda) no_conda=true;;
      --conda-packages) shift; extra_pkgs="$1";;
      *) echo "Unknown arg for lecture: $1"; exit 1;;
    esac
    shift
  done
  if [ -z "$name" ]; then
    read -r -p "Lecture name: " name
  fi
  lecture_id=$(to_snake_case "$name")
  if [ "$JSON_OUTPUT" = false ]; then
    echo "Lecture name converted to ID: $lecture_id"
  fi

  LECTURE_ROOT="LECTURE_WORLD/$lecture_id"
  if [ -d "$LECTURE_ROOT" ]; then
    if [ "$FORCE" = false ] && [ "$BACKUP" = false ]; then
      echo "Lecture '$lecture_id' already exists at $LECTURE_ROOT" >&2
      echo "Use --force to overwrite or --backup to create a backup before overwriting" >&2
      exit 1
    fi
    
    # Prompt for confirmation unless --yes is set
    prompt_overwrite "$LECTURE_ROOT"
    
    # Create backup if requested
    if [ "$BACKUP" = true ]; then
      backup_directory "$LECTURE_ROOT"
    fi
    
    # Remove existing directory
    if [ "$DRY_RUN" = false ]; then
      rm -rf "$LECTURE_ROOT"
    fi
  fi
  do_mkdir_p "$LECTURE_ROOT"
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create directory: $LECTURE_ROOT"
    fi
  else
    echo "Created lecture directory: $LECTURE_ROOT"
  fi

  for d in 00_admin 01_code 02_data/experimental_recordings 02_data/reference 03_slides 04_manuscript 05_exercises/problems 05_exercises/solutions 05_exercises/submissions 05_exercises/graded 06_exams/problems 06_exams/solutions 06_exams/submissions 06_exams/graded 07_grades; do
    do_mkdir_p "$LECTURE_ROOT/$d"
  done

  # Create .integrity directories (constitution v1.0.12)
  do_mkdir_p "$LECTURE_ROOT/.integrity/checksums"
  do_mkdir_p "$LECTURE_ROOT/.integrity/manifests"

  write_file "$LECTURE_ROOT/README.md" <<'EOF'
# $name ($lecture_id)

Created: $(date --iso-8601=seconds)
Conda env: lecture_$lecture_id
EOF

  write_file "$LECTURE_ROOT/project.yaml" <<'EOF'
course_code: "<COURSE_CODE>"
title: "$name"
term: "<TERM>"
instructor:
  name: "<Instructor Name>"
  email: "<email@example.org>"
sync_policy: "iCloud: slides/manuscript; External: raw_recordings_on_nas"
conda_env: "lecture_$lecture_id"
project_id: "$lecture_id"
created: "$(date +%Y-%m-%d)"
EOF

  # Conda
  if [ "$no_conda" = false ]; then
    local base_pkgs="numpy matplotlib pandas jupyter pyyaml scipy seaborn ipywidgets"
    # beamer is not a python package, leave as note
    if [ -n "$extra_pkgs" ]; then
      base_pkgs="$base_pkgs $extra_pkgs"
    fi
    CONDA_NAME="lecture_$lecture_id"
    create_conda_env "$CONDA_NAME" "$py_ver" $base_pkgs || true
    export_environment_yaml "$CONDA_NAME" "$LECTURE_ROOT/01_code/environment.yaml" "$py_ver" $base_pkgs
    echo "Conda environment created: $CONDA_NAME"
    echo "Activate with: conda activate $CONDA_NAME"
  else
    if [ "$JSON_OUTPUT" = false ]; then
      echo "--no-conda specified: skipping conda creation"
    fi
  fi

  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create lecture project '$lecture_id' in $LECTURE_ROOT"
    fi
  else
    echo "Created lecture project '$lecture_id' in $LECTURE_ROOT"
  fi
}

init_coding() {
  local language="" project="" py_ver="${PY:-3.11}" skip_conda=false skip_git=false
  local no_git=false no_conda=false
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --language|-l)
        shift; language=$(echo "$1" | tr '[:upper:]' '[:lower:]') ;;
      --project|-p)
        shift; project="$1" ;;
      --python)
        shift; py_ver="$1" ;;
      --no-conda)
        skip_conda=true ;;
      --no-git)
        skip_git=true ;;
      --help)
        if declare -F show_coding_help >/dev/null 2>&1; then
          show_coding_help
        else
          echo "Usage: $PROG_NAME init coding --language <lang> --project <name> [options]"
        fi
        return 0 ;;
      *) echo "Unknown arg for coding: $1"; exit 1 ;;
    esac
    shift
  done

  if [ -z "$language" ] || [ -z "$project" ]; then
    show_coding_missing_args_error "$language" "$project" "$skip_conda" "$skip_git" "$py_ver" "$PROG_NAME"
    return 1
  fi

  case "$language" in
    python|matlab|fortran|bash)
      ;; 
    *)
      show_unsupported_language_error "$language" "$PROG_NAME"
      return 1
      ;;
  esac

  proj_id=$(to_snake_case "$project")
  local ROOT="CODING_WORLD/${language}/${proj_id}"

  if [ -d "$ROOT" ]; then
    if [ "$FORCE" = false ] && [ "$BACKUP" = false ]; then
      show_project_exists_error "$proj_id" "$ROOT"
      return 1
    fi
    prompt_overwrite "$ROOT"
    if [ "$BACKUP" = true ]; then
      backup_directory "$ROOT"
    fi
    if [ "$DRY_RUN" = false ]; then
      rm -rf "$ROOT"
    fi
  fi

  case "$language" in
    python)
      init_coding_python "$ROOT" "$proj_id" "$py_ver" "$skip_conda" "$skip_git"
      ;;
    matlab)
      init_coding_matlab "$ROOT" "$proj_id" "$skip_git"
      ;;
    fortran)
      init_coding_fortran "$ROOT" "$proj_id" "$py_ver" "$skip_conda" "$skip_git"
      ;;
    bash)
      init_coding_bash "$ROOT" "$proj_id" "$skip_git"
      ;;
  esac

  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create ${language} project at $ROOT"
    fi
  else
    echo "âœ“ ${language} project created: ${ROOT}"
    if { [ "$language" = "python" ] || [ "$language" = "fortran" ]; } && [ "$skip_conda" = false ]; then
      echo "âœ“ Conda environment: coding_${proj_id}"
      echo "Activate with: conda activate coding_${proj_id}"
    fi
  fi
}

# Language-specific initializers
init_coding_python() {
  local project_dir="$1" project_name="$2" py_ver="$3" skip_conda="$4" skip_git="$5"
  do_mkdir_p "$project_dir/src/$project_name" "$project_dir/tests" "$project_dir/docs"

  write_file "$project_dir/README.md" <<EOF
# $project_name

Created: $(date +%Y-%m-%d)
Language: Python
EOF

  write_file "$project_dir/pyproject.toml" <<'EOF'
[build-system]
requires = ["setuptools", "wheel"]
build-backend = "setuptools.build_meta"
EOF

  write_file "$project_dir/src/$project_name/__init__.py" <<EOF
"""$project_name package."""
__version__ = "0.1.0"
EOF

  write_file "$project_dir/tests/test_example.py" <<'EOF'
def test_smoke():
  assert True
EOF

  if [ "$skip_conda" = false ]; then
    local CONDA_NAME="coding_${project_name}"
    local base_pkgs="numpy matplotlib pandas jupyter pytest black flake8"
    create_conda_env "$CONDA_NAME" "$py_ver" $base_pkgs || true
    export_environment_yaml "$CONDA_NAME" "$project_dir/environment.yaml" "$py_ver" $base_pkgs
  fi

  if [ "$skip_git" = false ]; then
    init_git_repo() { :; } || true
    if [ "$DRY_RUN" = false ]; then
      (cd "$project_dir" && git init >/dev/null 2>&1 || true)
    fi
    write_file "$project_dir/.gitignore" <<'EOF'
__pycache__/
.pytest_cache/
*.pyc
.venv/
env/
EOF
  fi
}

init_coding_matlab() {
  local project_dir="$1" project_name="$2" skip_git="$3"
  do_mkdir_p "$project_dir/src" "$project_dir/functions" "$project_dir/tests" "$project_dir/data" "$project_dir/figures" "$project_dir/docs"

  write_file "$project_dir/README.md" <<EOF
# $project_name

Created: $(date +%Y-%m-%d)
Language: MATLAB
EOF

  write_file "$project_dir/src/main.m" <<'EOF'
% Main entry for $PROJECT_NAME
disp('Hello from MATLAB project')
EOF

  write_file "$project_dir/project.yaml" <<EOF
project:
  name: ${project_name}
  language: matlab
  created: $(date +%Y-%m-%d)
  owner: ${USER}
EOF

  touch "$project_dir/data/.gitkeep" || true
  touch "$project_dir/figures/.gitkeep" || true

  if [ "$skip_git" = false ]; then
    if [ "$DRY_RUN" = false ]; then
      (cd "$project_dir" && git init >/dev/null 2>&1 || true)
    fi
    write_file "$project_dir/.gitignore" <<'EOF'
*.asv
*.mat
slprj/
figures/*.png
EOF
  fi
}

init_coding_fortran() {
  local project_dir="$1" project_name="$2" py_ver="$3" skip_conda="$4" skip_git="$5"
  do_mkdir_p "$project_dir/src" "$project_dir/modules" "$project_dir/tests" "$project_dir/build" "$project_dir/docs"

  write_file "$project_dir/README.md" <<EOF
# $project_name

Created: $(date +%Y-%m-%d)
Language: Fortran
EOF

  write_file "$project_dir/Makefile" <<'EOF'
FC = gfortran
FCFLAGS = -O2 -fcheck=all
SRC = src/main.f90
all:
	$(FC) $(FCFLAGS) -o build/$(notdir $(SRC:.f90=)) $(SRC)
EOF

  write_file "$project_dir/src/main.f90" <<'EOF'
! Main program for $PROJECT_NAME
program main
  print *, 'Hello Fortran'
end program main
EOF

  if [ "$skip_conda" = false ]; then
    local CONDA_NAME="coding_${project_name}"
    local base_pkgs="gfortran numpy"
    create_conda_env "$CONDA_NAME" "$py_ver" $base_pkgs || true
    export_environment_yaml "$CONDA_NAME" "$project_dir/environment.yaml" "$py_ver" $base_pkgs
  fi

  if [ "$skip_git" = false ]; then
    if [ "$DRY_RUN" = false ]; then
      (cd "$project_dir" && git init >/dev/null 2>&1 || true)
    fi
    write_file "$project_dir/.gitignore" <<'EOF'
*.o
*.mod
build/
*.out
EOF
  fi
}

init_coding_bash() {
  local project_dir="$1" project_name="$2" skip_git="$3"
  do_mkdir_p "$project_dir/bin" "$project_dir/lib" "$project_dir/tests" "$project_dir/config" "$project_dir/docs"

  write_file "$project_dir/README.md" <<EOF
# $project_name

Created: $(date +%Y-%m-%d)
Language: Bash
EOF

  write_file "$project_dir/bin/${project_name}.sh" <<'EOF'
#!/usr/bin/env bash
echo "Hello from $PROJECT_NAME"
EOF

  if [ "$DRY_RUN" = false ]; then
    chmod +x "$project_dir/bin/${project_name}.sh" || true
  fi

  write_file "$project_dir/project.yaml" <<EOF
project:
  name: ${project_name}
  language: bash
  created: $(date +%Y-%m-%d)
  owner: ${USER}
EOF

  if [ "$skip_git" = false ]; then
    if [ "$DRY_RUN" = false ]; then
      (cd "$project_dir" && git init >/dev/null 2>&1 || true)
    fi
    write_file "$project_dir/.gitignore" <<'EOF'
*.log
tmp/
.env
*.bak
EOF
  fi
}

init_journal() {
  # Handle help flags first before processing any other arguments (T034)
  for arg in "$@"; do
    case "$arg" in
      --help|-h)
        # Short journal help
        if declare -F show_journal_help >/dev/null 2>&1; then
          show_journal_help "short"
        else
          echo "Usage: $PROG_NAME init journal [OPTIONS]"
          echo "Options:"
          echo "  --name <name>       Name for paper (authorship) or journal (service)"
          echo "  --first             Primary authorship flag"
          echo "  --coauthor          Co-author collaboration flag"  
          echo "  --service           Journal service flag (requires --id)"
          echo "  --year <YYYY>       Year for authorship projects (default: current/extracted)"
          echo "  --id <id>           Manuscript identifier (required with --service)"
        fi
        return 0
        ;;
      --help-long)
        # Detailed journal help
        if declare -F show_journal_help >/dev/null 2>&1; then
          show_journal_help "long"
        else
          echo "Journal Role-Based Organization (Detailed Help)"
          echo "============================================="
          echo ""
          echo "Creates role-based journal organization for managing academic publishing workflows."
          echo ""
          echo "Usage patterns:"
          echo "  Primary authorship: $PROG_NAME init journal --name <paper_name> --first [--year <YYYY>]"
          echo "  Co-author project:  $PROG_NAME init journal --name <paper_name> --coauthor [--year <YYYY>]"
          echo "  Journal service:    $PROG_NAME init journal --name <journal_name> --id <manuscript_id> --service"
          echo ""
          echo "For comprehensive help, ensure help system is properly installed."
        fi
        return 0
        ;;
    esac
  done
  
  # Parse command-line arguments for role-based journal structure
  local name="" manuscript_id="" year=""
  local is_first=false is_coauthor=false is_service=false
  
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --name|-n)
        shift
        if [ $# -eq 0 ] || [ -z "${1:-}" ]; then
          echo "Error: --name requires a value (paper name or journal name)" >&2
          echo "" >&2
          echo "Examples:" >&2
          echo "  dirforge init journal --name \"thermal_analysis\" --first" >&2
          echo "  dirforge init journal --name \"Geophysics\" --id \"GEO-2025-0451\" --service" >&2
          echo "" >&2
          echo "For help: dirforge init journal --help" >&2
          exit 1
        fi
        name="$1"
        ;;
      --first|-f)
        is_first=true
        ;;
      --coauthor|-c)
        is_coauthor=true
        ;;
      --service|-s)
        is_service=true
        ;;
      --year|-y)
        shift
        if [ $# -eq 0 ] || [ -z "${1:-}" ]; then
          echo "Error: --year requires a 4-digit year (YYYY)" >&2
          echo "" >&2
          echo "Examples:" >&2
          echo "  dirforge init journal --name \"my_paper\" --first --year 2024" >&2
          echo "  dirforge init journal --name \"collaboration\" --coauthor --year 2023" >&2
          echo "" >&2
          echo "Note: If not specified, current year (2025) will be used" >&2
          echo "      Year can also be embedded in paper name: '2024_paper_name'" >&2
          exit 1
        fi
        year="$1"
        ;;
      --id|-i)
        shift
        if [ $# -eq 0 ] || [ -z "${1:-}" ]; then
          echo "Error: --id requires a manuscript identifier" >&2
          echo "" >&2
          echo "Examples:" >&2
          echo "  dirforge init journal --name \"Geophysics\" --id \"GEO-2025-0451\" --service" >&2
          echo "  dirforge init journal --name \"Nature Geoscience\" --id \"REVIEWER_2024_Q4\" --service" >&2
          echo "" >&2
          echo "Valid ID formats: letters, numbers, hyphens, underscores, dots" >&2
          echo "Example IDs: GEO-2025-0451, REVIEWER_2024_Q4, SPECIAL-ISSUE-2025" >&2
          exit 1
        fi
        manuscript_id="$1"
        ;;
      --help|-h|--help-long)
        # Skip these as they're already handled above
        echo "Internal error: help flags should have been handled earlier" >&2
        exit 1
        ;;
      *)
        echo "Error: Unknown argument for journal command: $1" >&2
        echo "" >&2
        echo "Valid journal flags:" >&2
        echo "  --name <name>       Name for paper (authorship) or journal (service)" >&2
        echo "  --first             Primary authorship flag" >&2
        echo "  --coauthor          Co-author collaboration flag" >&2
        echo "  --service           Journal service flag (requires --id)" >&2
        echo "  --year <YYYY>       Year for authorship projects (optional)" >&2
        echo "  --id <manuscript_id> Manuscript identifier for service projects" >&2
        echo "  --help, -h          Show help" >&2
        echo "  --help-long         Show detailed help" >&2
        echo "" >&2
        echo "Usage patterns:" >&2
        echo "  Primary authorship: $PROG_NAME init journal --name <paper_name> --first [--year <YYYY>]" >&2
        echo "  Co-author project:  $PROG_NAME init journal --name <paper_name> --coauthor [--year <YYYY>]" >&2
        echo "  Journal service:    $PROG_NAME init journal --name <journal_name> --id <manuscript_id> --service" >&2
        echo "" >&2
        echo "For comprehensive help: $PROG_NAME init journal --help" >&2
        exit 1
        ;;
    esac
    shift
  done
  
  # Validate flag combinations and requirements
  local mode_count=0
  if [ "$is_first" = true ]; then mode_count=$((mode_count + 1)); fi
  if [ "$is_coauthor" = true ]; then mode_count=$((mode_count + 1)); fi
  if [ "$is_service" = true ]; then mode_count=$((mode_count + 1)); fi
  
  if [ $mode_count -eq 0 ]; then
    echo "Error: Must specify one journal role: --first, --coauthor, or --service" >&2
    echo "" >&2
    echo "Choose your journal role:" >&2
    echo "  --first      Primary authorship (your papers as lead author)" >&2
    echo "  --coauthor   Co-author collaboration (joint projects)" >&2
    echo "  --service    Journal service (reviews, editorial work)" >&2
    echo "" >&2
    echo "Complete command examples:" >&2
    echo "  $PROG_NAME init journal --name \"thermal_analysis\" --first" >&2
    echo "  $PROG_NAME init journal --name \"joint_study\" --coauthor" >&2
    echo "  $PROG_NAME init journal --name \"Geophysics\" --id \"GEO-2025-0451\" --service" >&2
    echo "" >&2
    echo "For detailed help: $PROG_NAME init journal --help" >&2
    exit 1
  fi
  
  if [ $mode_count -gt 1 ]; then
    echo "Error: Cannot combine multiple journal role flags (--first, --coauthor, --service)" >&2
    echo "" >&2
    echo "Journal roles are mutually exclusive. Choose exactly one:" >&2
    echo "" >&2
    echo "  For YOUR papers (lead author):" >&2
    echo "    $PROG_NAME init journal --name \"paper_name\" --first" >&2
    echo "" >&2
    echo "  For COLLABORATIVE projects:" >&2
    echo "    $PROG_NAME init journal --name \"project_name\" --coauthor" >&2
    echo "" >&2
    echo "  For JOURNAL SERVICE (reviews/editorial):" >&2
    echo "    $PROG_NAME init journal --name \"Journal Name\" --id \"MANUSCRIPT_ID\" --service" >&2
    echo "" >&2
    echo "Each command creates content in a different organizational directory." >&2
    echo "For help: $PROG_NAME init journal --help" >&2
    exit 1
  fi
  
  # Validate required arguments for each mode
  if [ "$is_first" = true ] || [ "$is_coauthor" = true ]; then
    if [ -z "$name" ]; then
      echo "Error: --name is required for primary authorship and co-author projects" >&2
      echo "" >&2
      echo "Provide a descriptive paper name:" >&2
      echo "  $PROG_NAME init journal --name \"thermal_conductivity_analysis\" --first" >&2
      echo "  $PROG_NAME init journal --name \"2024_joint_reservoir_study\" --coauthor" >&2
      echo "" >&2
      echo "Paper names are automatically formatted for directory structure." >&2
      echo "Special characters and spaces are converted to underscores." >&2
      echo "Embedded years (YYYY_) are automatically detected and extracted." >&2
      exit 1
    fi
    
    if [ -n "$manuscript_id" ]; then
      echo "Error: --id flag is only valid for journal service projects (--service)" >&2
      echo "" >&2
      echo "You're creating an authorship project. Remove --id and use:" >&2
      if [ "$is_first" = true ]; then
        echo "  $PROG_NAME init journal --name \"$name\" --first"
      else
        echo "  $PROG_NAME init journal --name \"$name\" --coauthor"
      fi
      echo "" >&2
      echo "Manuscript IDs are only needed for journal service activities:" >&2
      echo "  $PROG_NAME init journal --name \"Journal Name\" --id \"MANUSCRIPT_ID\" --service" >&2
      exit 1
    fi
  fi
  
  if [ "$is_service" = true ]; then
    if [ -z "$name" ] || [ -z "$manuscript_id" ]; then
      echo "Error: Journal service requires both --name and --id flags" >&2
      echo "" >&2
      echo "Required for journal service:" >&2
      echo "  --name <journal_name>     Name of the journal (e.g., \"Geophysics\")" >&2
      echo "  --id <manuscript_id>      Manuscript identifier from journal" >&2
      echo "" >&2
      echo "Complete examples:" >&2
      echo "  $PROG_NAME init journal --name \"Geophysics\" --id \"GEO-2025-0451\" --service" >&2
      echo "  $PROG_NAME init journal --name \"Nature Geoscience\" --id \"REVIEWER_2024_Q4\" --service" >&2
      echo "  $PROG_NAME init journal --name \"JGR Solid Earth\" --id \"EDITORIAL_BOARD_2025\" --service" >&2
      echo "" >&2
      echo "This creates: 03_journal_service/journal_name/MANUSCRIPT_ID/" >&2
      exit 1
    fi
    
    if [ -n "$year" ]; then
      echo "Error: --year flag is only valid for authorship projects (--first, --coauthor)" >&2
      echo "" >&2
      echo "Journal service projects don't use --year. Remove it:" >&2
      echo "  $PROG_NAME init journal --name \"$name\" --id \"$manuscript_id\" --service" >&2
      echo "" >&2
      echo "Year specification is for authorship projects only:" >&2
      echo "  $PROG_NAME init journal --name \"paper_name\" --first --year 2024" >&2
      echo "  $PROG_NAME init journal --name \"project_name\" --coauthor --year 2023" >&2
      echo "" >&2
      echo "Journal service uses manuscript IDs for temporal organization." >&2
      exit 1
    fi
  fi
  
  # Ensure JOURNAL_WORLD structure exists
  if ! is_in_journal_world; then
    # Create role-based structure
    create_journal_role_structure || exit 1
  fi
  
  # Handle year logic for authorship projects
  if [ "$is_first" = true ] || [ "$is_coauthor" = true ]; then
    local paper_name="$name"
    if [ -z "$year" ]; then
      # Extract year from paper name or use current year
      year=$(extract_year_from_paper_name "$paper_name")
      paper_name=$(strip_year_from_paper_name "$paper_name")
    fi
    
    # Execute the appropriate creation function for authorship
    if [ "$is_first" = true ]; then
      create_primary_authorship_project "$paper_name" "$year" || exit 1
    elif [ "$is_coauthor" = true ]; then
      create_coauthor_project "$paper_name" "$year" || exit 1
    fi
  elif [ "$is_service" = true ]; then
    # For service mode, name is the journal name
    local journal_name="$name"
    create_journal_service_project "$journal_name" "$manuscript_id" || exit 1
  fi
}

handle_help_request() {
  # Route help requests to appropriate help functions based on context
  # Usage: handle_help_request [command] [world-type-or-subcommand] [world-type]
  
  local cmd="${1:-}"
  local arg2="${2:-}"
  local arg3="${3:-}"
  
  # Determine if arg2 is a world type or subcommand
  local world=""
  local subcmd=""
  
  case "$arg2" in
    research|lecture|coding|journal|office|private)
      # arg2 is a world type
      world="$arg2"
      subcmd="${arg3:-}"
      ;;
    *)
      # arg2 is a subcommand or empty
      subcmd="$arg2"
      world="$arg3"
      ;;
  esac
  
  # DEBUG: uncomment for troubleshooting
  # echo "DEBUG: cmd='$cmd' subcmd='$subcmd' world='$world' (arg2='$arg2' arg3='$arg3')" >&2
  
  # Check if help system is available
  if ! declare -F show_global_help >/dev/null 2>&1; then
    # Fallback to basic usage if help system not available
    usage
    return
  fi
  
  case "$cmd" in
    ""|"help"|"--help"|"-h")
      # Default to short help for quick reference
      if declare -F show_global_help_short >/dev/null 2>&1; then
        show_global_help_short
      else
        show_global_help
      fi
      ;;
    "--help-long")
      # Detailed comprehensive help
      show_global_help
      ;;
    "init")
      if [ -n "$world" ]; then
        # World-specific help: dirforge init research --help
        if declare -F show_world_help >/dev/null 2>&1; then
          show_world_help "$world"
        else
          show_command_help "init"
        fi
      else
        # Command help: dirforge init --help
        if declare -F show_command_help >/dev/null 2>&1; then
          show_command_help "init"
        else
          show_global_help
        fi
      fi
      ;;
    "--version"|"-v")
      echo "$PROG_NAME (DirForge Constitution $CONSTITUTION_VERSION)"
      echo "Enhanced Terminal Help System"
      ;;
    *)
      # Unknown command - show contextual help
      echo "Unknown command: $cmd" >&2
      echo >&2
      if declare -F show_global_help >/dev/null 2>&1; then
        echo "Available commands:" >&2
        show_global_help | grep -A5 "Usage" || usage
      else
        usage
      fi
      exit 1
      ;;
  esac
}

init_all_worlds() {
  # Create top-level directory structure with all world types
  local target_path="."
  local auto_create=false
  
  # Parse arguments
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --auto|--yes|-y)
        auto_create=true
        shift
        ;;
      --here)
        target_path="."
        shift
        ;;
      --path=*)
        target_path="${1#--path=}"
        shift
        ;;
      -*)
        echo "Unknown option: $1" >&2
        echo "Usage: $PROG_NAME init [path] [--auto|--yes|-y] [--here] [--path=PATH]" >&2
        exit 1
        ;;
      *)
        # First non-option argument is the target path
        target_path="$1"
        shift
        ;;
    esac
  done
  
  # Convert to absolute path and normalize
  if [[ "$target_path" == "." ]]; then
    target_path="$(pwd)"
  elif [[ "$target_path" != /* ]]; then
    target_path="$(pwd)/$target_path"
  fi
  
  echo "Initializing DirForge workspace at: $target_path"
  echo
  
  # Check if target directory exists and is not empty
  if [ -d "$target_path" ] && [ "$(ls -A "$target_path" 2>/dev/null | wc -l)" -gt 0 ]; then
    if [ "$auto_create" = false ] && [ "$YES" = false ] && [ "$FORCE" = false ]; then
      echo "WARNING: Directory '$target_path' exists and is not empty." >&2
      echo "Contents will be preserved, but new world directories will be created alongside existing files." >&2
      read -r -p "Continue with initialization? [y/N] " response
      case "$response" in
        [yY][eE][sS]|[yY]) 
          ;;
        *)
          echo "Initialization cancelled." >&2
          exit 1
          ;;
      esac
    fi
  fi
  
  # Create base directory if it doesn't exist
  do_mkdir_p "$target_path"
  
  # Define all world types - per DirForge Constitution v1.0.17
  local worlds=(
    "CODING_WORLD"
    "JOURNAL_WORLD" 
    "LECTURE_WORLD"
    "LITERATURE_WORLD"
    "OFFICE_WORLD"
    "PRIVATE_WORLD"
    "RESEARCH_WORLD"
  )
  
  # Only OFFICE_WORLD and PRIVATE_WORLD get subfolders during workspace init
  # Other worlds remain empty until specific projects are created
  
  local office_dirs=(
    "00_admin"
    "01_finance"
    "02_hr_administration"
    "03_faculty"
    "04_inventory_equipment"
    "05_software_licenses"
    "06_public_relations"
    "90_archive"
  )
  
  local private_dirs=(
    "00_admin"
    "01_credentials"
    "02_id_contracts"
    "03_finance"
    "04_documents"
    "05_photos"
    "06_movies"
    "07_hiking"
    "09_installers"
    "90_archive"
  )
  
  # Create world directories
  for world in "${worlds[@]}"; do
    local world_path="$target_path/$world"
    do_mkdir_p "$world_path"
    
    # Per Constitution: Only OFFICE_WORLD and PRIVATE_WORLD get subfolders at init
    # All others remain empty until specific projects are created
    case "$world" in
      OFFICE_WORLD)
        for dir in "${office_dirs[@]}"; do
          do_mkdir_p "$world_path/$dir"
        done
        ;;
      PRIVATE_WORLD)
        for dir in "${private_dirs[@]}"; do
          do_mkdir_p "$world_path/$dir"
        done
        ;;
      CODING_WORLD|JOURNAL_WORLD|LECTURE_WORLD|RESEARCH_WORLD|LITERATURE_WORLD)
        # These remain empty - projects created by specific init commands
        ;;
    esac
  done
  
  
  if [ "$DRY_RUN" = true ]; then
    echo "DRY RUN: would create complete DirForge workspace at $target_path"
  else
    echo
    echo "âœ… Workspace initialized at: $target_path"
    echo
    echo "Created world directories:"
    echo "  CODING_WORLD/           (empty - use 'dirforge init coding' to create projects)"
    echo "  JOURNAL_WORLD/          (empty - use 'dirforge init journal' to create activities)"
    echo "  LECTURE_WORLD/          (empty - use 'dirforge init lecture' to create courses)"
    echo "  LITERATURE_WORLD/       (empty - user-managed)"
    echo "  OFFICE_WORLD/           (with 7 subfolders)"
    echo "  PRIVATE_WORLD/          (with 10 subfolders)"
    echo "  RESEARCH_WORLD/         (empty - use 'dirforge init research' to create projects)"
    echo
    echo "Constitution version: v1.0.21"
    echo
    echo "Next steps:"
    echo "  â€¢ Create a research project: $PROG_NAME init research --name \"Project Name\""
    echo "  â€¢ Create a lecture: $PROG_NAME init lecture --name \"Course Name\""
    echo "  â€¢ Create a coding project: $PROG_NAME init coding --language python --project \"name\""
    echo "  â€¢ Create a journal activity: $PROG_NAME init journal --journal \"Journal Name\" --id \"MS-ID\""
  fi
}

suggest_world_help() {
  # Suggest valid world types for unknown world types
  local invalid_world="$1"
  local valid_worlds="research lecture coding journal office private"
  
  echo "Unknown world type: $invalid_world" >&2
  echo >&2
  echo "Valid world types:" >&2
  for world in $valid_worlds; do
    echo "  $world" >&2
  done
  echo >&2
  echo "For detailed help on a specific world type:" >&2
  echo "  $PROG_NAME init <world-type> --help" >&2
  echo >&2
  echo "Examples:" >&2
  echo "  $PROG_NAME init research --help" >&2
  echo "  $PROG_NAME init lecture --help" >&2
  echo >&2
  echo "To initialize a complete workspace with all worlds:" >&2
  echo "  $PROG_NAME init [path] [--auto]" >&2
}

usage() {
  cat <<EOF
Usage: 
  $PROG_NAME init <world> [options]        # Create specific world project
  $PROG_NAME init [path] [--auto]          # Initialize complete workspace with all worlds

World types: research, lecture, coding, journal, office, private

Global options:
  --dry-run, --preview    Preview changes without writing to filesystem
  --json                  Output machine-readable JSON plan (requires --dry-run)
  --force                 Overwrite existing projects without prompting
  --backup                Create timestamped backups before overwriting
  --yes, -y               Skip interactive prompts and proceed

Complete workspace initialization:
  path                    Target directory (default: current directory)
  --auto, --yes, -y       Create automatically without prompts
  --here                  Explicitly use current directory

Examples:
  # Initialize complete workspace
  $PROG_NAME init
  $PROG_NAME init /path/to/workspace --auto
  $PROG_NAME init ~/myworkspace
  
  # Create specific world projects
  $PROG_NAME init research --name "Thermal Model Analysis" --python 3.11
  $PROG_NAME init lecture --name "Digital Rock Physics"
  $PROG_NAME init coding --language python --project ml_toolkit
  
  # Preview changes
  $PROG_NAME --dry-run init ~/test-workspace
  $PROG_NAME --dry-run --json init research --name "Test" | jq .
EOF
}

output_json_plan() {
  # Output accumulated dry-run plan as JSON
  echo "{"
  echo '  "dry_run": true,'
  echo '  "directories": ['
  local first=true
  for dir in "${JSON_DIRS[@]}"; do
    if [ "$first" = false ]; then echo ","; fi
    printf '    "%s"' "$(json_escape "$dir")"
    first=false
  done
  echo ""
  echo '  ],'
  echo '  "files": ['
  first=true
  if [ "${#JSON_FILES[@]}" -gt 0 ]; then
    for file in "${JSON_FILES[@]}"; do
      if [ "$first" = false ]; then echo ","; fi
      printf '    "%s"' "$(json_escape "$file")"
      first=false
    done
  fi
  echo ""
  echo '  ]'
  echo "}"
}

main() {
  # Handle help and version flags first (before parsing other options)
  case "${1:-}" in
    --help|-h|help)
      handle_help_request
      exit 0
      ;;
    --version|-v|version)
      handle_help_request "--version"
      exit 0
      ;;
  esac

  # Global flags: support --dry-run or --preview anywhere in the args
  new_args=()
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --dry-run|--preview)
        DRY_RUN=true; shift;;
      --json)
        JSON_OUTPUT=true; shift;;
      --force)
        FORCE=true; shift;;
      --backup)
        BACKUP=true; shift;;
      --yes|-y)
        YES=true; shift;;
      --help|-h)
        # Context-aware help handling
        if [ "${#new_args[@]}" -gt 0 ]; then
          handle_help_request "${new_args[@]}"
        else
          handle_help_request
        fi
        exit 0
        ;;
      *) new_args+=("$1"); shift;;
    esac
  done
  
  # Validate JSON requires dry-run
  if [ "$JSON_OUTPUT" = true ] && [ "$DRY_RUN" = false ]; then
    show_json_requires_dryrun_error
    exit 1
  fi
  
  # Restore positional params
  set -- "${new_args[@]}"
  if [ "$#" -lt 1 ]; then
    handle_help_request
    exit 1
  fi
  
  cmd="$1"; shift
  case "$cmd" in
    init)
      # Check if there are any arguments
      if [ "$#" -eq 0 ]; then
        # No arguments - initialize complete workspace in current directory
        init_all_worlds "."
      else
        # Check if first argument is a help flag
        case "$1" in
          --help|-h)
            handle_help_request "init"
            exit 0
            ;;
          research|lecture|coding|journal|office|private)
            # Traditional world-specific init
            world="$1"
            shift
            
            # Check for help flags before processing world
            case "${1:-}" in
              --help|-h)
                # Short help for world type
                if declare -F show_world_help >/dev/null 2>&1; then
                  show_world_help "$world" "short"
                  exit 0
                fi
                ;;
              --help-long)
                # Long/detailed help for world type
                if declare -F show_world_help >/dev/null 2>&1; then
                  show_world_help "$world" "long"
                  exit 0
                fi
                ;;
            esac
            
            # Check for parent-only mode first
            if is_parent_only_mode "$world" "$@"; then
              create_world_parent "$world"
            else
              case "$world" in
                research) init_research "$@" ;;
                lecture) init_lecture "$@" ;;
                coding) init_coding "$@" ;;
                journal) init_journal "$@" ;;
                office)
                echo "Creating OFFICE_WORLD standard folders..."
                for d in 00_admin 01_finance 02_hr_administration 03_faculty 04_inventory_equipment 05_software_licenses 06_public_relations; do
                  do_mkdir_p "OFFICE_WORLD/$d"
                done
                if [ "$DRY_RUN" = true ]; then
                  echo "DRY RUN: would create OFFICE_WORLD/"
                else
                  echo "Created OFFICE_WORLD/"
                fi ;;
              private)
                echo "Creating PRIVATE_WORLD standard folders..."
                for d in 00_admin 01_credentials 02_id_contracts 03_finance 04_documents 05_photos 06_movies 07_hiking 09_installers 90_archive; do
                  do_mkdir_p "PRIVATE_WORLD/$d"
                done
                if [ "$DRY_RUN" = true ]; then
                  echo "DRY RUN: would create PRIVATE_WORLD/"
                else
                  echo "Created PRIVATE_WORLD/"
                fi ;;
              esac
            fi
            ;;
          *)
            # Initialize complete workspace (all worlds) - could be path or flags
            init_all_worlds "$@"
            ;;
        esac
      fi
      
      # Output JSON plan if requested
      if [ "$JSON_OUTPUT" = true ]; then
        output_json_plan
      fi
    ;;
    *) 
      handle_help_request "$cmd"
      exit 1
      ;;
  esac
}

main "$@"
