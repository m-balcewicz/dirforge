#!/usr/bin/env bash
set -euo pipefail

# dirforge - create standardized directory structures per DirForge Constitution
# Minimal, portable bash CLI that implements `dirforge init <world-type>`

PROG_NAME="dirforge"

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Detect library directory (development vs installed)
if [ -d "$SCRIPT_DIR/../lib" ]; then
    # Development mode - script is in tools/, libraries in lib/
    LIB_DIR="$(cd "$SCRIPT_DIR/../lib" && pwd)"
elif [ -d "$HOME/.local/lib/dirforge" ]; then
    # Local installation mode  
    LIB_DIR="$HOME/.local/lib/dirforge"
elif [ -d "/usr/local/lib/dirforge" ]; then
    # System installation mode
    LIB_DIR="/usr/local/lib/dirforge"
else
    # Fallback - try relative path anyway
    LIB_DIR="$SCRIPT_DIR/../lib"
fi

# Detect templates directory (development vs installed)
if [ -d "$SCRIPT_DIR/../templates" ]; then
    # Development mode - templates in templates/
    TEMPLATES_DIR="$(cd "$SCRIPT_DIR/../templates" && pwd)"
elif [ -d "$HOME/.local/share/dirforge/templates" ]; then
    # Local installation mode
    TEMPLATES_DIR="$HOME/.local/share/dirforge/templates"
elif [ -d "/usr/local/share/dirforge/templates" ]; then
    # System installation mode
    TEMPLATES_DIR="/usr/local/share/dirforge/templates"
else
    # Fallback
    TEMPLATES_DIR="$SCRIPT_DIR/../templates"
fi

# Source help system libraries if available
if [ -f "$LIB_DIR/terminal.sh" ]; then
    source "$LIB_DIR/terminal.sh"
fi
if [ -f "$LIB_DIR/colors.sh" ]; then
    source "$LIB_DIR/colors.sh"
    init_colors 2>/dev/null || true
fi
if [ -f "$LIB_DIR/help.sh" ]; then
    source "$LIB_DIR/help.sh"
fi
if [ -f "$LIB_DIR/error.sh" ]; then
    source "$LIB_DIR/error.sh"
fi

CONSTITUTION_VERSION="v1.0.20"

# Dry-run flag (preview mode). When true, filesystem changes are not written; actions are printed.
DRY_RUN=false
# JSON output flag. When true with DRY_RUN, output machine-readable JSON plan.
JSON_OUTPUT=false
# Force flag. When true, overwrite existing projects without prompting.
FORCE=false
# Backup flag. When true, create timestamped backups before overwriting.
BACKUP=false
# Yes flag. When true, skip interactive prompts and proceed.
YES=false

# JSON plan accumulator (used when JSON_OUTPUT=true)
JSON_DIRS=()
JSON_FILES=()

json_escape() {
  # Escape string for JSON (basic escaping, remove trailing newline)
  printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g'
}

do_mkdir_p() {
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = true ]; then
      for dir in "$@"; do
        JSON_DIRS+=("$dir")
      done
    else
      echo "DRY RUN: mkdir -p $*"
    fi
  else
    mkdir -p "$@"
  fi
}

write_file() {
  # usage: write_file <dest> <<'EOF'...EOF
  local dest="$1"
  shift
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = true ]; then
      # Capture file content for JSON
      local content
      content=$(cat)
      JSON_FILES+=("$dest")
    else
      echo "DRY RUN: would write file: $dest"
      # print a snippet of the content for visibility
      awk '{ if (NR<=20) print "    " $0 }' || true
      # consume stdin
      cat >/dev/null
    fi
  else
    mkdir -p "$(dirname "$dest")"
    cat > "$dest"
  fi
}

render_template() {
  # usage: render_template <template_file> <dest> [VAR=value ...]
  local template_file="$1"
  local dest="$2"
  shift 2
  # Verify template exists
  if [ ! -f "$template_file" ]; then
    show_template_not_found_error "$template_file"
    return 1
  fi

  local content
  content=$(cat "$template_file")
  for var in "$@"; do
    local name="${var%%=*}"
    local value="${var#*=}"
    # Escape backslashes, pipes and ampersands for safe sed substitution
    local esc
    esc=$(printf '%s' "$value" | sed -e 's/\\/\\\\/g' -e 's/|/\\|/g' -e 's/&/\\&/g')
    content=$(printf "%s" "$content" | sed "s|{{${name}}}|${esc}|g")
  done
  write_file "$dest" <<< "$content"
}

to_snake_case() {
  # Convert a string to lower_snake_case: transliterate, lowercase, replace non-alnum with _, trim
  local s="$*"
  # Use iconv if available for transliteration, else rely on sed
  if command -v iconv >/dev/null 2>&1; then
    s=$(printf "%s" "$s" | iconv -f utf8 -t ascii//TRANSLIT 2>/dev/null)
  fi
  printf "%s" "$s" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9_-]+/_/g' | sed -E 's/^_+|_+$//g'
}

strip_year_prefix() {
  local id="$1"
  echo "$id" | sed -E 's/^[0-9]{4}_//'
}

backup_directory() {
  local src="$1"
  local timestamp
  timestamp=$(date +%Y%m%d-%H%M%S)
  local backup_dir="${src}.backup-${timestamp}"
  
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create backup: $backup_dir"
    fi
  else
    cp -R "$src" "$backup_dir"
    echo "Created backup: $backup_dir"
  fi
}

prompt_overwrite() {
  local project_path="$1"
  
  # Skip prompt if --yes or --force is set
  if [ "$YES" = true ] || [ "$FORCE" = true ]; then
    return 0
  fi
  
  echo "WARNING: Project already exists at $project_path" >&2
  if [ "$BACKUP" = true ]; then
    echo "A backup will be created before overwriting." >&2
  fi
  read -r -p "Overwrite existing project? [y/N] " response
  case "$response" in
    [yY][eE][sS]|[yY]) 
      return 0
      ;;
    *)
      echo "Operation cancelled." >&2
      exit 1
      ;;
  esac
}

conda_env_exists() {
  local name="$1"
  if ! command -v conda >/dev/null 2>&1; then
    return 1
  fi
  conda info --envs 2>/dev/null | awk '{print $1}' | grep -xq "$name" || return 1
}

create_conda_env() {
  local env_name="$1"; shift
  local py_ver="$1"; shift
  local packages="$*"
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create conda environment: $env_name (python=$py_ver)"
    fi
    return 0
  fi
  if ! command -v conda >/dev/null 2>&1; then
    echo "Conda not found in PATH — skipping env creation (or use --no-conda to suppress)." >&2
    return 0
  fi
  if conda_env_exists "$env_name"; then
    echo "Conda environment '$env_name' already exists - skipping creation."
    return 0
  fi
  echo "Creating conda environment: $env_name"
  conda create -n "$env_name" python="$py_ver" $packages -y
}

export_environment_yaml() {
  local env_name="$1"; shift
  local dest="$1"; shift
  local py_ver="$1"; shift
  local packages="$*"
  do_mkdir_p "$(dirname "$dest")"
  write_file "$dest" <<EOF
name: $env_name
channels:
  - defaults
dependencies:
  - python=$py_ver
$(for p in $packages; do echo "  - $p"; done)
EOF
}

init_research() {
  local name="${NAME:-}" project_id="" study_name="" py_ver="${PY:-3.11}" no_conda=false extra_pkgs=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --name|-n) shift; name="$1";;
      --project|-p) shift; project_id="$1";;
      --study|-s) shift; study_name="$1";;
      --python) shift; py_ver="$1";;
      --no-conda) no_conda=true;;
      --conda-packages) shift; extra_pkgs="$1";;
      *) echo "Unknown arg: $1"; exit 1;;
    esac
    shift
  done
  
  # Determine operation mode
  if [ -n "$project_id" ] && [ -n "$study_name" ]; then
    # Study creation mode
    init_research_study --project "$project_id" --study "$study_name"
    return
  elif [ -n "$name" ] && [ -n "$study_name" ]; then
    # Combined project + study creation
    # First create project, then create study
    local args=()
    [ -n "$name" ] && args+=(--name "$name")
    [ -n "$py_ver" ] && args+=(--python "$py_ver")
    [ "$no_conda" = true ] && args+=(--no-conda)
    [ -n "$extra_pkgs" ] && args+=(--conda-packages "$extra_pkgs")
    init_research_project_only "${args[@]}"
    # Extract project ID from what was just created
    local id_raw
    id_raw=$(to_snake_case "$name")
    local year
    year=$(date +%Y)
    if [[ "$id_raw" =~ ^[0-9]{4}_ ]]; then
      project_id="$id_raw"
    else
      project_id="${year}_$id_raw"
    fi
    init_research_study --project "$project_id" --study "$study_name"
    return
  elif [ -n "$name" ]; then
    # Project creation mode
    local args=()
    [ -n "$name" ] && args+=(--name "$name")
    [ -n "$py_ver" ] && args+=(--python "$py_ver")
    [ "$no_conda" = true ] && args+=(--no-conda)
    [ -n "$extra_pkgs" ] && args+=(--conda-packages "$extra_pkgs")
    init_research_project_only "${args[@]}"
    return
  else
    show_research_missing_args_error "$PROG_NAME"
    exit 1
  fi
}

init_research_project_only() {
  local name="" py_ver="${PY:-3.11}" no_conda=false extra_pkgs=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --name|-n) shift; name="$1";;
      --python) shift; py_ver="$1";;
      --no-conda) no_conda=true;;
      --conda-packages) shift; extra_pkgs="$1";;
      *) echo "Unknown arg: $1"; exit 1;;
    esac
    shift
  done
  if [ -z "$name" ]; then
    read -r -p "Project name: " name
  fi
  local id_raw
  id_raw=$(to_snake_case "$name")
  # prefix with year if not present
  local year
  year=$(date +%Y)
  if [[ "$id_raw" =~ ^[0-9]{4}_ ]]; then
    PROJECT_ID="$id_raw"
  else
    PROJECT_ID="${year}_$id_raw"
  fi
  # conda env name
  local id_no_year
  id_no_year=$(strip_year_prefix "$PROJECT_ID")
  CONDA_NAME="research_${id_no_year}"

  RESEARCH_ROOT="RESEARCH_WORLD/$PROJECT_ID"
  if [ -d "$RESEARCH_ROOT" ]; then
    if [ "$FORCE" = false ] && [ "$BACKUP" = false ]; then
      echo "Project '$PROJECT_ID' already exists at $RESEARCH_ROOT" >&2
      echo "Use --force to overwrite or --backup to create a backup before overwriting" >&2
      exit 1
    fi
    
    # Prompt for confirmation unless --yes is set
    prompt_overwrite "$RESEARCH_ROOT"
    
    # Create backup if requested
    if [ "$BACKUP" = true ]; then
      backup_directory "$RESEARCH_ROOT"
    fi
    
    # Remove existing directory
    if [ "$DRY_RUN" = false ]; then
      rm -rf "$RESEARCH_ROOT"
    fi
  fi
  do_mkdir_p "$RESEARCH_ROOT"
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create directory: $RESEARCH_ROOT"
    fi
  else
    echo "Created directory: $RESEARCH_ROOT"
  fi

  # create numbered subfolders
  for d in 00_admin 01_project_management 02_studies; do
    do_mkdir_p "$RESEARCH_ROOT/$d"
  done

  # Create project management subdirectories
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/01_proposal/01_draft"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/01_proposal/02_submission"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/01_proposal/03_review"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/01_proposal/04_final"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/02_finance"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/03_reports"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/04_presentations"

  # Create .integrity directories (constitution v1.0.12)
  do_mkdir_p "$RESEARCH_ROOT/.integrity/checksums"
  do_mkdir_p "$RESEARCH_ROOT/.integrity/manifests"

  # create files
  write_file "$RESEARCH_ROOT/README.md" <<EOF
# $PROJECT_ID

Created: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
Conda env: $CONDA_NAME

## Project Structure

This research project follows the DirForge Constitution v1.0.17 study-based organization:

- \`00_admin/\` - Project contracts, ethics, agreements
- \`01_project_management/\` - Proposals, reports, budgets
- \`02_studies/\` - Container for individual research studies

## Creating Studies

Add studies to this project using:
\`\`\`bash
dirforge init research --project $PROJECT_ID --study "Study Name"
\`\`\`

Each study will be created in \`02_studies/<study_name>/\` with its own protocols, code, data, outputs, and publications.
EOF

  write_file "$RESEARCH_ROOT/project.yaml" <<'EOF'
owner: "<owner name>"
contact: "<email@example.org>"
license: "CC-BY-4.0"
sync_policy: "iCloud: active, External: raw_data_on_nas"
conda_env: "$CONDA_NAME"
EOF

  # Render project management templates
  render_template "$TEMPLATES_DIR/research/01_project_management/README.md.template" "$RESEARCH_ROOT/01_project_management/README.md" "PROJECT_NAME=$title" "PROJECT_ID=$PROJECT_ID"
  render_template "$TEMPLATES_DIR/research/01_project_management/01_proposal/README.md.template" "$RESEARCH_ROOT/01_project_management/01_proposal/README.md" "PROJECT_NAME=$title" "PROJECT_ID=$PROJECT_ID"
  render_template "$TEMPLATES_DIR/research/01_project_management/02_finance/README.md.template" "$RESEARCH_ROOT/01_project_management/02_finance/README.md" "PROJECT_NAME=$title" "PROJECT_ID=$PROJECT_ID"
  render_template "$TEMPLATES_DIR/research/01_project_management/03_reports/README.md.template" "$RESEARCH_ROOT/01_project_management/03_reports/README.md" "PROJECT_NAME=$title" "PROJECT_ID=$PROJECT_ID"
  render_template "$TEMPLATES_DIR/research/01_project_management/04_presentations/README.md.template" "$RESEARCH_ROOT/01_project_management/04_presentations/README.md" "PROJECT_NAME=$title" "PROJECT_ID=$PROJECT_ID"

  # Conda
  if [ "$no_conda" = false ]; then
    local base_pkgs="numpy matplotlib pandas jupyter pyyaml"
    if [ -n "$extra_pkgs" ]; then
      base_pkgs="$base_pkgs $extra_pkgs"
    fi
    create_conda_env "$CONDA_NAME" "$py_ver" $base_pkgs || true
    export_environment_yaml "$CONDA_NAME" "$RESEARCH_ROOT/environment.yaml" "$py_ver" $base_pkgs
    echo "Activate with: conda activate $CONDA_NAME"
  else
    if [ "$JSON_OUTPUT" = false ]; then
      echo "--no-conda specified: skipping conda creation"
    fi
  fi

  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create research project '$PROJECT_ID' in $RESEARCH_ROOT"
    fi
  else
    echo "Created research project '$PROJECT_ID' in $RESEARCH_ROOT"
  fi
}

init_research_study() {
  local project_id="" study_name=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --project|-p) shift; project_id="$1";;
      --study|-s) shift; study_name="$1";;
      *) echo "Unknown arg for study: $1"; exit 1;;
    esac
    shift
  done

  if [ -z "$project_id" ]; then
    show_required_arg_error "--project" "$PROG_NAME" "research"
    exit 1
  fi
  if [ -z "$study_name" ]; then
    show_required_arg_error "--study" "$PROG_NAME" "research"
    exit 1
  fi

  local PROJECT_ROOT="RESEARCH_WORLD/$project_id"
  
  # Check if project exists (skip in dry-run mode for combined operations)
  if [ "$DRY_RUN" = false ] && [ ! -d "$PROJECT_ROOT" ]; then
    show_project_not_found_error "$project_id" "$PROJECT_ROOT"
    exit 1
  fi
  
  # Sanitize study name
  local study_id
  study_id=$(to_snake_case "$study_name")
  
  local STUDY_ROOT="$PROJECT_ROOT/02_studies/$study_id"
  if [ -d "$STUDY_ROOT" ]; then
    if [ "$FORCE" = false ] && [ "$BACKUP" = false ]; then
      echo "Study '$study_id' already exists at $STUDY_ROOT" >&2
      echo "Use --force to overwrite or --backup to create a backup before overwriting" >&2
      exit 1
    fi
    
    prompt_overwrite "$STUDY_ROOT"
    
    if [ "$BACKUP" = true ]; then
      backup_directory "$STUDY_ROOT"
    fi
    
    if [ "$DRY_RUN" = false ]; then
      rm -rf "$STUDY_ROOT"
    fi
  fi
  
  do_mkdir_p "$STUDY_ROOT"
  
  # Create study subdirectories
  for d in 00_protocols 01_code 02_data 03_outputs 04_publication 05_presentations; do
    do_mkdir_p "$STUDY_ROOT/$d"
  done
  
  # Create study .integrity directories
  do_mkdir_p "$STUDY_ROOT/.integrity/checksums"
  do_mkdir_p "$STUDY_ROOT/.integrity/manifests"
  
  # Create study README.md
  write_file "$STUDY_ROOT/README.md" <<EOF
# $study_name ($study_id)

Created: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
Project: $project_id

## Study Overview

**Research Question:** [Brief description of the specific research question this study addresses]

**Methods:** [Brief description of experimental/computational methods]

**Expected Outcomes:** [What results or insights this study aims to produce]

## Directory Structure

- \`00_protocols/\` - Experimental protocols, calibration notes, instrument configurations
- \`01_code/\` - Analysis scripts, notebooks, environment.yml
- \`02_data/\` - Raw and processed datasets, metadata.yaml files
- \`03_outputs/\` - Processed results, figures, tables
- \`04_publication/\` - Manuscript drafts, supplementary materials
- \`05_presentations/\` - Slides and presentations for conferences, meetings
- \`.integrity/\` - Checksums and manifest validation files
EOF

  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create research study '$study_id' in $STUDY_ROOT"
    fi
  else
    echo "Created research study '$study_id' in $STUDY_ROOT"
  fi
}

init_lecture() {
  local name="" py_ver="${PY:-3.11}" no_conda=false extra_pkgs=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --name|-n) shift; name="$1";;
      --python) shift; py_ver="$1";;
      --no-conda) no_conda=true;;
      --conda-packages) shift; extra_pkgs="$1";;
      *) echo "Unknown arg for lecture: $1"; exit 1;;
    esac
    shift
  done
  if [ -z "$name" ]; then
    read -r -p "Lecture name: " name
  fi
  lecture_id=$(to_snake_case "$name")
  if [ "$JSON_OUTPUT" = false ]; then
    echo "Lecture name converted to ID: $lecture_id"
  fi

  LECTURE_ROOT="LECTURE_WORLD/$lecture_id"
  if [ -d "$LECTURE_ROOT" ]; then
    if [ "$FORCE" = false ] && [ "$BACKUP" = false ]; then
      echo "Lecture '$lecture_id' already exists at $LECTURE_ROOT" >&2
      echo "Use --force to overwrite or --backup to create a backup before overwriting" >&2
      exit 1
    fi
    
    # Prompt for confirmation unless --yes is set
    prompt_overwrite "$LECTURE_ROOT"
    
    # Create backup if requested
    if [ "$BACKUP" = true ]; then
      backup_directory "$LECTURE_ROOT"
    fi
    
    # Remove existing directory
    if [ "$DRY_RUN" = false ]; then
      rm -rf "$LECTURE_ROOT"
    fi
  fi
  do_mkdir_p "$LECTURE_ROOT"
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create directory: $LECTURE_ROOT"
    fi
  else
    echo "Created lecture directory: $LECTURE_ROOT"
  fi

  for d in 00_admin 01_code 02_data/experimental_recordings 02_data/reference 03_slides 04_manuscript 05_exercises/problems 05_exercises/solutions 05_exercises/submissions 05_exercises/graded 06_exams/problems 06_exams/solutions 06_exams/submissions 06_exams/graded 07_grades; do
    do_mkdir_p "$LECTURE_ROOT/$d"
  done

  # Create .integrity directories (constitution v1.0.12)
  do_mkdir_p "$LECTURE_ROOT/.integrity/checksums"
  do_mkdir_p "$LECTURE_ROOT/.integrity/manifests"

  write_file "$LECTURE_ROOT/README.md" <<'EOF'
# $name ($lecture_id)

Created: $(date --iso-8601=seconds)
Conda env: lecture_$lecture_id
EOF

  write_file "$LECTURE_ROOT/project.yaml" <<'EOF'
course_code: "<COURSE_CODE>"
title: "$name"
term: "<TERM>"
instructor:
  name: "<Instructor Name>"
  email: "<email@example.org>"
sync_policy: "iCloud: slides/manuscript; External: raw_recordings_on_nas"
conda_env: "lecture_$lecture_id"
project_id: "$lecture_id"
created: "$(date +%Y-%m-%d)"
EOF

  # Conda
  if [ "$no_conda" = false ]; then
    local base_pkgs="numpy matplotlib pandas jupyter pyyaml scipy seaborn ipywidgets"
    # beamer is not a python package, leave as note
    if [ -n "$extra_pkgs" ]; then
      base_pkgs="$base_pkgs $extra_pkgs"
    fi
    CONDA_NAME="lecture_$lecture_id"
    create_conda_env "$CONDA_NAME" "$py_ver" $base_pkgs || true
    export_environment_yaml "$CONDA_NAME" "$LECTURE_ROOT/01_code/environment.yaml" "$py_ver" $base_pkgs
    echo "Conda environment created: $CONDA_NAME"
    echo "Activate with: conda activate $CONDA_NAME"
  else
    if [ "$JSON_OUTPUT" = false ]; then
      echo "--no-conda specified: skipping conda creation"
    fi
  fi

  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create lecture project '$lecture_id' in $LECTURE_ROOT"
    fi
  else
    echo "Created lecture project '$lecture_id' in $LECTURE_ROOT"
  fi
}

init_coding() {
  local language="" project="" py_ver="${PY:-3.11}" skip_conda=false skip_git=false
  local no_git=false no_conda=false
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --language|-l)
        shift; language=$(echo "$1" | tr '[:upper:]' '[:lower:]') ;;
      --project|-p)
        shift; project="$1" ;;
      --python)
        shift; py_ver="$1" ;;
      --no-conda)
        skip_conda=true ;;
      --no-git)
        skip_git=true ;;
      --help)
        if declare -F show_coding_help >/dev/null 2>&1; then
          show_coding_help
        else
          echo "Usage: $PROG_NAME init coding --language <lang> --project <name> [options]"
        fi
        return 0 ;;
      *) echo "Unknown arg for coding: $1"; exit 1 ;;
    esac
    shift
  done

  if [ -z "$language" ] || [ -z "$project" ]; then
    show_coding_missing_args_error "$language" "$project" "$skip_conda" "$skip_git" "$py_ver" "$PROG_NAME"
    return 1
  fi

  case "$language" in
    python|matlab|fortran|bash)
      ;; 
    *)
      show_unsupported_language_error "$language" "$PROG_NAME"
      return 1
      ;;
  esac

  proj_id=$(to_snake_case "$project")
  local ROOT="CODING_WORLD/${language}/${proj_id}"

  if [ -d "$ROOT" ]; then
    if [ "$FORCE" = false ] && [ "$BACKUP" = false ]; then
      show_project_exists_error "$proj_id" "$ROOT"
      return 1
    fi
    prompt_overwrite "$ROOT"
    if [ "$BACKUP" = true ]; then
      backup_directory "$ROOT"
    fi
    if [ "$DRY_RUN" = false ]; then
      rm -rf "$ROOT"
    fi
  fi

  case "$language" in
    python)
      init_coding_python "$ROOT" "$proj_id" "$py_ver" "$skip_conda" "$skip_git"
      ;;
    matlab)
      init_coding_matlab "$ROOT" "$proj_id" "$skip_git"
      ;;
    fortran)
      init_coding_fortran "$ROOT" "$proj_id" "$py_ver" "$skip_conda" "$skip_git"
      ;;
    bash)
      init_coding_bash "$ROOT" "$proj_id" "$skip_git"
      ;;
  esac

  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create ${language} project at $ROOT"
    fi
  else
    echo "✓ ${language} project created: ${ROOT}"
    if { [ "$language" = "python" ] || [ "$language" = "fortran" ]; } && [ "$skip_conda" = false ]; then
      echo "✓ Conda environment: coding_${proj_id}"
      echo "Activate with: conda activate coding_${proj_id}"
    fi
  fi
}

# Language-specific initializers
init_coding_python() {
  local project_dir="$1" project_name="$2" py_ver="$3" skip_conda="$4" skip_git="$5"
  do_mkdir_p "$project_dir/src/$project_name" "$project_dir/tests" "$project_dir/docs"

  write_file "$project_dir/README.md" <<EOF
# $project_name

Created: $(date +%Y-%m-%d)
Language: Python
EOF

  write_file "$project_dir/pyproject.toml" <<'EOF'
[build-system]
requires = ["setuptools", "wheel"]
build-backend = "setuptools.build_meta"
EOF

  write_file "$project_dir/src/$project_name/__init__.py" <<EOF
"""$project_name package."""
__version__ = "0.1.0"
EOF

  write_file "$project_dir/tests/test_example.py" <<'EOF'
def test_smoke():
  assert True
EOF

  if [ "$skip_conda" = false ]; then
    local CONDA_NAME="coding_${project_name}"
    local base_pkgs="numpy matplotlib pandas jupyter pytest black flake8"
    create_conda_env "$CONDA_NAME" "$py_ver" $base_pkgs || true
    export_environment_yaml "$CONDA_NAME" "$project_dir/environment.yaml" "$py_ver" $base_pkgs
  fi

  if [ "$skip_git" = false ]; then
    init_git_repo() { :; } || true
    if [ "$DRY_RUN" = false ]; then
      (cd "$project_dir" && git init >/dev/null 2>&1 || true)
    fi
    write_file "$project_dir/.gitignore" <<'EOF'
__pycache__/
.pytest_cache/
*.pyc
.venv/
env/
EOF
  fi
}

init_coding_matlab() {
  local project_dir="$1" project_name="$2" skip_git="$3"
  do_mkdir_p "$project_dir/src" "$project_dir/functions" "$project_dir/tests" "$project_dir/data" "$project_dir/figures" "$project_dir/docs"

  write_file "$project_dir/README.md" <<EOF
# $project_name

Created: $(date +%Y-%m-%d)
Language: MATLAB
EOF

  write_file "$project_dir/src/main.m" <<'EOF'
% Main entry for $PROJECT_NAME
disp('Hello from MATLAB project')
EOF

  write_file "$project_dir/project.yaml" <<EOF
project:
  name: ${project_name}
  language: matlab
  created: $(date +%Y-%m-%d)
  owner: ${USER}
EOF

  touch "$project_dir/data/.gitkeep" || true
  touch "$project_dir/figures/.gitkeep" || true

  if [ "$skip_git" = false ]; then
    if [ "$DRY_RUN" = false ]; then
      (cd "$project_dir" && git init >/dev/null 2>&1 || true)
    fi
    write_file "$project_dir/.gitignore" <<'EOF'
*.asv
*.mat
slprj/
figures/*.png
EOF
  fi
}

init_coding_fortran() {
  local project_dir="$1" project_name="$2" py_ver="$3" skip_conda="$4" skip_git="$5"
  do_mkdir_p "$project_dir/src" "$project_dir/modules" "$project_dir/tests" "$project_dir/build" "$project_dir/docs"

  write_file "$project_dir/README.md" <<EOF
# $project_name

Created: $(date +%Y-%m-%d)
Language: Fortran
EOF

  write_file "$project_dir/Makefile" <<'EOF'
FC = gfortran
FCFLAGS = -O2 -fcheck=all
SRC = src/main.f90
all:
	$(FC) $(FCFLAGS) -o build/$(notdir $(SRC:.f90=)) $(SRC)
EOF

  write_file "$project_dir/src/main.f90" <<'EOF'
! Main program for $PROJECT_NAME
program main
  print *, 'Hello Fortran'
end program main
EOF

  if [ "$skip_conda" = false ]; then
    local CONDA_NAME="coding_${project_name}"
    local base_pkgs="gfortran numpy"
    create_conda_env "$CONDA_NAME" "$py_ver" $base_pkgs || true
    export_environment_yaml "$CONDA_NAME" "$project_dir/environment.yaml" "$py_ver" $base_pkgs
  fi

  if [ "$skip_git" = false ]; then
    if [ "$DRY_RUN" = false ]; then
      (cd "$project_dir" && git init >/dev/null 2>&1 || true)
    fi
    write_file "$project_dir/.gitignore" <<'EOF'
*.o
*.mod
build/
*.out
EOF
  fi
}

init_coding_bash() {
  local project_dir="$1" project_name="$2" skip_git="$3"
  do_mkdir_p "$project_dir/bin" "$project_dir/lib" "$project_dir/tests" "$project_dir/config" "$project_dir/docs"

  write_file "$project_dir/README.md" <<EOF
# $project_name

Created: $(date +%Y-%m-%d)
Language: Bash
EOF

  write_file "$project_dir/bin/${project_name}.sh" <<'EOF'
#!/usr/bin/env bash
echo "Hello from $PROJECT_NAME"
EOF

  if [ "$DRY_RUN" = false ]; then
    chmod +x "$project_dir/bin/${project_name}.sh" || true
  fi

  write_file "$project_dir/project.yaml" <<EOF
project:
  name: ${project_name}
  language: bash
  created: $(date +%Y-%m-%d)
  owner: ${USER}
EOF

  if [ "$skip_git" = false ]; then
    if [ "$DRY_RUN" = false ]; then
      (cd "$project_dir" && git init >/dev/null 2>&1 || true)
    fi
    write_file "$project_dir/.gitignore" <<'EOF'
*.log
tmp/
.env
*.bak
EOF
  fi
}

init_journal() {
  local journal_name="" id=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --journal|-j) shift; journal_name="$1";;
      --id|-i) shift; id="$1";;
      *) echo "Unknown arg for journal: $1"; exit 1;;
    esac
    shift
  done
  if [ -z "$journal_name" ]; then
    read -r -p "Journal name: " journal_name
  fi
  if [ -z "$id" ]; then
    read -r -p "Manuscript ID: " id
  fi

  # Convert to UPPER_SNAKE_CASE: transliterate, uppercase, replace non-alnum with underscore
  local jtmp journal_u
  if command -v iconv >/dev/null 2>&1; then
    jtmp=$(printf "%s" "$journal_name" | iconv -f utf8 -t ascii//TRANSLIT 2>/dev/null)
  else
    jtmp="$journal_name"
  fi
  journal_u=$(printf "%s" "$jtmp" | tr '[:lower:]' '[:upper:]' | sed -E 's/[^A-Z0-9]+/_/g' | sed -E 's/^_+|_+$//g')

  JOURNAL_ROOT="JOURNAL_WORLD/$journal_u/$id"
  if [ -d "$JOURNAL_ROOT" ]; then
    echo "Journal manuscript already exists at $JOURNAL_ROOT" >&2
    exit 1
  fi

  do_mkdir_p "$JOURNAL_ROOT/manuscript" "$JOURNAL_ROOT/reviews" "$JOURNAL_ROOT/correspondence"

  write_file "$JOURNAL_ROOT/README.md" <<'EOF'
# $journal_u / $id

Created: $(date --iso-8601=seconds)
Journal: $journal_name
Manuscript ID: $id
EOF

  write_file "$JOURNAL_ROOT/project.yaml" <<'EOF'
journal_name: "$journal_u"
manuscript_id: "$id"
created: "$(date +%Y-%m-%d)"
EOF

  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create journal manuscript: $JOURNAL_ROOT"
    fi
  else
    echo "Created journal manuscript: $JOURNAL_ROOT"
  fi
}

handle_help_request() {
  # Route help requests to appropriate help functions based on context
  # Usage: handle_help_request [command] [world-type-or-subcommand] [world-type]
  
  local cmd="${1:-}"
  local arg2="${2:-}"
  local arg3="${3:-}"
  
  # Determine if arg2 is a world type or subcommand
  local world=""
  local subcmd=""
  
  case "$arg2" in
    research|lecture|coding|journal|office|private)
      # arg2 is a world type
      world="$arg2"
      subcmd="${arg3:-}"
      ;;
    *)
      # arg2 is a subcommand or empty
      subcmd="$arg2"
      world="$arg3"
      ;;
  esac
  
  # DEBUG: uncomment for troubleshooting
  # echo "DEBUG: cmd='$cmd' subcmd='$subcmd' world='$world' (arg2='$arg2' arg3='$arg3')" >&2
  
  # Check if help system is available
  if ! declare -F show_global_help >/dev/null 2>&1; then
    # Fallback to basic usage if help system not available
    usage
    return
  fi
  
  case "$cmd" in
    ""|"help"|"--help"|"-h")
      # Default to short help for quick reference
      if declare -F show_global_help_short >/dev/null 2>&1; then
        show_global_help_short
      else
        show_global_help
      fi
      ;;
    "--help-long")
      # Detailed comprehensive help
      show_global_help
      ;;
    "init")
      if [ -n "$world" ]; then
        # World-specific help: dirforge init research --help
        if declare -F show_world_help >/dev/null 2>&1; then
          show_world_help "$world"
        else
          show_command_help "init"
        fi
      else
        # Command help: dirforge init --help
        if declare -F show_command_help >/dev/null 2>&1; then
          show_command_help "init"
        else
          show_global_help
        fi
      fi
      ;;
    "--version"|"-v")
      echo "$PROG_NAME (DirForge Constitution $CONSTITUTION_VERSION)"
      echo "Enhanced Terminal Help System"
      ;;
    *)
      # Unknown command - show contextual help
      echo "Unknown command: $cmd" >&2
      echo >&2
      if declare -F show_global_help >/dev/null 2>&1; then
        echo "Available commands:" >&2
        show_global_help | grep -A5 "Usage" || usage
      else
        usage
      fi
      exit 1
      ;;
  esac
}

init_all_worlds() {
  # Create top-level directory structure with all world types
  local target_path="."
  local auto_create=false
  
  # Parse arguments
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --auto|--yes|-y)
        auto_create=true
        shift
        ;;
      --here)
        target_path="."
        shift
        ;;
      --path=*)
        target_path="${1#--path=}"
        shift
        ;;
      -*)
        echo "Unknown option: $1" >&2
        echo "Usage: $PROG_NAME init [path] [--auto|--yes|-y] [--here] [--path=PATH]" >&2
        exit 1
        ;;
      *)
        # First non-option argument is the target path
        target_path="$1"
        shift
        ;;
    esac
  done
  
  # Convert to absolute path and normalize
  if [[ "$target_path" == "." ]]; then
    target_path="$(pwd)"
  elif [[ "$target_path" != /* ]]; then
    target_path="$(pwd)/$target_path"
  fi
  
  echo "Initializing DirForge workspace at: $target_path"
  echo
  
  # Check if target directory exists and is not empty
  if [ -d "$target_path" ] && [ "$(ls -A "$target_path" 2>/dev/null | wc -l)" -gt 0 ]; then
    if [ "$auto_create" = false ] && [ "$YES" = false ] && [ "$FORCE" = false ]; then
      echo "WARNING: Directory '$target_path' exists and is not empty." >&2
      echo "Contents will be preserved, but new world directories will be created alongside existing files." >&2
      read -r -p "Continue with initialization? [y/N] " response
      case "$response" in
        [yY][eE][sS]|[yY]) 
          ;;
        *)
          echo "Initialization cancelled." >&2
          exit 1
          ;;
      esac
    fi
  fi
  
  # Create base directory if it doesn't exist
  do_mkdir_p "$target_path"
  
  # Define all world types - per DirForge Constitution v1.0.17
  local worlds=(
    "CODING_WORLD"
    "JOURNAL_WORLD" 
    "LECTURE_WORLD"
    "LITERATURE_WORLD"
    "OFFICE_WORLD"
    "PRIVATE_WORLD"
    "RESEARCH_WORLD"
  )
  
  # Only OFFICE_WORLD and PRIVATE_WORLD get subfolders during workspace init
  # Other worlds remain empty until specific projects are created
  
  local office_dirs=(
    "00_admin"
    "01_finance"
    "02_hr_administration"
    "03_faculty"
    "04_inventory_equipment"
    "05_software_licenses"
    "06_public_relations"
    "90_archive"
  )
  
  local private_dirs=(
    "00_admin"
    "01_credentials"
    "02_id_contracts"
    "03_finance"
    "04_documents"
    "05_photos"
    "06_movies"
    "07_hiking"
    "09_installers"
    "90_archive"
  )
  
  # Create world directories
  for world in "${worlds[@]}"; do
    local world_path="$target_path/$world"
    do_mkdir_p "$world_path"
    
    # Per Constitution: Only OFFICE_WORLD and PRIVATE_WORLD get subfolders at init
    # All others remain empty until specific projects are created
    case "$world" in
      OFFICE_WORLD)
        for dir in "${office_dirs[@]}"; do
          do_mkdir_p "$world_path/$dir"
        done
        ;;
      PRIVATE_WORLD)
        for dir in "${private_dirs[@]}"; do
          do_mkdir_p "$world_path/$dir"
        done
        ;;
      CODING_WORLD|JOURNAL_WORLD|LECTURE_WORLD|RESEARCH_WORLD|LITERATURE_WORLD)
        # These remain empty - projects created by specific init commands
        ;;
    esac
  done
  
  
  if [ "$DRY_RUN" = true ]; then
    echo "DRY RUN: would create complete DirForge workspace at $target_path"
  else
    echo
    echo "✅ Workspace initialized at: $target_path"
    echo
    echo "Created world directories:"
    echo "  CODING_WORLD/           (empty - use 'dirforge init coding' to create projects)"
    echo "  JOURNAL_WORLD/          (empty - use 'dirforge init journal' to create activities)"
    echo "  LECTURE_WORLD/          (empty - use 'dirforge init lecture' to create courses)"
    echo "  LITERATURE_WORLD/       (empty - user-managed)"
    echo "  OFFICE_WORLD/           (with 7 subfolders)"
    echo "  PRIVATE_WORLD/          (with 10 subfolders)"
    echo "  RESEARCH_WORLD/         (empty - use 'dirforge init research' to create projects)"
    echo
    echo "Constitution version: v1.0.17"
    echo
    echo "Next steps:"
    echo "  • Create a research project: $PROG_NAME init research --name \"Project Name\""
    echo "  • Create a lecture: $PROG_NAME init lecture --name \"Course Name\""
    echo "  • Create a coding project: $PROG_NAME init coding --language python --project \"name\""
    echo "  • Create a journal activity: $PROG_NAME init journal --journal \"Journal Name\" --id \"MS-ID\""
  fi
}

suggest_world_help() {
  # Suggest valid world types for unknown world types
  local invalid_world="$1"
  local valid_worlds="research lecture coding journal office private"
  
  echo "Unknown world type: $invalid_world" >&2
  echo >&2
  echo "Valid world types:" >&2
  for world in $valid_worlds; do
    echo "  $world" >&2
  done
  echo >&2
  echo "For detailed help on a specific world type:" >&2
  echo "  $PROG_NAME init <world-type> --help" >&2
  echo >&2
  echo "Examples:" >&2
  echo "  $PROG_NAME init research --help" >&2
  echo "  $PROG_NAME init lecture --help" >&2
  echo >&2
  echo "To initialize a complete workspace with all worlds:" >&2
  echo "  $PROG_NAME init [path] [--auto]" >&2
}

usage() {
  cat <<EOF
Usage: 
  $PROG_NAME init <world> [options]        # Create specific world project
  $PROG_NAME init [path] [--auto]          # Initialize complete workspace with all worlds

World types: research, lecture, coding, journal, office, private

Global options:
  --dry-run, --preview    Preview changes without writing to filesystem
  --json                  Output machine-readable JSON plan (requires --dry-run)
  --force                 Overwrite existing projects without prompting
  --backup                Create timestamped backups before overwriting
  --yes, -y               Skip interactive prompts and proceed

Complete workspace initialization:
  path                    Target directory (default: current directory)
  --auto, --yes, -y       Create automatically without prompts
  --here                  Explicitly use current directory

Examples:
  # Initialize complete workspace
  $PROG_NAME init
  $PROG_NAME init /path/to/workspace --auto
  $PROG_NAME init ~/myworkspace
  
  # Create specific world projects
  $PROG_NAME init research --name "Thermal Model Analysis" --python 3.11
  $PROG_NAME init lecture --name "Digital Rock Physics"
  $PROG_NAME init coding --language python --project ml_toolkit
  
  # Preview changes
  $PROG_NAME --dry-run init ~/test-workspace
  $PROG_NAME --dry-run --json init research --name "Test" | jq .
EOF
}

output_json_plan() {
  # Output accumulated dry-run plan as JSON
  echo "{"
  echo '  "dry_run": true,'
  echo '  "directories": ['
  local first=true
  for dir in "${JSON_DIRS[@]}"; do
    if [ "$first" = false ]; then echo ","; fi
    printf '    "%s"' "$(json_escape "$dir")"
    first=false
  done
  echo ""
  echo '  ],'
  echo '  "files": ['
  first=true
  if [ "${#JSON_FILES[@]}" -gt 0 ]; then
    for file in "${JSON_FILES[@]}"; do
      if [ "$first" = false ]; then echo ","; fi
      printf '    "%s"' "$(json_escape "$file")"
      first=false
    done
  fi
  echo ""
  echo '  ]'
  echo "}"
}

main() {
  # Handle help and version flags first (before parsing other options)
  case "${1:-}" in
    --help|-h|help)
      handle_help_request
      exit 0
      ;;
    --version|-v|version)
      handle_help_request "--version"
      exit 0
      ;;
  esac

  # Global flags: support --dry-run or --preview anywhere in the args
  new_args=()
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --dry-run|--preview)
        DRY_RUN=true; shift;;
      --json)
        JSON_OUTPUT=true; shift;;
      --force)
        FORCE=true; shift;;
      --backup)
        BACKUP=true; shift;;
      --yes|-y)
        YES=true; shift;;
      --help|-h)
        # Context-aware help handling
        if [ "${#new_args[@]}" -gt 0 ]; then
          handle_help_request "${new_args[@]}"
        else
          handle_help_request
        fi
        exit 0
        ;;
      *) new_args+=("$1"); shift;;
    esac
  done
  
  # Validate JSON requires dry-run
  if [ "$JSON_OUTPUT" = true ] && [ "$DRY_RUN" = false ]; then
    show_json_requires_dryrun_error
    exit 1
  fi
  
  # Restore positional params
  set -- "${new_args[@]}"
  if [ "$#" -lt 1 ]; then
    handle_help_request
    exit 1
  fi
  
  cmd="$1"; shift
  case "$cmd" in
    init)
      # Check if there are any arguments
      if [ "$#" -eq 0 ]; then
        # No arguments - initialize complete workspace in current directory
        init_all_worlds "."
      else
        # Check if first argument is a help flag
        case "$1" in
          --help|-h)
            handle_help_request "init"
            exit 0
            ;;
          research|lecture|coding|journal|office|private)
            # Traditional world-specific init
            world="$1"
            shift
            
            # Check for help flags before processing world
            case "${1:-}" in
              --help|-h)
                # Short help for world type
                if declare -F show_world_help >/dev/null 2>&1; then
                  show_world_help "$world" "short"
                  exit 0
                fi
                ;;
              --help-long)
                # Long/detailed help for world type
                if declare -F show_world_help >/dev/null 2>&1; then
                  show_world_help "$world" "long"
                  exit 0
                fi
                ;;
            esac
            
            case "$world" in
              research) init_research "$@" ;;
              lecture) init_lecture "$@" ;;
              coding) init_coding "$@" ;;
              journal) init_journal "$@" ;;
              office)
                echo "Creating OFFICE_WORLD standard folders..."
                for d in 00_admin 01_finance 02_hr_administration 03_faculty 04_inventory_equipment 05_software_licenses 06_public_relations; do
                  do_mkdir_p "OFFICE_WORLD/$d"
                done
                if [ "$DRY_RUN" = true ]; then
                  echo "DRY RUN: would create OFFICE_WORLD/"
                else
                  echo "Created OFFICE_WORLD/"
                fi ;;
              private)
                echo "Creating PRIVATE_WORLD standard folders..."
                for d in 00_admin 01_credentials 02_id_contracts 03_finance 04_documents 05_photos 06_movies 07_hiking 09_installers 90_archive; do
                  do_mkdir_p "PRIVATE_WORLD/$d"
                done
                if [ "$DRY_RUN" = true ]; then
                  echo "DRY RUN: would create PRIVATE_WORLD/"
                else
                  echo "Created PRIVATE_WORLD/"
                fi ;;
            esac
            ;;
          *)
            # Initialize complete workspace (all worlds) - could be path or flags
            init_all_worlds "$@"
            ;;
        esac
      fi
      
      # Output JSON plan if requested
      if [ "$JSON_OUTPUT" = true ]; then
        output_json_plan
      fi
    ;;
    *) 
      handle_help_request "$cmd"
      exit 1
      ;;
  esac
}

main "$@"
