#!/usr/bin/env bash
set -euo pipefail

# dirforge - create standardized directory structures per DirForge Constitution
# Minimal, portable bash CLI that implements `dirforge init <world-type>`

PROG_NAME="dirforge"

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Detect library directory (development vs installed)
if [ -d "$SCRIPT_DIR/../lib" ]; then
    # Development mode - script is in tools/, libraries in lib/
    LIB_DIR="$(cd "$SCRIPT_DIR/../lib" && pwd)"
elif [ -d "$HOME/.local/lib/dirforge" ]; then
    # Local installation mode  
    LIB_DIR="$HOME/.local/lib/dirforge"
elif [ -d "/usr/local/lib/dirforge" ]; then
    # System installation mode
    LIB_DIR="/usr/local/lib/dirforge"
else
    # Fallback - try relative path anyway
    LIB_DIR="$SCRIPT_DIR/../lib"
fi

# Source help system libraries if available
if [ -f "$LIB_DIR/terminal.sh" ]; then
    source "$LIB_DIR/terminal.sh"
fi
if [ -f "$LIB_DIR/colors.sh" ]; then
    source "$LIB_DIR/colors.sh"
    init_colors 2>/dev/null || true
fi
if [ -f "$LIB_DIR/help.sh" ]; then
    source "$LIB_DIR/help.sh"
fi

CONSTITUTION_VERSION="v1.0.16"

# Dry-run flag (preview mode). When true, filesystem changes are not written; actions are printed.
DRY_RUN=false
# JSON output flag. When true with DRY_RUN, output machine-readable JSON plan.
JSON_OUTPUT=false
# Force flag. When true, overwrite existing projects without prompting.
FORCE=false
# Backup flag. When true, create timestamped backups before overwriting.
BACKUP=false
# Yes flag. When true, skip interactive prompts and proceed.
YES=false

# JSON plan accumulator (used when JSON_OUTPUT=true)
JSON_DIRS=()
JSON_FILES=()

json_escape() {
  # Escape string for JSON (basic escaping, remove trailing newline)
  printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g'
}

do_mkdir_p() {
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = true ]; then
      for dir in "$@"; do
        JSON_DIRS+=("$dir")
      done
    else
      echo "DRY RUN: mkdir -p $*"
    fi
  else
    mkdir -p "$@"
  fi
}

write_file() {
  # usage: write_file <dest> <<'EOF'...EOF
  local dest="$1"
  shift
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = true ]; then
      # Capture file content for JSON
      local content
      content=$(cat)
      JSON_FILES+=("$dest")
    else
      echo "DRY RUN: would write file: $dest"
      # print a snippet of the content for visibility
      awk '{ if (NR<=20) print "    " $0 }' || true
      # consume stdin
      cat >/dev/null
    fi
  else
    mkdir -p "$(dirname "$dest")"
    cat > "$dest"
  fi
}

to_snake_case() {
  # Convert a string to lower_snake_case: transliterate, lowercase, replace non-alnum with _, trim
  local s="$*"
  # Use iconv if available for transliteration, else rely on sed
  if command -v iconv >/dev/null 2>&1; then
    s=$(printf "%s" "$s" | iconv -f utf8 -t ascii//TRANSLIT 2>/dev/null)
  fi
  printf "%s" "$s" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9_-]+/_/g' | sed -E 's/^_+|_+$//g'
}

strip_year_prefix() {
  local id="$1"
  echo "$id" | sed -E 's/^[0-9]{4}_//'
}

backup_directory() {
  local src="$1"
  local timestamp
  timestamp=$(date +%Y%m%d-%H%M%S)
  local backup_dir="${src}.backup-${timestamp}"
  
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create backup: $backup_dir"
    fi
  else
    cp -R "$src" "$backup_dir"
    echo "Created backup: $backup_dir"
  fi
}

prompt_overwrite() {
  local project_path="$1"
  
  # Skip prompt if --yes or --force is set
  if [ "$YES" = true ] || [ "$FORCE" = true ]; then
    return 0
  fi
  
  echo "WARNING: Project already exists at $project_path" >&2
  if [ "$BACKUP" = true ]; then
    echo "A backup will be created before overwriting." >&2
  fi
  read -r -p "Overwrite existing project? [y/N] " response
  case "$response" in
    [yY][eE][sS]|[yY]) 
      return 0
      ;;
    *)
      echo "Operation cancelled." >&2
      exit 1
      ;;
  esac
}

conda_env_exists() {
  local name="$1"
  if ! command -v conda >/dev/null 2>&1; then
    return 1
  fi
  conda info --envs 2>/dev/null | awk '{print $1}' | grep -xq "$name" || return 1
}

create_conda_env() {
  local env_name="$1"; shift
  local py_ver="$1"; shift
  local packages="$*"
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create conda environment: $env_name (python=$py_ver)"
    fi
    return 0
  fi
  if ! command -v conda >/dev/null 2>&1; then
    echo "Conda not found in PATH — skipping env creation (or use --no-conda to suppress)." >&2
    return 0
  fi
  if conda_env_exists "$env_name"; then
    echo "Conda environment '$env_name' already exists - skipping creation."
    return 0
  fi
  echo "Creating conda environment: $env_name"
  conda create -n "$env_name" python="$py_ver" $packages -y
}

export_environment_yml() {
  local env_name="$1"; shift
  local dest="$1"; shift
  local py_ver="$1"; shift
  local packages="$*"
  do_mkdir_p "$(dirname "$dest")"
  write_file "$dest" <<EOF
name: $env_name
channels:
  - defaults
dependencies:
  - python=$py_ver
$(for p in $packages; do echo "  - $p"; done)
EOF
}

init_research() {
  local title="${TITLE:-}" py_ver="${PY:-3.11}" no_conda=false extra_pkgs=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --title) shift; title="$1";;
      --python) shift; py_ver="$1";;
      --no-conda) no_conda=true;;
      --conda-packages) shift; extra_pkgs="$1";;
      *) echo "Unknown arg: $1"; exit 1;;
    esac
    shift
  done
  if [ -z "$title" ]; then
    read -r -p "Project title: " title
  fi
  local id_raw
  id_raw=$(to_snake_case "$title")
  # prefix with year if not present
  local year
  year=$(date +%Y)
  if [[ "$id_raw" =~ ^[0-9]{4}_ ]]; then
    PROJECT_ID="$id_raw"
  else
    PROJECT_ID="${year}_$id_raw"
  fi
  # conda env name
  local id_no_year
  id_no_year=$(strip_year_prefix "$PROJECT_ID")
  CONDA_NAME="research_${id_no_year}"

  RESEARCH_ROOT="RESEARCH_WORLD/$PROJECT_ID"
  if [ -d "$RESEARCH_ROOT" ]; then
    if [ "$FORCE" = false ] && [ "$BACKUP" = false ]; then
      echo "Project '$PROJECT_ID' already exists at $RESEARCH_ROOT" >&2
      echo "Use --force to overwrite or --backup to create a backup before overwriting" >&2
      exit 1
    fi
    
    # Prompt for confirmation unless --yes is set
    prompt_overwrite "$RESEARCH_ROOT"
    
    # Create backup if requested
    if [ "$BACKUP" = true ]; then
      backup_directory "$RESEARCH_ROOT"
    fi
    
    # Remove existing directory
    if [ "$DRY_RUN" = false ]; then
      rm -rf "$RESEARCH_ROOT"
    fi
  fi
  do_mkdir_p "$RESEARCH_ROOT"
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create directory: $RESEARCH_ROOT"
    fi
  else
    echo "Created directory: $RESEARCH_ROOT"
  fi

  # create numbered subfolders
  for d in 01_project_management 02_admin 03_design_protocols 04_data 05_data_analysis 06_data_outputs 07_publication 08_documentation; do
    do_mkdir_p "$RESEARCH_ROOT/$d"
  done

  # Create .integrity directories (constitution v1.0.12)
  do_mkdir_p "$RESEARCH_ROOT/.integrity/checksums"
  do_mkdir_p "$RESEARCH_ROOT/.integrity/manifests"

  # create files
  write_file "$RESEARCH_ROOT/README.md" <<'EOF'
# $PROJECT_ID

Created: $(date --iso-8601=seconds)
Conda env: $CONDA_NAME
EOF

  write_file "$RESEARCH_ROOT/project.yaml" <<'EOF'
owner: "<owner name>"
contact: "<email@example.org>"
license: "CC-BY-4.0"
sync_policy: "iCloud: active, External: raw_data_on_nas"
conda_env: "$CONDA_NAME"
EOF

  # Conda
  if [ "$no_conda" = false ]; then
    local base_pkgs="numpy matplotlib pandas jupyter pyyaml"
    if [ -n "$extra_pkgs" ]; then
      base_pkgs="$base_pkgs $extra_pkgs"
    fi
    create_conda_env "$CONDA_NAME" "$py_ver" $base_pkgs || true
    export_environment_yml "$CONDA_NAME" "$RESEARCH_ROOT/05_data_analysis/environment.yml" "$py_ver" $base_pkgs
    echo "Activate with: conda activate $CONDA_NAME"
  else
    if [ "$JSON_OUTPUT" = false ]; then
      echo "--no-conda specified: skipping conda creation"
    fi
  fi

  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create research project '$PROJECT_ID' in $RESEARCH_ROOT"
    fi
  else
    echo "Created research project '$PROJECT_ID' in $RESEARCH_ROOT"
  fi
}

init_lecture() {
  local name="" py_ver="${PY:-3.11}" no_conda=false extra_pkgs=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --name) shift; name="$1";;
      --python) shift; py_ver="$1";;
      --no-conda) no_conda=true;;
      --conda-packages) shift; extra_pkgs="$1";;
      *) echo "Unknown arg for lecture: $1"; exit 1;;
    esac
    shift
  done
  if [ -z "$name" ]; then
    read -r -p "Lecture name: " name
  fi
  lecture_id=$(to_snake_case "$name")
  if [ "$JSON_OUTPUT" = false ]; then
    echo "Lecture name converted to ID: $lecture_id"
  fi

  LECTURE_ROOT="LECTURE_WORLD/$lecture_id"
  if [ -d "$LECTURE_ROOT" ]; then
    if [ "$FORCE" = false ] && [ "$BACKUP" = false ]; then
      echo "Lecture '$lecture_id' already exists at $LECTURE_ROOT" >&2
      echo "Use --force to overwrite or --backup to create a backup before overwriting" >&2
      exit 1
    fi
    
    # Prompt for confirmation unless --yes is set
    prompt_overwrite "$LECTURE_ROOT"
    
    # Create backup if requested
    if [ "$BACKUP" = true ]; then
      backup_directory "$LECTURE_ROOT"
    fi
    
    # Remove existing directory
    if [ "$DRY_RUN" = false ]; then
      rm -rf "$LECTURE_ROOT"
    fi
  fi
  do_mkdir_p "$LECTURE_ROOT"
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create directory: $LECTURE_ROOT"
    fi
  else
    echo "Created lecture directory: $LECTURE_ROOT"
  fi

  for d in 00_admin 01_code 02_data/experimental_recordings 02_data/reference 03_slides 04_manuscript 05_exercises/problems 05_exercises/solutions 05_exercises/submissions 05_exercises/graded 06_exams/problems 06_exams/solutions 06_exams/submissions 06_exams/graded 07_grades; do
    do_mkdir_p "$LECTURE_ROOT/$d"
  done

  # Create .integrity directories (constitution v1.0.12)
  do_mkdir_p "$LECTURE_ROOT/.integrity/checksums"
  do_mkdir_p "$LECTURE_ROOT/.integrity/manifests"

  write_file "$LECTURE_ROOT/README.md" <<'EOF'
# $name ($lecture_id)

Created: $(date --iso-8601=seconds)
Conda env: lecture_$lecture_id
EOF

  write_file "$LECTURE_ROOT/project.yaml" <<'EOF'
course_code: "<COURSE_CODE>"
title: "$name"
term: "<TERM>"
instructor:
  name: "<Instructor Name>"
  email: "<email@example.org>"
sync_policy: "iCloud: slides/manuscript; External: raw_recordings_on_nas"
conda_env: "lecture_$lecture_id"
project_id: "$lecture_id"
created: "$(date +%Y-%m-%d)"
EOF

  # Conda
  if [ "$no_conda" = false ]; then
    local base_pkgs="numpy matplotlib pandas jupyter pyyaml scipy seaborn ipywidgets"
    # beamer is not a python package, leave as note
    if [ -n "$extra_pkgs" ]; then
      base_pkgs="$base_pkgs $extra_pkgs"
    fi
    CONDA_NAME="lecture_$lecture_id"
    create_conda_env "$CONDA_NAME" "$py_ver" $base_pkgs || true
    export_environment_yml "$CONDA_NAME" "$LECTURE_ROOT/01_code/environment.yml" "$py_ver" $base_pkgs
    echo "Conda environment created: $CONDA_NAME"
    echo "Activate with: conda activate $CONDA_NAME"
  else
    if [ "$JSON_OUTPUT" = false ]; then
      echo "--no-conda specified: skipping conda creation"
    fi
  fi

  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create lecture project '$lecture_id' in $LECTURE_ROOT"
    fi
  else
    echo "Created lecture project '$lecture_id' in $LECTURE_ROOT"
  fi
}

init_coding() {
  local language="" project="" py_ver="${PY:-3.11}"
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --language) shift; language="$1";;
      --project) shift; project="$1";;
      --python) shift; py_ver="$1";;
      *) echo "Unknown arg for coding: $1"; exit 1;;
    esac
    shift
  done
  if [ "$language" != "python" ]; then
    echo "Only python language supported for coding init currently."; exit 1
  fi
  if [ -z "$project" ]; then
    read -r -p "Project name: " project
  fi
  proj_id=$(to_snake_case "$project")
  ROOT="CODING_WORLD/python/$proj_id"
  if [ -d "$ROOT" ]; then
    echo "Project exists: $ROOT"; exit 1
  fi
  do_mkdir_p "$ROOT/src" "$ROOT/tests" "$ROOT/docs"
  write_file "$ROOT/README.md" <<'EOF'
# $proj_id

Created: $(date --iso-8601=seconds)
EOF

  CONDA_NAME="coding_$proj_id"
  base_pkgs="numpy matplotlib pandas jupyter pyyaml"
  create_conda_env "$CONDA_NAME" "$py_ver" $base_pkgs || true
  export_environment_yml "$CONDA_NAME" "$ROOT/environment.yml" "$py_ver" $base_pkgs
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create coding project at $ROOT"
    fi
  else
    echo "Activate with: conda activate $CONDA_NAME"
    echo "Created coding project at $ROOT"
  fi
}

init_journal() {
  local journal_name="" id=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --journal) shift; journal_name="$1";;
      --id) shift; id="$1";;
      *) echo "Unknown arg for journal: $1"; exit 1;;
    esac
    shift
  done
  if [ -z "$journal_name" ]; then
    read -r -p "Journal name: " journal_name
  fi
  if [ -z "$id" ]; then
    read -r -p "Manuscript ID: " id
  fi

  # Convert to UPPER_SNAKE_CASE: transliterate, uppercase, replace non-alnum with underscore
  local jtmp journal_u
  if command -v iconv >/dev/null 2>&1; then
    jtmp=$(printf "%s" "$journal_name" | iconv -f utf8 -t ascii//TRANSLIT 2>/dev/null)
  else
    jtmp="$journal_name"
  fi
  journal_u=$(printf "%s" "$jtmp" | tr '[:lower:]' '[:upper:]' | sed -E 's/[^A-Z0-9]+/_/g' | sed -E 's/^_+|_+$//g')

  JOURNAL_ROOT="JOURNAL_WORLD/$journal_u/$id"
  if [ -d "$JOURNAL_ROOT" ]; then
    echo "Journal manuscript already exists at $JOURNAL_ROOT" >&2
    exit 1
  fi

  do_mkdir_p "$JOURNAL_ROOT/manuscript" "$JOURNAL_ROOT/reviews" "$JOURNAL_ROOT/correspondence"

  write_file "$JOURNAL_ROOT/README.md" <<'EOF'
# $journal_u / $id

Created: $(date --iso-8601=seconds)
Journal: $journal_name
Manuscript ID: $id
EOF

  write_file "$JOURNAL_ROOT/project.yaml" <<'EOF'
journal_name: "$journal_u"
manuscript_id: "$id"
created: "$(date +%Y-%m-%d)"
EOF

  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create journal manuscript: $JOURNAL_ROOT"
    fi
  else
    echo "Created journal manuscript: $JOURNAL_ROOT"
  fi
}

handle_help_request() {
  # Route help requests to appropriate help functions based on context
  # Usage: handle_help_request [command] [world-type-or-subcommand] [world-type]
  
  local cmd="${1:-}"
  local arg2="${2:-}"
  local arg3="${3:-}"
  
  # Determine if arg2 is a world type or subcommand
  local world=""
  local subcmd=""
  
  case "$arg2" in
    research|lecture|coding|journal|office|private)
      # arg2 is a world type
      world="$arg2"
      subcmd="${arg3:-}"
      ;;
    *)
      # arg2 is a subcommand or empty
      subcmd="$arg2"
      world="$arg3"
      ;;
  esac
  
  # DEBUG: uncomment for troubleshooting
  # echo "DEBUG: cmd='$cmd' subcmd='$subcmd' world='$world' (arg2='$arg2' arg3='$arg3')" >&2
  
  # Check if help system is available
  if ! declare -F show_global_help >/dev/null 2>&1; then
    # Fallback to basic usage if help system not available
    usage
    return
  fi
  
  case "$cmd" in
    ""|"help"|"--help"|"-h")
      show_global_help
      ;;
    "init")
      if [ -n "$world" ]; then
        # World-specific help: dirforge init research --help
        if declare -F show_world_help >/dev/null 2>&1; then
          show_world_help "$world"
        else
          show_command_help "init"
        fi
      else
        # Command help: dirforge init --help
        if declare -F show_command_help >/dev/null 2>&1; then
          show_command_help "init"
        else
          show_global_help
        fi
      fi
      ;;
    "--version"|"-v")
      echo "$PROG_NAME (DirForge Constitution $CONSTITUTION_VERSION)"
      echo "Enhanced Terminal Help System"
      ;;
    *)
      # Unknown command - show contextual help
      echo "Unknown command: $cmd" >&2
      echo >&2
      if declare -F show_global_help >/dev/null 2>&1; then
        echo "Available commands:" >&2
        show_global_help | grep -A5 "Usage" || usage
      else
        usage
      fi
      exit 1
      ;;
  esac
}

init_all_worlds() {
  # Create top-level directory structure with all world types
  local target_path="."
  local auto_create=false
  
  # Parse arguments
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --auto|--yes|-y)
        auto_create=true
        shift
        ;;
      --here)
        target_path="."
        shift
        ;;
      --path=*)
        target_path="${1#--path=}"
        shift
        ;;
      -*)
        echo "Unknown option: $1" >&2
        echo "Usage: $PROG_NAME init [path] [--auto|--yes|-y] [--here] [--path=PATH]" >&2
        exit 1
        ;;
      *)
        # First non-option argument is the target path
        target_path="$1"
        shift
        ;;
    esac
  done
  
  # Convert to absolute path and normalize
  if [[ "$target_path" == "." ]]; then
    target_path="$(pwd)"
  elif [[ "$target_path" != /* ]]; then
    target_path="$(pwd)/$target_path"
  fi
  
  echo "Initializing DirForge workspace at: $target_path"
  echo
  
  # Check if target directory exists and is not empty
  if [ -d "$target_path" ] && [ "$(ls -A "$target_path" 2>/dev/null | wc -l)" -gt 0 ]; then
    if [ "$auto_create" = false ] && [ "$YES" = false ] && [ "$FORCE" = false ]; then
      echo "WARNING: Directory '$target_path' exists and is not empty." >&2
      echo "Contents will be preserved, but new world directories will be created alongside existing files." >&2
      read -r -p "Continue with initialization? [y/N] " response
      case "$response" in
        [yY][eE][sS]|[yY]) 
          ;;
        *)
          echo "Initialization cancelled." >&2
          exit 1
          ;;
      esac
    fi
  fi
  
  # Create base directory if it doesn't exist
  do_mkdir_p "$target_path"
  
  # Define all world types and their standard directories
  local worlds=(
    "CODING_WORLD"
    "JOURNAL_WORLD" 
    "LECTURE_WORLD"
    "OFFICE_WORLD"
    "PRIVATE_WORLD"
    "RESEARCH_WORLD"
  )
  
  local coding_dirs=(
    "00_admin"
    "01_projects" 
    "90_archive"
  )
  
  local journal_dirs=(
    "00_admin"
    "01_daily"
    "02_weekly" 
    "03_monthly"
    "04_yearly"
    "90_archive"
  )
  
  local lecture_dirs=(
    "00_admin"
    "01_courses"
    "90_archive"
  )
  
  local office_dirs=(
    "00_admin"
    "01_finance"
    "04_inventory_equipment"
    "05_software_licenses"
    "06_public_relations"
    "90_archive"
  )
  
  local private_dirs=(
    "01_credentials"
    "02_id_contracts"
    "03_finance"
    "04_documents"
    "05_photos"
    "06_movies"
    "07_hiking"
    "09_installers"
    "90_archive"
  )
  
  local research_dirs=(
    "00_admin"
    "01_projects"
    "90_archive"
  )
  
  # Create world directories
  for world in "${worlds[@]}"; do
    local world_path="$target_path/$world"
    do_mkdir_p "$world_path"
    
    # Get the appropriate directories for this world
    local dirs_var="${world%_WORLD}_dirs[@]"
    dirs_var=$(echo "$dirs_var" | tr '[:upper:]' '[:lower:]')
    
    case "$world" in
      CODING_WORLD)
        for dir in "${coding_dirs[@]}"; do
          do_mkdir_p "$world_path/$dir"
        done
        ;;
      JOURNAL_WORLD)
        for dir in "${journal_dirs[@]}"; do
          do_mkdir_p "$world_path/$dir"
        done
        ;;
      LECTURE_WORLD)
        for dir in "${lecture_dirs[@]}"; do
          do_mkdir_p "$world_path/$dir"
        done
        ;;
      OFFICE_WORLD)
        for dir in "${office_dirs[@]}"; do
          do_mkdir_p "$world_path/$dir"
        done
        ;;
      PRIVATE_WORLD)
        for dir in "${private_dirs[@]}"; do
          do_mkdir_p "$world_path/$dir"
        done
        ;;
      RESEARCH_WORLD)
        for dir in "${research_dirs[@]}"; do
          do_mkdir_p "$world_path/$dir"
        done
        ;;
    esac
    
    if [ "$DRY_RUN" = false ]; then
      echo "✓ Created $world with standard directories"
    fi
  done
  
  if [ "$DRY_RUN" = true ]; then
    echo "DRY RUN: would create complete DirForge workspace at $target_path"
  else
    echo
    echo "✅ DirForge workspace initialized successfully at $target_path"
    echo
    echo "Created world directories:"
    for world in "${worlds[@]}"; do
      echo "  - $world/"
    done
    echo
    echo "You can now create specific projects in each world:"
    echo "  $PROG_NAME init research --title \"My Research Project\""
    echo "  $PROG_NAME init coding --project \"my-app\" --language python"
    echo "  $PROG_NAME init lecture --name \"My Course\""
  fi
}

suggest_world_help() {
  # Suggest valid world types for unknown world types
  local invalid_world="$1"
  local valid_worlds="research lecture coding journal office private"
  
  echo "Unknown world type: $invalid_world" >&2
  echo >&2
  echo "Valid world types:" >&2
  for world in $valid_worlds; do
    echo "  $world" >&2
  done
  echo >&2
  echo "For detailed help on a specific world type:" >&2
  echo "  $PROG_NAME init <world-type> --help" >&2
  echo >&2
  echo "Examples:" >&2
  echo "  $PROG_NAME init research --help" >&2
  echo "  $PROG_NAME init lecture --help" >&2
  echo >&2
  echo "To initialize a complete workspace with all worlds:" >&2
  echo "  $PROG_NAME init [path] [--auto]" >&2
}

usage() {
  cat <<EOF
Usage: 
  $PROG_NAME init <world> [options]        # Create specific world project
  $PROG_NAME init [path] [--auto]          # Initialize complete workspace with all worlds

World types: research, lecture, coding, journal, office, private

Global options:
  --dry-run, --preview    Preview changes without writing to filesystem
  --json                  Output machine-readable JSON plan (requires --dry-run)
  --force                 Overwrite existing projects without prompting
  --backup                Create timestamped backups before overwriting
  --yes, -y               Skip interactive prompts and proceed

Complete workspace initialization:
  path                    Target directory (default: current directory)
  --auto, --yes, -y       Create automatically without prompts
  --here                  Explicitly use current directory

Examples:
  # Initialize complete workspace
  $PROG_NAME init
  $PROG_NAME init /path/to/workspace --auto
  $PROG_NAME init ~/myworkspace
  
  # Create specific world projects
  $PROG_NAME init research --title "Thermal Model Analysis" --python 3.11
  $PROG_NAME init lecture --name "Digital Rock Physics"
  $PROG_NAME init coding --language python --project ml_toolkit
  
  # Preview changes
  $PROG_NAME --dry-run init ~/test-workspace
  $PROG_NAME --dry-run --json init research --title "Test" | jq .
EOF
}

output_json_plan() {
  # Output accumulated dry-run plan as JSON
  echo "{"
  echo '  "dry_run": true,'
  echo '  "directories": ['
  local first=true
  for dir in "${JSON_DIRS[@]}"; do
    if [ "$first" = false ]; then echo ","; fi
    printf '    "%s"' "$(json_escape "$dir")"
    first=false
  done
  echo ""
  echo '  ],'
  echo '  "files": ['
  first=true
  if [ "${#JSON_FILES[@]}" -gt 0 ]; then
    for file in "${JSON_FILES[@]}"; do
      if [ "$first" = false ]; then echo ","; fi
      printf '    "%s"' "$(json_escape "$file")"
      first=false
    done
  fi
  echo ""
  echo '  ]'
  echo "}"
}

main() {
  # Handle help and version flags first (before parsing other options)
  case "${1:-}" in
    --help|-h|help)
      handle_help_request
      exit 0
      ;;
    --version|-v|version)
      handle_help_request "--version"
      exit 0
      ;;
  esac

  # Global flags: support --dry-run or --preview anywhere in the args
  new_args=()
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --dry-run|--preview)
        DRY_RUN=true; shift;;
      --json)
        JSON_OUTPUT=true; shift;;
      --force)
        FORCE=true; shift;;
      --backup)
        BACKUP=true; shift;;
      --yes|-y)
        YES=true; shift;;
      --help|-h)
        # Context-aware help handling
        if [ "${#new_args[@]}" -gt 0 ]; then
          handle_help_request "${new_args[@]}"
        else
          handle_help_request
        fi
        exit 0
        ;;
      *) new_args+=("$1"); shift;;
    esac
  done
  
  # Validate JSON requires dry-run
  if [ "$JSON_OUTPUT" = true ] && [ "$DRY_RUN" = false ]; then
    echo "ERROR: --json requires --dry-run" >&2
    exit 1
  fi
  
  # Restore positional params
  set -- "${new_args[@]}"
  if [ "$#" -lt 1 ]; then
    handle_help_request
    exit 1
  fi
  
  cmd="$1"; shift
  case "$cmd" in
    init)
      # Check if there are any arguments
      if [ "$#" -eq 0 ]; then
        # No arguments - initialize complete workspace in current directory
        init_all_worlds "."
      else
        # Check if first argument is a help flag
        case "$1" in
          --help|-h)
            handle_help_request "init"
            exit 0
            ;;
          research|lecture|coding|journal|office|private)
            # Traditional world-specific init
            world="$1"
            shift
            
            case "$world" in
              research) init_research "$@" ;;
              lecture) init_lecture "$@" ;;
              coding) init_coding "$@" ;;
              journal) init_journal "$@" ;;
              office)
                echo "Creating OFFICE_WORLD standard folders..."
                for d in 00_admin 01_finance 04_inventory_equipment 05_software_licenses 06_public_relations 90_archive; do
                  do_mkdir_p "OFFICE_WORLD/$d"
                done
                if [ "$DRY_RUN" = true ]; then
                  echo "DRY RUN: would create OFFICE_WORLD/"
                else
                  echo "Created OFFICE_WORLD/"
                fi ;;
              private)
                echo "Creating PRIVATE_WORLD standard folders..."
                for d in 01_credentials 02_id_contracts 03_finance 04_documents 05_photos 06_movies 07_hiking 09_installers 90_archive; do
                  do_mkdir_p "PRIVATE_WORLD/$d"
                done
                if [ "$DRY_RUN" = true ]; then
                  echo "DRY RUN: would create PRIVATE_WORLD/"
                else
                  echo "Created PRIVATE_WORLD/"
                fi ;;
            esac
            ;;
          *)
            # Initialize complete workspace (all worlds) - could be path or flags
            init_all_worlds "$@"
            ;;
        esac
      fi
      
      # Output JSON plan if requested
      if [ "$JSON_OUTPUT" = true ]; then
        output_json_plan
      fi
    ;;
    *) 
      handle_help_request "$cmd"
      exit 1
      ;;
  esac
}

main "$@"
