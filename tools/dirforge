#!/usr/bin/env bash
set -euo pipefail

# Get the directory where this script is located (works for both symlinks and direct execution)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROG_NAME="$(basename "${BASH_SOURCE[0]}")"

# Set workspace root for world directories
# Use DIRFORGE_WORKSPACE_ROOT if set, otherwise try to detect from current location, or use current directory
if [[ -n "${DIRFORGE_WORKSPACE_ROOT:-}" ]]; then
    WORKSPACE_ROOT="$DIRFORGE_WORKSPACE_ROOT"
elif [[ -d "$HOME/Documents" ]]; then
    # Common default location
    WORKSPACE_ROOT="$HOME/Documents"
else
    # Fallback to current directory (legacy behavior)
    WORKSPACE_ROOT="$(pwd)"
fi

# Helper function to prompt user for world type when it cannot be detected
# Usage: prompt_for_world_type <target_dir>
prompt_for_world_type() {
  local target_dir="$1"
  
  echo "‚ö†Ô∏è  Could not automatically detect the world type for: $target_dir"
  echo
  echo "Please specify the world type for this project:"
  echo "  1) RESEARCH_WORLD   - Research projects with studies"
  echo "  2) JOURNAL_WORLD    - Journal with role-based structure"
  echo "  3) CODING_WORLD     - Programming and development projects"
  echo "  4) LECTURE_WORLD    - Course/lecture materials"
  echo "  5) OFFICE_WORLD     - Business and office management"
  echo "  6) PRIVATE_WORLD    - Personal and private documents"
  echo "  7) LITERATURE_WORLD - Books, articles, and literature"
  echo
  read -p "Enter choice (1-7): " choice
  
  case "$choice" in
    1) echo "RESEARCH_WORLD" ;;
    2) echo "JOURNAL_WORLD" ;;
    3) echo "CODING_WORLD" ;;
    4) echo "LECTURE_WORLD" ;;
    5) echo "OFFICE_WORLD" ;;
    6) echo "PRIVATE_WORLD" ;;
    7) echo "LITERATURE_WORLD" ;;
    *) 
      echo "Invalid choice. Defaulting to RESEARCH_WORLD."
      echo "RESEARCH_WORLD"
      ;;
  esac
}

# ============================================================================
# INTERNAL HELPER FUNCTIONS FOR cmd_update
# ============================================================================
# These functions reduce code duplication and improve maintainability

# Helper: Output update status message (consolidates JSON/text formatting)
# Usage: _output_update_status "message" <json_flag>
_output_update_status() {
  local message="$1"
  local json_mode="${2:-false}"
  
  if [[ "$json_mode" == true ]]; then
    # JSON mode: output is handled by parent function
    return 0
  else
    # Text mode: output formatted message
    echo "$message"
  fi
}

# Helper: Validate target directory exists and is accessible
# Usage: _validate_target_directory <path> <json_mode> <dry_run>
# Returns: 0 on success, 2 if doesn't exist, 3 if no write permission
_validate_target_directory() {
  local target_dir="$1"
  local json_mode="${2:-false}"
  local dry_run="${3:-false}"
  
  if [[ ! -d "$target_dir" ]]; then
    if [[ "$json_mode" == true ]]; then
      echo '{"ok":false,"error":"Target directory does not exist"}'
    else
      echo "‚ùå Error: Target directory '$target_dir' does not exist."
    fi
    return 2
  fi
  
  if [[ "$dry_run" != true && ! -w "$target_dir" ]]; then
    if [[ "$json_mode" == true ]]; then
      echo '{"ok":false,"error":"No write permission for target directory"}'
    else
      echo "‚ùå Error: No write permission for '$target_dir'."
    fi
    return 3
  fi
  
  return 0
}

# Helper: Safely source required libraries with error handling
# Usage: _source_required_libraries <lib_dir> <json_mode>
# Returns: 0 on success, 1 on failure
_source_required_libraries() {
  local lib_dir="$1"
  local json_mode="${2:-false}"
  local required_libs=("version_detect.sh" "migrate.sh" "integrity.sh" "user_input.sh")
  
  for lib in "${required_libs[@]}"; do
    if [[ ! -f "$lib_dir/$lib" ]]; then
      if [[ "$json_mode" == true ]]; then
        echo '{"ok":false,"error":"Missing required helper scripts"}'
      else
        echo "‚ùå Error: Required helper scripts not found in $lib_dir"
        echo "   Please ensure dirforge is properly installed."
      fi
      return 1
    fi
  done
  
  source "$lib_dir/version_detect.sh"
  source "$lib_dir/migrate.sh"
  source "$lib_dir/integrity.sh"
  source "$lib_dir/user_input.sh"
  return 0
}

# Helper: Clean detected values (remove embedded newlines from detection functions)
# Usage: _clean_detection_values <value>
# Returns: cleaned value with first line only
_clean_detection_values() {
  local value="$1"
  # Extract first line only (detection functions might have multi-line output)
  echo "${value%%$'\n'*}"
}

# Helper: Handle detection failure for a specific field
# Usage: _handle_detection_failure <field_name> <detected_value> <force_flag> <json_mode> <default_value>
# Outputs: cleaned value or default, updates parent scope variable
# Returns: 0 on success, error code if unrecoverable
_handle_detection_failure() {
  local field_name="$1"
  local detected_value="$2"
  local force_flag="$3"
  local json_mode="$4"
  local default_value="$5"
  
  # Check if value appears unknown
  if [[ "$detected_value" == *"unknown"* || "$detected_value" == "" ]]; then
    if [[ "$force_flag" == true ]]; then
      # --force flag: use default silently
      echo "$default_value"
      return 0
    elif [[ "$json_mode" == true ]]; then
      # JSON mode: cannot prompt, report error
      return 4
    else
      # Text mode: prompt user
      return 5
    fi
  fi
  
  # Value is valid, return cleaned version
  echo "$(_clean_detection_values "$detected_value")"
  return 0
}

# ============================================================================
# Update command: integrates version/world detection and migration logic
# Optimized for performance (<5s typical workspace)
cmd_update() {
  local target_dir="."
  local dry_run_flag="$DRY_RUN"
  local json_flag="$JSON_OUTPUT"
  local backup_flag="$BACKUP"
  local force_flag="${FORCE:-false}"
  local backup_path=""
  local start_time=$(date +%s.%N)
  
  # Parse args for --dry-run, --json, --backup, --here, --path= (also check global flags)
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help|-h)
        # Show help and exit
        if declare -F show_update_command_help >/dev/null 2>&1; then
          show_update_command_help
        else
          echo "dirforge update - Upgrade project structure to latest version"
          echo "Usage: dirforge update [path] [options]"
          echo "Options:"
          echo "  --help, -h         Show this help message"
          echo "  --dry-run          Preview changes without making modifications"
          echo "  --json             Output JSON summary"
          echo "  --backup           Create timestamped backup before updating"
          echo "  --force            Override version/world detection errors"
          echo "  --here             Use current directory"
          echo "  --path=PATH        Specify target directory"
        fi
        exit 0
        ;;
      --dry-run)
        dry_run_flag=true
        shift
        ;;
      --json)
        json_flag=true
        shift
        ;;
      --backup)
        backup_flag=true
        shift
        ;;
      --here)
        target_dir="."
        shift
        ;;
      --path=*)
        target_dir="${1#--path=}"
        shift
        ;;
      --force)
        # Force flag for version detection override
        force_flag=true
        shift
        ;;
      --*)
        # ignore other flags for now
        shift
        ;;
      *)
        # First non-option argument is the target path
        target_dir="$1"
        shift
        ;;
    esac
  done
  
  # Convert to absolute path and normalize (same as cmd_init)
  if [[ "$target_dir" == "." ]]; then
    target_dir="$(pwd)"
  elif [[ "$target_dir" != /* ]]; then
    target_dir="$(pwd)/$target_dir"
  fi
  
  # Source helpers with error handling
  _source_required_libraries "$LIB_DIR" "$json_flag" || return 1

  # Validate target directory exists and is accessible
  _validate_target_directory "$target_dir" "$json_flag" "$dry_run_flag" || return $?

  # Detect current version, world type, and organizational level
  local current_version world_type org_level
  current_version=$(detect_version "$target_dir" || echo "unknown")
  world_type=$(detect_world_type "$target_dir" || echo "unknown")
  org_level=$(detect_organizational_level "$target_dir" || echo "unknown")
  
  # If we're inside a project subdirectory (version is unknown), find the project root
  if [[ "$current_version" == "unknown" ]]; then
    local project_root=""
    project_root=$(find_project_root "$target_dir" || echo "")
    if [[ -n "$project_root" && "$project_root" != "$target_dir" ]]; then
      # We found a project root above this directory, use that instead
      target_dir="$project_root"
      current_version=$(detect_version "$target_dir" || echo "unknown")
      world_type=$(detect_world_type "$target_dir" || echo "unknown")
      org_level=$(detect_organizational_level "$target_dir" || echo "unknown")
    fi
  fi

  # Prompt user if version is still unknown (not in JSON mode)
  if [[ "$current_version" == "unknown" && "$json_flag" != true ]]; then
    current_version=$(prompt_for_version)
  fi

  # Prompt user if world type is still unknown (not in JSON mode)
  if [[ "$world_type" == "unknown" && "$json_flag" != true ]]; then
    world_type=$(prompt_for_world_type)
  fi

  # Check if this is a workspace-level directory or a world-level directory with projects
  local is_workspace_or_world=false
  if [[ "$current_version" == "unknown" && "$world_type" == "unknown" ]]; then
    # Check if this directory contains project directories (has subdirectories with .integrity/)
    local project_count=0
    for subdir in "$target_dir"/*/; do
      if [[ -d "$subdir/.integrity" ]] && [[ -f "$subdir/README.md" ]]; then
        ((project_count++))
      fi
    done
    
    # Also check if this is a workspace (contains world directories)
    local world_dirs=0
    for world_dir in "$target_dir"/RESEARCH_WORLD "$target_dir"/JOURNAL_WORLD "$target_dir"/CODING_WORLD "$target_dir"/LECTURE_WORLD "$target_dir"/OFFICE_WORLD "$target_dir"/PRIVATE_WORLD; do
      if [[ -d "$world_dir" ]]; then
        ((world_dirs++))
      fi
    done
    
    if [[ $project_count -gt 0 || $world_dirs -gt 0 ]]; then
      is_workspace_or_world=true
      if [[ "$json_flag" != true ]]; then
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        if [[ $world_dirs -gt 0 ]]; then
          echo "üìã DirForge Workspace Update"
        else
          echo "üìã DirForge World Update"
        fi
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "üîÑ Updating all projects..."
        echo
      fi
      
      # If this is a workspace (contains world directories), recurse into worlds first
      if [[ $world_dirs -gt 0 ]]; then
        for world_dir in "$target_dir"/RESEARCH_WORLD "$target_dir"/JOURNAL_WORLD "$target_dir"/CODING_WORLD "$target_dir"/LECTURE_WORLD "$target_dir"/OFFICE_WORLD "$target_dir"/PRIVATE_WORLD "$target_dir"/LITERATURE_WORLD; do
          if [[ -d "$world_dir" ]]; then
            local world_name=$(basename "$world_dir")
            
            # Check if we can traverse the world directory
            if ! test_permissions "$world_dir" "traverse"; then
              if [[ "$json_flag" != true ]]; then
                echo "  ‚ö†Ô∏è  Skipping $world_name: Permission denied"
              fi
              continue
            fi
            
            # Recursively update each world with error handling
            for project_dir in "$world_dir"/*/; do
              if [[ -d "$project_dir" ]]; then
                local project_name=$(basename "$project_dir")
                
                # Check project directory accessibility
                if ! test_permissions "$project_dir" "read"; then
                  if [[ "$json_flag" != true ]]; then
                    echo "  ‚ö†Ô∏è  Skipping $world_name/$project_name: Read permission denied"
                  fi
                  continue
                fi
                
                if [[ "$json_flag" != true ]]; then
                  echo "  üåç $world_name/$project_name"
                fi
                
                # Call recursive update with error handling
                local update_result
                if [[ "$dry_run_flag" == true ]]; then
                  update_result=$(cmd_update "$project_dir" --dry-run 2>&1)
                  local update_exit=$?
                else
                  update_result=$(cmd_update "$project_dir" 2>&1)
                  local update_exit=$?
                fi
                
                # Handle recursive update errors
                if [[ $update_exit -ne 0 ]] && [[ "$json_flag" != true ]]; then
                  echo "  ‚ùå Failed to update $world_name/$project_name: $update_result"
                fi
              fi
            done
          fi
        done
      else
        # This is a world directory (like RESEARCH_WORLD) - update all projects in it
        for project_dir in "$target_dir"/*/; do
          if [[ -d "$project_dir/.integrity" ]]; then
            local project_name=$(basename "$project_dir")
            if [[ "$json_flag" != true ]]; then
              echo "  üìÅ $project_name"
            fi
            
            if [[ "$dry_run_flag" == true ]]; then
              cmd_update "$project_dir" --dry-run
            else
              cmd_update "$project_dir"
            fi
          fi
        done
      fi
      
      if [[ "$json_flag" != true ]]; then
        echo
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        echo "‚úÖ Update complete."
        echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      fi
      return 0
    fi
  fi

  # Target version is always the latest (v1.0.22 with .integrity system)
  local target_version="1.0.22"

  # Handle detection failures with consistent error handling
  # Pattern matching handles "unknown" with or without trailing newlines from detection functions
  
  # Clean detection values first to handle multi-line output from detection functions
  current_version="$(_clean_detection_values "$current_version")"
  world_type="$(_clean_detection_values "$world_type")"
  org_level="$(_clean_detection_values "$org_level")"

  # Handle version detection failure
  if [[ "$current_version" == "unknown" || "$current_version" == "" ]]; then
    current_version="$target_version"  # Default to latest for legacy projects
  fi
  
  # Handle world type detection failure
  if [[ "$world_type" == "unknown" || "$world_type" == "" ]]; then
    if [[ "$force_flag" == true ]]; then
      world_type="RESEARCH_WORLD"
      [[ "$json_flag" != true ]] && echo "‚ö†Ô∏è  Warning: World type detection failed, --force used. Defaulting to RESEARCH_WORLD"
    elif [[ "$json_flag" == true ]]; then
      echo '{"ok":false,"error":"Could not detect world type. Use --force to default to RESEARCH_WORLD"}'
      return 4
    else
      # Interactive: ask the user
      world_type=$(prompt_for_world_type "$target_dir")
    fi
  fi
  
  # Handle organizational level detection failure
  if [[ "$org_level" == "unknown" || "$org_level" == "" ]]; then
    if [[ "$force_flag" == true ]]; then
      org_level="project"
      [[ "$json_flag" != true ]] && echo "‚ö†Ô∏è  Warning: Organizational level detection failed, --force used. Assuming project level"
    fi
  fi

  if [[ "$json_flag" == true ]]; then
    printf "{\"ok\":true,\"current_version\":\"$current_version\",\"target_version\":\"$target_version\",\"world_type\":\"$world_type\",\"org_level\":\"$org_level\",\"dry_run\":$dry_run_flag,\"backup\":$backup_flag" > "$target_dir/.dirforge_update_tmp.json"
  else
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo "üìã DirForge Structure Update"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo "Current version: $current_version"
    echo "Target version:  $target_version"
    echo "World type:      $world_type"
    if [[ "$dry_run_flag" == true ]]; then
      echo "Mode:            DRY RUN (preview only)"
      echo "  - No changes will be made."
      echo "  - You will see a preview of what would be created."
    fi
    if [[ "$backup_flag" == true ]]; then
      echo "Backup:          ENABLED"
      echo "  - A full backup of the target directory will be created before any changes."
      echo "  - Use \"--restore <backup_path>\" to revert if needed."
    fi
    echo
  fi

  # Only run migration if not already up to date
  # BUT: Always check for legacy metadata that needs migration (even if version matches)
  # AND: Always check if study needs integrity metadata creation
  local needs_legacy_migration=false
  if has_legacy_project_yaml "$target_dir"; then
    needs_legacy_migration=true
  fi
  
  local needs_study_metadata=false
  if [[ "$org_level" == "study" && ! -f "$target_dir/.integrity/study.yaml" ]]; then
    needs_study_metadata=true
  fi
  
  if [[ "$current_version" == "$target_version" && "$needs_legacy_migration" == false && "$needs_study_metadata" == false ]]; then
    if [[ "$json_flag" == true ]]; then
      echo ',"already_up_to_date":true,"changes":[]}' >> "$target_dir/.dirforge_update_tmp.json"
      cat "$target_dir/.dirforge_update_tmp.json"
      rm -f "$target_dir/.dirforge_update_tmp.json"
    else
      echo "‚úÖ Structure already up to date. No changes needed."
    fi
    return 0
  fi

  # Extract entity_name early - needed for study metadata creation
  local entity_name="unknown"
  if [[ "$org_level" == "study" ]]; then
    # For studies, use the directory name as the entity name
    entity_name=$(basename "$target_dir")
  elif [[ -f "$target_dir/project.yaml" ]]; then
    entity_name=$(grep -E '^name:' "$target_dir/project.yaml" | head -n1 | awk '{print $2}' | tr -d '"' 2>/dev/null || echo "unknown")
  fi

  # Create study metadata if needed (do this for all studies, regardless of version)
  if [[ "$org_level" == "study" && ! -f "$target_dir/.integrity/study.yaml" ]]; then
    if [[ -d "$target_dir/.integrity" ]]; then
      if create_study_integrity_metadata "$target_dir" "$entity_name" "$target_version"; then
        if [[ "$json_flag" != true ]]; then
          echo "‚úì Study-level .integrity metadata created for $entity_name"
        fi
      fi
    fi
  fi

  # Validate structure before update
  if [[ "$json_flag" != true ]]; then
    echo "üîé Validating structure before update..."
    # (Placeholder for future: call structure validation helpers)
  fi

  # Handle legacy metadata migration (even if version is current)
  if [[ "$needs_legacy_migration" == true ]]; then
    if [[ "$json_flag" != true ]]; then
      echo "üì¶ Migrating legacy project.yaml to .integrity structure..."
    fi
    
    if [[ "$dry_run_flag" != true ]]; then
      migrate_legacy_project_yaml "$target_dir" "$target_version"
    fi
  fi

  # Call migration engine (additive-only) if version mismatch
  if [[ "$current_version" != "$target_version" ]]; then
    if [[ "$backup_flag" == true && "$dry_run_flag" != true ]]; then
    local ts
    ts=$(date +%Y%m%d-%H%M%S)
    
    # Enhanced backup creation with error handling
    local backup_dir="$target_dir/.integrity/backup"
    backup_path="$backup_dir/backup_$ts"
    
    # Ensure backup directory exists and is writable
    if ! mkdir -p "$backup_dir" 2>/dev/null; then
      show_backup_error "$target_dir" "$backup_dir" "Cannot create backup directory" "$json_flag"
      return 17
    fi
    
    # Check disk space for backup
    local backup_space_mb
    backup_space_mb=$(du -sm "$target_dir" 2>/dev/null | awk '{print $1}' || echo "100")
    local backup_space_check
    backup_space_check=$(check_disk_space "$backup_dir" "$backup_space_mb")
    local backup_space_exit=$?
    
    if [[ $backup_space_exit -eq 1 ]]; then
      show_disk_space_error "$backup_dir" "$backup_space_mb" "$backup_space_check" "$json_flag"
      return 18
    fi
    
    # Create backup with error handling
    if ! cp -a "$target_dir" "$backup_path" 2>/dev/null; then
      local cp_error
      cp_error=$(cp -a "$target_dir" "$backup_path" 2>&1 || echo "Copy operation failed")
      show_backup_error "$target_dir" "$backup_path" "$cp_error" "$json_flag"
      return 19
    fi
    
    if [[ "$json_flag" == true ]]; then
      printf ",\"backup_path\":\"$backup_path\"" >> "$target_dir/.dirforge_update_tmp.json"
    else
      echo "üì¶ Backup created at: $backup_path"
    fi
  elif [[ "$json_flag" == true ]]; then
    printf ",\"backup_path\":null" >> "$target_dir/.dirforge_update_tmp.json"
  fi

  if [[ "$json_flag" == true ]]; then
    # Capture migration changes as JSON array
    local changes_json
    if [[ "$dry_run_flag" == true ]]; then
      changes_json=$(migrate_additive "$target_dir" "$world_type" "$current_version" "$target_version" 1 | awk '{print "\""$0"\""}' | paste -sd, -)
      echo ",\"already_up_to_date\":false,\"changes\":[${changes_json}]}" >> "$target_dir/.dirforge_update_tmp.json"
      cat "$target_dir/.dirforge_update_tmp.json"
      rm -f "$target_dir/.dirforge_update_tmp.json"
      return 0
    else
      changes_json=$(migrate_additive "$target_dir" "$world_type" "$current_version" "$target_version" 0 | awk '{print "\""$0"\""}' | paste -sd, -)
      # Validate structure after update
      local new_version
      new_version=$(detect_version "$target_dir")
      local update_ok=false
      if [[ "$new_version" == "$target_version" ]]; then
        update_ok=true
      fi
      echo ",\"already_up_to_date\":false,\"changes\":[${changes_json}],\"update_ok\":$update_ok,\"new_version\":\"$new_version\"}" >> "$target_dir/.dirforge_update_tmp.json"
      cat "$target_dir/.dirforge_update_tmp.json"
      rm -f "$target_dir/.dirforge_update_tmp.json"
      return 0
    fi
  else
    echo "üõ†Ô∏è  Applying additive migration steps:"
    if [[ "$dry_run_flag" == true ]]; then
      migrate_additive "$target_dir" "$world_type" "$current_version" "$target_version" 1
      
      # Check for nested projects even in dry-run mode (T019)
      local subproject_paths=()
      local temp_file="/tmp/dirforge_nested_$$"
      find "$target_dir" -mindepth 2 -maxdepth 4 -name "project.yaml" 2>/dev/null > "$temp_file" || true
      
      if [[ -s "$temp_file" ]]; then
        while IFS= read -r project_file; do
          if [[ -n "$project_file" && -f "$project_file" ]]; then
            local subdir
            subdir=$(dirname "$project_file")
            subproject_paths+=("$subdir")
          fi
        done < "$temp_file"
      fi
      rm -f "$temp_file"

      if [[ ${#subproject_paths[@]} -gt 0 ]]; then
        if [[ "$json_flag" != true ]]; then
          echo
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üîÑ Found nested subprojects:"
          for sp in "${subproject_paths[@]}"; do
            echo "  - $sp"
          done
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        fi
      fi
      
      echo
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo "DRY RUN: No changes were made."
      echo "To perform the update, run again without --dry-run."
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo
      return 0
    fi
    if ! migrate_additive "$target_dir" "$world_type" "$current_version" "$target_version" 0; then
      # Enhanced migration error handling
      local migration_step="migration from $current_version to $target_version"
      local error_details="Migration function returned non-zero exit code"
      
      # Check if it's a permission issue
      if ! test_permissions "$target_dir" "write"; then
        error_details="Permission denied - cannot write to target directory"
      elif ! check_disk_space "$target_dir" "50" >/dev/null; then
        error_details="Insufficient disk space for migration"
      else
        # Check for corrupted files that may have caused migration failure
        for yaml_file in "$target_dir/project.yaml" "$target_dir/.integrity/project.yaml"; do
          if [[ -f "$yaml_file" ]] && ! validate_yaml_file "$yaml_file" 2>/dev/null; then
            error_details="Corrupted YAML file detected: $yaml_file"
            break
          fi
        done
      fi
      
      show_migration_error "$migration_step" "$current_version" "$target_version" "$error_details" "$json_flag"
      return 5
    fi
    
    # Create .integrity directory structure (v1.0.22) based on organizational level
    if ! has_integrity_structure "$target_dir" 2>/dev/null; then
      if [[ "$json_flag" != true ]]; then
        echo "üìÅ Creating .integrity directory structure ($org_level level)..."
      fi
      
      case "$org_level" in
        world)
          # World-level integrity - mkdir is done in create_world_integrity_metadata
          if create_world_integrity_metadata "$target_dir" "$world_type" "$target_version"; then
            if [[ "$json_flag" != true ]]; then
              echo "‚úì World-level .integrity created for $world_type"
            fi
          fi
          ;;
        study)
          # Study-level integrity - mkdir is done in create_study_integrity_metadata
          if create_study_integrity_metadata "$target_dir" "$entity_name" "$target_version"; then
            if [[ "$json_flag" != true ]]; then
              echo "‚úì Study-level .integrity created for $entity_name"
            fi
          fi
          ;;
        *)
          # Project-level (default)
          if ! create_integrity_structure "$target_dir" "$world_type"; then
            if [[ "$json_flag" != true ]]; then
              echo "‚ö†Ô∏è  Warning: Could not create .integrity directory (may be write-protected)"
            fi
          fi
          ;;
      esac
    else
      # Structure already exists (e.g., from migration), but metadata files might not
      # Create metadata files if they don't exist
      case "$org_level" in
        world)
          if [[ ! -f "$target_dir/.integrity/world.yaml" ]]; then
            if create_world_integrity_metadata "$target_dir" "$world_type" "$target_version"; then
              if [[ "$json_flag" != true ]]; then
                echo "‚úì World-level .integrity metadata created for $world_type"
              fi
            fi
          fi
          ;;
        study)
          if [[ ! -f "$target_dir/.integrity/study.yaml" ]]; then
            if create_study_integrity_metadata "$target_dir" "$entity_name" "$target_version"; then
              if [[ "$json_flag" != true ]]; then
                echo "‚úì Study-level .integrity metadata created for $entity_name"
              fi
            fi
          fi
          ;;
        *)
          # Project-level: metadata created by create_integrity_structure, no action needed
          ;;
      esac
    fi
    
    # Migrate legacy project.yaml to .integrity/project.yaml (FR-012: migrate and remove original)
    # Only for project level (not for world or study)
    if [[ "$org_level" == "project" && -f "$target_dir/project.yaml" && -d "$target_dir/.integrity" ]]; then
      if [[ "$json_flag" != true ]]; then
        echo "üîÑ Migrating legacy metadata to .integrity system..."
      fi
      if migrate_legacy_project_yaml "$target_dir" "$target_version"; then
        if [[ "$json_flag" != true ]]; then
          echo "‚úì Legacy metadata migrated to .integrity/"
        fi
      fi
    fi
    
    # Update version in .integrity/*.yaml files to v1.0.22 (FR-011: always update version)
    if [[ -d "$target_dir/.integrity" ]]; then
      if [[ "$json_flag" != true ]]; then
        echo "üìù Updating version tracking in .integrity metadata..."
      fi
      
      case "$org_level" in
        world)
          if update_world_integrity_version "$target_dir" "$target_version"; then
            if [[ "$json_flag" != true ]]; then
              echo "‚úì World version updated to $target_version"
            fi
          fi
          ;;
        study)
          if update_study_integrity_version "$target_dir" "$target_version"; then
            if [[ "$json_flag" != true ]]; then
              echo "‚úì Study version updated to $target_version"
            fi
          fi
          ;;
        *)
          # Project level
          if update_integrity_version "$target_dir" "$target_version"; then
            if [[ "$json_flag" != true ]]; then
              echo "‚úì Version updated to $target_version in .integrity files"
            fi
          fi
          ;;
      esac
    fi
    
    # Update version in project.yaml if migration was successful
    if [[ -f "$target_dir/project.yaml" ]]; then
      # Update the version line in project.yaml
      if grep -q "^version:" "$target_dir/project.yaml"; then
        if [[ "$(uname)" == "Darwin" ]]; then
          sed -i '' "s/^version:.*/version: $target_version/" "$target_dir/project.yaml"
        else
          sed -i "s/^version:.*/version: $target_version/" "$target_dir/project.yaml"
        fi
      else
        # Add version line if it doesn't exist
        echo "version: $target_version" >> "$target_dir/project.yaml"
      fi
    fi
  fi
  
  fi  # Close: if [[ "$current_version" != "$target_version" ]]; then
  
  # Handle legacy metadata migration when version matches but legacy files exist
  if [[ "$current_version" == "$target_version" && "$needs_legacy_migration" == true ]]; then
    if [[ "$json_flag" != true ]]; then
      echo "üõ†Ô∏è  Applying legacy metadata migration (no version upgrade needed):"
    fi
    
    if [[ "$dry_run_flag" == true ]]; then
      echo
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo "DRY RUN: No changes were made."
      echo "To perform the update, run again without --dry-run."
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo
      return 0
    fi
    
    if [[ "$json_flag" != true ]]; then
      echo "‚úÖ Update successful. Legacy metadata migrated to .integrity."
    fi
  fi

  # Recursively update all nested child structures (studies in projects)
  if [[ "$org_level" == "project" ]]; then
    local studies_dir="$target_dir/02_studies"
    if [[ -d "$studies_dir" ]]; then
      if [[ "$json_flag" != true ]]; then
        echo
        echo "üîÑ Updating nested studies..."
      fi
      
      # Find all study directories with error handling
      for study_dir in "$studies_dir"/*/; do
        if [[ -d "$study_dir" ]]; then
          local study_name=$(basename "$study_dir")
          
          # Check study directory accessibility
          if ! test_permissions "$study_dir" "read"; then
            if [[ "$json_flag" != true ]]; then
              echo "  ‚ö†Ô∏è  Skipping study $study_name: Read permission denied"
            fi
            continue
          fi
          
          if [[ "$json_flag" != true ]]; then
            echo "  üìö Updating study: $study_name"
          fi
          
          # Recursively call update on the study with error handling
          local study_update_result
          if [[ "$dry_run_flag" == true ]]; then
            study_update_result=$(cmd_update "$study_dir" --dry-run 2>&1)
            local study_exit=$?
          else
            study_update_result=$(cmd_update "$study_dir" 2>&1)
            local study_exit=$?
          fi
          
          # Handle study update errors
          if [[ $study_exit -ne 0 ]] && [[ "$json_flag" != true ]]; then
            echo "  ‚ùå Failed to update study $study_name: $study_update_result"
          fi
        fi
      done
    fi
  fi

  # Validate structure after update (already handled in JSON mode above)
  if [[ "$json_flag" != true ]]; then
    local new_version
    new_version=$(detect_version "$target_dir")
    if [[ "$new_version" == "$target_version" ]]; then
      echo
      echo "‚úÖ Update successful. Structure is now at $target_version."
    else
      echo
      echo "‚ö†Ô∏è  Warning: Structure may not be fully updated. Detected version: $new_version"
    fi
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  fi

  # Manual migration warning for world types/versions not fully supported
  local manual_migration_needed=false
  
  # Check if this is an unsupported combination (invert the logic)
  if [[ "$world_type" != "RESEARCH_WORLD" && "$world_type" != "JOURNAL_WORLD" && "$world_type" != "OFFICE_WORLD" ]]; then
    manual_migration_needed=true
  elif [[ "$world_type" == "RESEARCH_WORLD" && "$current_version" != "1.0.16" ]]; then
    manual_migration_needed=true
  elif [[ "$world_type" == "JOURNAL_WORLD" && "$current_version" != "1.0.20" ]]; then
    manual_migration_needed=true
  elif [[ "$world_type" == "OFFICE_WORLD" && "$current_version" != "1.0.10" ]]; then
    manual_migration_needed=true
  fi

  if [[ "$manual_migration_needed" == true && "$json_flag" != true ]]; then
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo "‚ö†Ô∏è  Warning: Structure may not be fully updated. Detected version: $current_version"
    echo "Manual migration steps may be required for $world_type from $current_version to $target_version."
    echo "Please consult the migration guide in docs/ for detailed instructions."
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo
  fi

  # Performance timing (optional)
  if [[ "$json_flag" != true && "$dry_run_flag" != true ]]; then
    local end_time=$(date +%s.%N)
    local duration=$(echo "$end_time - $start_time" | bc -l 2>/dev/null || echo "N/A")
    if [[ "$duration" != "N/A" ]]; then
      echo "‚è±Ô∏è  Update completed in ${duration}s"
    fi
    echo
  fi
}


# dirforge main dispatch and initialization

# Detect library directory (development vs installed)
if [ -d "$SCRIPT_DIR/../lib" ]; then
    # Development mode - script is in tools/, libraries in lib/
    LIB_DIR="$(cd "$SCRIPT_DIR/../lib" && pwd)"
elif [ -d "$HOME/.local/lib/dirforge" ]; then
    # Local installation mode  
    LIB_DIR="$HOME/.local/lib/dirforge"
elif [ -d "/usr/local/lib/dirforge" ]; then
    # System installation mode
    LIB_DIR="/usr/local/lib/dirforge"
else
    # Fallback - try relative path anyway
    LIB_DIR="$SCRIPT_DIR/../lib"
fi

# Detect templates directory (development vs installed)
if [ -d "$SCRIPT_DIR/../templates" ]; then
    # Development mode - templates in templates/
    TEMPLATES_DIR="$(cd "$SCRIPT_DIR/../templates" && pwd)"
elif [ -d "$HOME/.local/lib/dirforge/templates" ]; then
    # Local installation mode
    TEMPLATES_DIR="$HOME/.local/lib/dirforge/templates"
elif [ -d "/usr/local/lib/dirforge/templates" ]; then
    # System installation mode
    TEMPLATES_DIR="/usr/local/lib/dirforge/templates"
else
    # Fallback
    TEMPLATES_DIR="$SCRIPT_DIR/../templates"
fi

# Source help system libraries if available
if [ -f "$LIB_DIR/terminal.sh" ]; then
    source "$LIB_DIR/terminal.sh"
fi
if [ -f "$LIB_DIR/colors.sh" ]; then
    source "$LIB_DIR/colors.sh"
    init_colors 2>/dev/null || true
fi
if [ -f "$LIB_DIR/help.sh" ]; then
    source "$LIB_DIR/help.sh"
fi
if [ -f "$LIB_DIR/error.sh" ]; then
    source "$LIB_DIR/error.sh"
fi
if [ -f "$LIB_DIR/integrity.sh" ]; then
    source "$LIB_DIR/integrity.sh"
fi
if [ -f "$LIB_DIR/help_yaml_parser.sh" ]; then
    source "$LIB_DIR/help_yaml_parser.sh"
fi

CONSTITUTION_VERSION="v1.0.21"

# Dry-run flag (preview mode). When true, filesystem changes are not written; actions are printed.
DRY_RUN=false
# JSON output flag. When true with DRY_RUN, output machine-readable JSON plan.
JSON_OUTPUT=false
# Force flag. When true, overwrite existing projects without prompting.
FORCE=false
# Backup flag. When true, create timestamped backups before overwriting.
BACKUP=false
# Yes flag. When true, skip interactive prompts and proceed.
YES=false

# JSON plan accumulator (used when JSON_OUTPUT=true)
JSON_DIRS=()
JSON_FILES=()

json_escape() {
  # Escape string for JSON (basic escaping, remove trailing newline)
  printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g'
}

do_mkdir_p() {
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = true ]; then
      for dir in "$@"; do
        JSON_DIRS+=("$dir")
      done
    else
      echo "DRY RUN: mkdir -p $*"
    fi
  else
    mkdir -p "$@"
  fi
}

write_file() {
  # usage: write_file <dest> <<'EOF'...EOF
  local dest="$1"
  shift
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = true ]; then
      # Capture file content for JSON
      local content
      content=$(cat)
      JSON_FILES+=("$dest")
    else
      echo "DRY RUN: would write file: $dest"
      # print a snippet of the content for visibility
      awk '{ if (NR<=20) print "    " $0 }' || true
      # consume stdin
      cat >/dev/null
    fi
  else
    mkdir -p "$(dirname "$dest")"
    cat > "$dest"
  fi
}

render_template() {
  # usage: render_template <template_file> <dest> [VAR=value ...]
  local template_file="$1"
  local dest="$2"
  shift 2
  # Verify template exists
  if [ ! -f "$template_file" ]; then
    show_template_not_found_error "$template_file"
    return 1
  fi

  local content
  content=$(cat "$template_file")
  for var in "$@"; do
    local name="${var%%=*}"
    local value="${var#*=}"
    # Escape backslashes, pipes and ampersands for safe sed substitution
    local esc
    esc=$(printf '%s' "$value" | sed -e 's/\\/\\\\/g' -e 's/|/\\|/g' -e 's/&/\\&/g')
    content=$(printf "%s" "$content" | sed "s|{{${name}}}|${esc}|g")
  done
  write_file "$dest" <<< "$content"
}

to_snake_case() {
  # Convert a string to lower_snake_case: transliterate, lowercase, replace non-alnum with _, trim
  local s="$*"
  # Use iconv if available for transliteration, else rely on sed
  if command -v iconv >/dev/null 2>&1; then
    s=$(printf "%s" "$s" | iconv -f utf8 -t ascii//TRANSLIT 2>/dev/null)
  fi
  printf "%s" "$s" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9_-]+/_/g' | sed -E 's/^_+|_+$//g'
}

strip_year_prefix() {
  local id="$1"
  echo "$id" | sed -E 's/^[0-9]{4}_//'
}

backup_directory() {
  local src="$1"
  local timestamp
  timestamp=$(date +%Y%m%d-%H%M%S)
  local backup_dir="${src}.backup-${timestamp}"
  
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create backup: $backup_dir"
    fi
  else
    cp -R "$src" "$backup_dir"
    echo "Created backup: $backup_dir"
  fi
}

prompt_overwrite() {
  local project_path="$1"
  
  # Skip prompt if --yes or --force is set
  if [ "$YES" = true ] || [ "$FORCE" = true ]; then
    return 0
  fi
  
  echo "WARNING: Project already exists at $project_path" >&2
  if [ "$BACKUP" = true ]; then
    echo "A backup will be created before overwriting." >&2
  fi
  read -r -p "Overwrite existing project? [y/N] " response
  case "$response" in
    [yY][eE][sS]|[yY]) 
      return 0
      ;;
    *)
      echo "Operation cancelled." >&2
      exit 1
      ;;
  esac
}

conda_env_exists() {
  local name="$1"
  if ! command -v conda >/dev/null 2>&1; then
    return 1
  fi
  conda info --envs 2>/dev/null | awk '{print $1}' | grep -xq "$name" || return 1
}

# Detect if init is in parent-only mode for a world-type
# Returns 0 (true) if only <world-type> is given, no project/study flags
# Usage: is_parent_only_mode <world-type> <args>
is_parent_only_mode() {
  local world_type="$1"; shift
  # If no args, parent-only mode
  if [ "$#" -eq 0 ]; then
    return 0
  fi
  # For research: must NOT have --name, --project, --study
  case "$world_type" in
    research)
      for arg in "$@"; do
        case "$arg" in
          --name|--project|--study|-n|-p|-s)
            return 1
            ;;
        esac
      done
      return 0
      ;;
    journal)
      # For journal, must NOT have project-specific flags
      for arg in "$@"; do
        case "$arg" in
          --name|--id|--first|--coauthor|--service|--year|-n|-i|-f|-c|-s|-y)
            return 1
            ;;
        esac
      done
      return 0
      ;;
    lecture)
      # For lecture, must NOT have --name, --term, --code
      for arg in "$@"; do
        case "$arg" in
          --name|--term|--code|-n)
            return 1
            ;;
        esac
      done
      return 0
      ;;
    coding)
      # For coding, must NOT have --language, --project, --name
      for arg in "$@"; do
        case "$arg" in
          --language|--project|--name|-l|-p|-n)
            return 1
            ;;
        esac
      done
      return 0
      ;;
    office|private)
      # Office and private always create standard structure (no project-specific flags)
      # Any flags would be invalid for these world types
      return 0
      ;;
    *)
      # Default: parent-only if no --name/-n
      for arg in "$@"; do
        case "$arg" in
          --name|-n)
            return 1
            ;;
        esac
      done
      return 0
      ;;
  esac
}

# Create only the parent directory for a given world-type (no subfolders, no prompts)
# Usage: create_world_parent <world-type>
create_world_parent() {
  local world_type="$1"
  case "$world_type" in
    research)
      do_mkdir_p "RESEARCH_WORLD"
      if [ "$DRY_RUN" = true ]; then
        if [ "$JSON_OUTPUT" = false ]; then
          echo "DRY RUN: would create parent directory: RESEARCH_WORLD"
        fi
      else
        echo "Created parent directory: RESEARCH_WORLD"
      fi
      ;;
    journal)
      do_mkdir_p "JOURNAL_WORLD"
      if [ "$DRY_RUN" = true ]; then
        if [ "$JSON_OUTPUT" = false ]; then
          echo "DRY RUN: would create parent directory: JOURNAL_WORLD"
        fi
      else
        echo "Created parent directory: JOURNAL_WORLD"
      fi
      ;;
    lecture)
      do_mkdir_p "LECTURE_WORLD"
      if [ "$DRY_RUN" = true ]; then
        if [ "$JSON_OUTPUT" = false ]; then
          echo "DRY RUN: would create parent directory: LECTURE_WORLD"
        fi
      else
        echo "Created parent directory: LECTURE_WORLD"
      fi
      ;;
    coding)
      do_mkdir_p "CODING_WORLD"
      if [ "$DRY_RUN" = true ]; then
        if [ "$JSON_OUTPUT" = false ]; then
          echo "DRY RUN: would create parent directory: CODING_WORLD"
        fi
      else
        echo "Created parent directory: CODING_WORLD"
      fi
      ;;
    office)
      # Office creates standard structure even in parent-only mode
      echo "Creating OFFICE_WORLD standard folders..."
      if [ ! -d "$WORKSPACE_ROOT/OFFICE_WORLD" ]; then
        echo "Created parent directory: $WORKSPACE_ROOT/OFFICE_WORLD"
      fi
      for d in 00_admin 01_finance 02_hr_administration 03_faculty 04_inventory_equipment 05_software_licenses 06_public_relations; do
        do_mkdir_p "$WORKSPACE_ROOT/OFFICE_WORLD/$d"
      done
      if [ "$DRY_RUN" = true ]; then
        if [ "$JSON_OUTPUT" = false ]; then
          echo "DRY RUN: would create OFFICE_WORLD/"
        fi
      else
        echo "Created OFFICE_WORLD/"
      fi
      ;;
    private)
      # Private creates standard structure even in parent-only mode
      echo "Creating PRIVATE_WORLD standard folders..."
      if [ ! -d "$WORKSPACE_ROOT/PRIVATE_WORLD" ]; then
        echo "Created parent directory: $WORKSPACE_ROOT/PRIVATE_WORLD"
      fi
      for d in 00_admin 01_credentials 02_id_contracts 03_finance 04_documents 05_photos 06_movies 07_hiking 09_installers 90_archive; do
        do_mkdir_p "$WORKSPACE_ROOT/PRIVATE_WORLD/$d"
      done
      if [ "$DRY_RUN" = true ]; then
        if [ "$JSON_OUTPUT" = false ]; then
          echo "DRY RUN: would create PRIVATE_WORLD/"
        fi
      else
        echo "Created PRIVATE_WORLD/"
      fi
      ;;
    *)
      echo "Unknown world type: $world_type" >&2
      return 1
      ;;
  esac
}

# Detect if current directory is within a JOURNAL_WORLD structure
# Returns 0 (true) if current or any parent directory contains JOURNAL_WORLD
# Usage: is_in_journal_world
is_in_journal_world() {
  local current_dir
  current_dir="$(pwd)"
  
  # Walk up the directory tree looking for JOURNAL_WORLD
  while [ "$current_dir" != "/" ]; do
    # Check if current directory IS JOURNAL_WORLD
    if [ "$(basename "$current_dir")" = "JOURNAL_WORLD" ]; then
      return 0
    fi
    
    # Check if current directory contains JOURNAL_WORLD
    if [ -d "$current_dir/JOURNAL_WORLD" ]; then
      return 0
    fi
    
    # Move up one directory
    current_dir="$(dirname "$current_dir")"
  done
  
  # Not found
  return 1
}

# Validate role-based directory structure requirements
# Returns 0 if valid, 1 if invalid (with error messages to stderr)
# Usage: validate_journal_structure
validate_journal_structure() {
  # Check if we're in or have access to JOURNAL_WORLD
  if ! is_in_journal_world; then
    echo "Error: Not in JOURNAL_WORLD structure. Run 'dirforge init journal' first." >&2
    return 1
  fi
  
  # Find JOURNAL_WORLD root
  local journal_root
  journal_root="$(find_journal_world_root)"
  if [ -z "$journal_root" ]; then
    echo "Error: Could not locate JOURNAL_WORLD root directory." >&2
    return 1
  fi
  
  # Validate role directories exist
  local expected_roles=("00_admin" "01_primary_authorship" "02_coauthor_invites" "03_journal_service")
  local missing_roles=()
  
  for role in "${expected_roles[@]}"; do
    if [ ! -d "$journal_root/$role" ]; then
      missing_roles+=("$role")
    fi
  done
  
  if [ ${#missing_roles[@]} -gt 0 ]; then
    echo "Warning: Missing role directories in JOURNAL_WORLD:" >&2
    printf "  %s\n" "${missing_roles[@]}" >&2
    echo "Consider running 'dirforge init journal' to create missing structure." >&2
    return 1
  fi
  
  return 0
}

# Find the JOURNAL_WORLD root directory
# Returns the absolute path to JOURNAL_WORLD or empty if not found
# Usage: journal_root=$(find_journal_world_root)
find_journal_world_root() {
  local current_dir
  current_dir="$(pwd)"
  
  # Walk up the directory tree looking for JOURNAL_WORLD
  while [ "$current_dir" != "/" ]; do
    # Check if current directory IS JOURNAL_WORLD
    if [ "$(basename "$current_dir")" = "JOURNAL_WORLD" ]; then
      echo "$current_dir"
      return 0
    fi
    
    # Check if current directory contains JOURNAL_WORLD
    if [ -d "$current_dir/JOURNAL_WORLD" ]; then
      echo "$current_dir/JOURNAL_WORLD"
      return 0
    fi
    
    # Move up one directory
    current_dir="$(dirname "$current_dir")"
  done
  
  # Not found
  return 1
}

# Validate paper name format and convert to valid directory name with comprehensive error messages
# Returns 0 if valid, 1 if invalid (with detailed error to stderr)
# Outputs sanitized name to stdout
# Usage: sanitized_name=$(validate_paper_name "Paper Name")
validate_paper_name() {
  local paper_name="$1"
  
  # Check for empty input
  if [ -z "$paper_name" ]; then
    echo "Error: Paper name cannot be empty." >&2
    echo "  Expected format: descriptive name like 'thermal_conductivity_review' or 'seismic_hazard_analysis'" >&2
    echo "  Example: --name \"thermal_conductivity_review\"" >&2
    return 1
  fi
  
  # Check minimum length (at least 3 characters for meaningful names)
  if [ ${#paper_name} -lt 3 ]; then
    echo "Error: Paper name must be at least 3 characters long." >&2
    echo "  Current: '$paper_name' (${#paper_name} characters)" >&2
    echo "  Example: --name \"thermal_review\" (meaningful descriptive name)" >&2
    return 1
  fi
  
  # Check maximum length (filesystem limits and readability)
  if [ ${#paper_name} -gt 200 ]; then
    echo "Error: Paper name is too long (${#paper_name} characters, maximum 200)." >&2
    echo "  Try using a shorter, more focused description." >&2
    echo "  Example: Instead of a full title, use key terms like 'thermal_conductivity_review'" >&2
    return 1
  fi
  
  # Check for invalid characters with specific guidance
  if echo "$paper_name" | grep -q '[<>:"|?*\\]'; then
    echo "Error: Paper name contains invalid filesystem characters." >&2
    echo "  Invalid characters found: $(echo "$paper_name" | grep -o '[<>:"|?*\\]' | tr '\n' ' ')" >&2
    echo "  These characters are not allowed in directory names: < > : \" | ? * \\" >&2
    echo "  Example: Use 'thermal_analysis' instead of 'thermal:analysis'" >&2
    return 1
  fi
  
  # Check for problematic patterns
  if echo "$paper_name" | grep -q '^\.\|/$\|/\.\|\./$'; then
    echo "Error: Paper name contains problematic path patterns." >&2
    echo "  Cannot start with '.', end with '/', or contain './' or './'" >&2
    echo "  Example: Use 'thermal_review' instead of './thermal_review'" >&2
    return 1
  fi
  
  # Check for multiple consecutive separators before sanitization
  if echo "$paper_name" | grep -q '  \|__\|--\|\.\.'; then
    echo "Warning: Paper name contains multiple consecutive separators." >&2
    echo "  These will be cleaned up: '  ' -> '_', '__' -> '_', '--' -> '_'" >&2
  fi
  
  # Check for year prefix format if provided
  if echo "$paper_name" | grep -q '^[0-9]\{4\}_'; then
    local year_part
    year_part=$(echo "$paper_name" | cut -d'_' -f1)
    if [ "$year_part" -lt 1900 ] || [ "$year_part" -gt 2100 ]; then
      echo "Error: Year prefix '$year_part' is outside reasonable range (1900-2100)." >&2
      echo "  Current format: '$paper_name'" >&2
      echo "  Example: Use '2025_thermal_review' for 2025 papers" >&2
      return 1
    fi
  fi
  
  # Check for characters beyond the allowed set: letters, numbers, spaces, hyphens, underscores
  if echo "$paper_name" | grep -q '[^a-zA-Z0-9 _-]'; then
    echo "Error: Paper name contains characters beyond the allowed set." >&2
    echo "  Allowed: letters, numbers, spaces, hyphens, underscores" >&2
    echo "  Invalid characters found: $(echo "$paper_name" | grep -o '[^a-zA-Z0-9 _-]' | tr '\n' ' ' | sed 's/ *$//')" >&2
    echo "  Example: Use 'thermal_analysis' instead of 'thermal@analysis'" >&2
    return 1
  fi
  
  # Convert to lowercase with underscores (standard format)
  local sanitized
  sanitized=$(echo "$paper_name" | tr '[:upper:]' '[:lower:]' | tr ' -' '_' | sed 's/[^a-z0-9_]/_/g' | sed 's/__*/_/g' | sed 's/^_\|_$//g')
  
  # Check if sanitization resulted in empty string
  if [ -z "$sanitized" ]; then
    echo "Error: Paper name results in empty directory name after sanitization." >&2
    echo "  Original: '$paper_name'" >&2
    echo "  After cleanup: empty" >&2
    echo "  Try using more letters and numbers, avoiding only special characters." >&2
    echo "  Example: --name \"thermal_analysis\" (uses letters and underscores)" >&2
    return 1
  fi
  
  # Check if sanitized name is too short after cleanup
  if [ ${#sanitized} -lt 2 ]; then
    echo "Error: Paper name becomes too short after sanitization." >&2
    echo "  Original: '$paper_name'" >&2
    echo "  After cleanup: '$sanitized' (${#sanitized} characters)" >&2
    echo "  Use a longer, more descriptive name with letters and numbers." >&2
    echo "  Example: --name \"thermal_review\" (results in 'thermal_review')" >&2
    return 1
  fi
  
  # Check for reserved names that might conflict with system directories
  case "$sanitized" in
    "admin"|"manuscript"|"reviews"|"correspondence"|"tmp"|"temp"|"test"|"src"|"bin"|"lib"|"etc")
      echo "Error: Paper name '$sanitized' conflicts with system directory names." >&2
      echo "  Reserved names: admin, manuscript, reviews, correspondence, tmp, temp, test, src, bin, lib, etc" >&2
      echo "  Example: Use 'thermal_admin_study' instead of 'admin'" >&2
      return 1
      ;;
  esac
  
  # Success: output sanitized name
  echo "$sanitized"
  return 0
}

# Validate year format (4-digit YYYY)
# Returns 0 if valid, 1 if invalid (with error to stderr)
# Usage: validate_year_format "2025"
validate_year_format() {
  local year="$1"
  
  if [ -z "$year" ]; then
    echo "Error: Year cannot be empty." >&2
    return 1
  fi
  
  # Check if it's exactly 4 digits
  if ! echo "$year" | grep -q '^[0-9]\{4\}$'; then
    echo "Error: Year must be a 4-digit number (YYYY)." >&2
    return 1
  fi
  
  # Basic sanity check for reasonable year range
  if [ "$year" -lt 1990 ] || [ "$year" -gt 2030 ]; then
    echo "Warning: Year '$year' seems unusual (expected 1990-2030)." >&2
  fi
  
  return 0
}

# Validate journal name for service structure
# Returns 0 if valid, 1 if invalid (with detailed error to stderr)
# Outputs sanitized journal name to stdout
# Usage: sanitized_journal=$(validate_journal_name "Journal Name")
validate_journal_name() {
  local journal_name="$1"
  
  # Check for empty input
  if [ -z "$journal_name" ]; then
    echo "Error: Journal name cannot be empty." >&2
    echo "  Expected format: descriptive journal name like 'nature_geoscience' or 'journal_structural_geology'" >&2
    echo "  Example: --name \"nature_geoscience\"" >&2
    return 1
  fi
  
  # Check minimum length (at least 3 characters for meaningful names)
  if [ ${#journal_name} -lt 3 ]; then
    echo "Error: Journal name must be at least 3 characters long." >&2
    echo "  Current: '$journal_name' (${#journal_name} characters)" >&2
    echo "  Example: --name \"nature\" (short journal name)" >&2
    return 1
  fi
  
  # Check maximum length (filesystem limits and readability)
  if [ ${#journal_name} -gt 100 ]; then
    echo "Error: Journal name is too long (${#journal_name} characters, maximum 100)." >&2
    echo "  Try using a shorter journal name or abbreviation." >&2
    echo "  Example: Use 'nature_geosci' instead of full journal title" >&2
    return 1
  fi
  
  # Check for invalid characters with specific guidance
  if echo "$journal_name" | grep -q '[<>:"|?*\\]'; then
    echo "Error: Journal name contains invalid filesystem characters." >&2
    echo "  Invalid characters found: $(echo "$journal_name" | grep -o '[<>:"|?*\\]' | tr '\n' ' ')" >&2
    echo "  These characters are not allowed in directory names: < > : \" | ? * \\" >&2
    echo "  Example: Use 'nature_geoscience' instead of 'nature:geoscience'" >&2
    return 1
  fi
  
  # Convert to lowercase with underscores, removing special chars
  local sanitized
  sanitized=$(echo "$journal_name" | tr '[:upper:]' '[:lower:]' | tr ' -' '_' | sed 's/[^a-z0-9_]/_/g' | sed 's/__*/_/g' | sed 's/^_\|_$//g')
  
  # Check if sanitization resulted in empty string
  if [ -z "$sanitized" ]; then
    echo "Error: Journal name results in empty directory name after sanitization." >&2
    echo "  Original: '$journal_name'" >&2
    echo "  After cleanup: empty" >&2
    echo "  Try using more letters and numbers, avoiding only special characters." >&2
    echo "  Example: --name \"nature_geoscience\" (uses letters and underscores)" >&2
    return 1
  fi
  
  # Check if sanitized name is too short after cleanup
  if [ ${#sanitized} -lt 2 ]; then
    echo "Error: Journal name becomes too short after sanitization." >&2
    echo "  Original: '$journal_name'" >&2
    echo "  After cleanup: '$sanitized' (${#sanitized} characters)" >&2
    echo "  Use a longer, more descriptive journal name with letters and numbers." >&2
    echo "  Example: --name \"nature\" (results in 'nature')" >&2
    return 1
  fi
  
  # Success: output sanitized name
  echo "$sanitized"
  return 0
}

# Validate manuscript ID format for service structure
# Returns 0 if valid, 1 if invalid (with detailed error to stderr)
# Usage: validate_manuscript_id "GJI-S-25-0928"
validate_manuscript_id() {
  local manuscript_id="$1"
  
  # Check for empty input
  if [ -z "$manuscript_id" ]; then
    echo "Error: Manuscript ID cannot be empty." >&2
    echo "  Expected format: journal manuscript ID like 'GJI-S-25-0928' or 'NATURE-2024-12345'" >&2
    echo "  Example: --id \"GJI-S-25-0928\"" >&2
    return 1
  fi
  
  # Check minimum length (at least 3 characters for meaningful IDs)
  if [ ${#manuscript_id} -lt 3 ]; then
    echo "Error: Manuscript ID must be at least 3 characters long." >&2
    echo "  Current: '$manuscript_id' (${#manuscript_id} characters)" >&2
    echo "  Example: --id \"ABC123\" (short manuscript ID)" >&2
    return 1
  fi
  
  # Check maximum length (filesystem limits)
  if [ ${#manuscript_id} -gt 50 ]; then
    echo "Error: Manuscript ID is too long (${#manuscript_id} characters, maximum 50)." >&2
    echo "  Try using a shorter manuscript ID." >&2
    echo "  Example: Use 'GJI-2025-123' instead of very long IDs" >&2
    return 1
  fi
  
  # Check for invalid filesystem characters
  if echo "$manuscript_id" | grep -q '[<>:"|?*\\]'; then
    echo "Error: Manuscript ID contains invalid filesystem characters." >&2
    echo "  Invalid characters found: $(echo "$manuscript_id" | grep -o '[<>:"|?*\\]' | tr '\n' ' ')" >&2
    echo "  These characters are not allowed in directory names: < > : \" | ? * \\" >&2
    echo "  Example: Use 'GJI-S-25-0928' instead of 'GJI:S:25:0928'" >&2
    return 1
  fi
  
  # Check for characters beyond the allowed set: letters, numbers, dots, hyphens, underscores
  if echo "$manuscript_id" | grep -q '[^a-zA-Z0-9._-]'; then
    echo "Error: Manuscript ID contains characters beyond the allowed set." >&2
    echo "  Allowed: letters, numbers, dots, hyphens, underscores" >&2
    echo "  Invalid characters found: $(echo "$manuscript_id" | grep -o '[^a-zA-Z0-9._-]' | tr '\n' ' ' | sed 's/ *$//')" >&2
    echo "  Example: Use 'GJI-S-25-0928' instead of 'GJI@S@25@0928'" >&2
    return 1
  fi
  
  # Validate that it contains at least some letters or numbers (not just separators)
  if ! echo "$manuscript_id" | grep -q '[a-zA-Z0-9]'; then
    echo "Error: Manuscript ID must contain at least one letter or number." >&2
    echo "  Current: '$manuscript_id' (only separators)" >&2
    echo "  Example: --id \"GJI-123\" (contains letters and numbers)" >&2
    return 1
  fi
  
  return 0
}

# Create role-based JOURNAL_WORLD directory structure
# Returns 0 if successful, 1 if error (with error to stderr)
# Usage: create_journal_role_structure
create_journal_role_structure() {
  # Find or create JOURNAL_WORLD root
  local journal_root
  journal_root="$(find_journal_world_root)"
  
  if [ -z "$journal_root" ]; then
    # Create JOURNAL_WORLD parent directory
    do_mkdir_p "JOURNAL_WORLD"
    journal_root="$(pwd)/JOURNAL_WORLD"
    
    if [ "$DRY_RUN" = true ]; then
      if [ "$JSON_OUTPUT" = false ]; then
        echo "DRY RUN: would create JOURNAL_WORLD structure"
      fi
    else
      echo "Created JOURNAL_WORLD directory"
    fi
  fi
  
  # Create all role directories
  local role_dirs=("00_admin" "01_primary_authorship" "02_coauthor_invites" "03_journal_service")
  for role in "${role_dirs[@]}"; do
    do_mkdir_p "$journal_root/$role"
  done
  
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create role-based structure in $journal_root"
    fi
  else
    echo "Created role-based directory structure in $journal_root"
  fi
  
  return 0
}

# Create primary authorship project directory with standard subdirectories
# Returns 0 if successful, 1 if error (with error to stderr)
# Usage: create_primary_authorship_project <paper_name> <year>
create_primary_authorship_project() {
  local paper_name="$1"
  local year="$2"
  
  # Use path construction utility to build project path
  local project_path
  if ! project_path="$(construct_primary_authorship_path "$paper_name" "$year")"; then
    return 1
  fi
  
  # Check for conflicts (only in non-dry-run mode)
  if [ "$DRY_RUN" = false ] && [ -d "$project_path" ]; then
    echo "Error: Primary authorship project already exists: $project_path" >&2
    return 1
  fi
  
  # Create project directory first
  do_mkdir_p "$project_path"
  
  # Create standard subdirectories with comprehensive validation
  if ! create_standard_subdirectories "$project_path"; then
    return 1
  fi
  
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create primary authorship project: $project_path"
    fi
  else
    echo "Created primary authorship project: $project_path"
  fi
  
  return 0
}

# Create co-author collaboration project directory with standard subdirectories  
# Returns 0 if successful, 1 if error (with error to stderr)
# Usage: create_coauthor_project <paper_name> <year>
create_coauthor_project() {
  local paper_name="$1"
  local year="$2"
  
  # Use path construction utility to build project path
  local project_path
  if ! project_path="$(construct_coauthor_path "$paper_name" "$year")"; then
    return 1
  fi
  
  # Check for conflicts (only in non-dry-run mode)
  if [ "$DRY_RUN" = false ] && [ -d "$project_path" ]; then
    echo "Error: Co-author project already exists: $project_path" >&2
    return 1
  fi
  
  # Create project directory first
  do_mkdir_p "$project_path"
  
  # Create standard subdirectories with comprehensive validation
  if ! create_standard_subdirectories "$project_path"; then
    return 1
  fi
  
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create co-author project: $project_path"
    fi
  else
    echo "Created co-author project: $project_path"
  fi
  
  return 0
}

# Create journal service project directory with two-level structure
# Returns 0 if successful, 1 if error (with error to stderr)
# Usage: create_journal_service_project <journal_name> <manuscript_id>
create_journal_service_project() {
  local journal_name="$1"
  local manuscript_id="$2"
  
  # Use path construction utility to build project path
  local project_path
  if ! project_path="$(construct_service_path "$journal_name" "$manuscript_id")"; then
    return 1
  fi
  
  # Check for conflicts (only in non-dry-run mode)
  if [ "$DRY_RUN" = false ] && [ -d "$project_path" ]; then
    echo "Error: Journal service project already exists: $project_path" >&2
    return 1
  fi
  
  # Create project directory first
  do_mkdir_p "$project_path"
  
  # Create standard subdirectories with comprehensive validation
  if ! create_standard_subdirectories "$project_path"; then
    return 1
  fi
  
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create journal service project: $project_path"
    fi
  else
    echo "Created journal service project: $project_path"
  fi
  
  return 0
}

# Extract year from paper name if embedded (YYYY_ prefix format)
# Returns extracted year or current year as fallback
# Usage: year=$(extract_year_from_paper_name "2021_elastic_properties")
extract_year_from_paper_name() {
  local paper_name="$1"
  
  # Check for YYYY_ prefix pattern
  if echo "$paper_name" | grep -q '^[0-9]\{4\}_'; then
    # Extract the year prefix
    echo "$paper_name" | cut -d'_' -f1
  else
    # Return current year as default
    date +%Y
  fi
}

# Strip year prefix from paper name if present
# Returns paper name without year prefix
# Usage: clean_name=$(strip_year_from_paper_name "2021_elastic_properties")
strip_year_from_paper_name() {
  local paper_name="$1"
  
  # Check for YYYY_ prefix pattern
  if echo "$paper_name" | grep -q '^[0-9]\{4\}_'; then
    # Remove the year prefix
    echo "$paper_name" | sed 's/^[0-9]\{4\}_//'
  else
    # Return unchanged if no year prefix
    echo "$paper_name"
  fi
}

# Role-based path construction utilities
# These functions implement the Path Resolution Algorithm from the contracts

# Construct primary authorship project path
# Returns the full path to the project directory
# Usage: path=$(construct_primary_authorship_path <paper_name> <year>)
construct_primary_authorship_path() {
  local paper_name="$1"
  local year="$2"
  local journal_root="${3:-}"
  
  # Validate inputs
  local sanitized_name
  if ! sanitized_name="$(validate_paper_name "$paper_name")"; then
    return 1
  fi
  
  if ! validate_year_format "$year"; then
    return 1
  fi
  
  # Use provided journal root or use WORKSPACE_ROOT
  if [ -z "$journal_root" ]; then
    journal_root="$WORKSPACE_ROOT/JOURNAL_WORLD"
    
    # Create parent directories if they don't exist
    if [ "$DRY_RUN" = false ]; then
      if [ ! -d "$WORKSPACE_ROOT/JOURNAL_WORLD" ]; then
        do_mkdir_p "$WORKSPACE_ROOT/JOURNAL_WORLD"
        echo "Created parent directory: $WORKSPACE_ROOT/JOURNAL_WORLD"
      fi
      if [ ! -d "$journal_root/01_primary_authorship" ]; then
        do_mkdir_p "$journal_root/01_primary_authorship"
        echo "Created category directory: $journal_root/01_primary_authorship"
      fi
    fi
  fi
  
  # Algorithm: "01_primary_authorship/{year}_{paper_name}/"
  echo "$journal_root/01_primary_authorship/${year}_${sanitized_name}"
  return 0
}

# Construct co-author collaboration project path
# Returns the full path to the project directory  
# Usage: path=$(construct_coauthor_path <paper_name> <year>)
construct_coauthor_path() {
  local paper_name="$1"
  local year="$2"
  local journal_root="${3:-}"
  
  # Validate inputs
  local sanitized_name
  if ! sanitized_name="$(validate_paper_name "$paper_name")"; then
    return 1
  fi
  
  if ! validate_year_format "$year"; then
    return 1
  fi
  
  # Use provided journal root or use WORKSPACE_ROOT
  if [ -z "$journal_root" ]; then
    journal_root="$WORKSPACE_ROOT/JOURNAL_WORLD"
    
    # Create parent directories if they don't exist
    if [ "$DRY_RUN" = false ]; then
      if [ ! -d "$WORKSPACE_ROOT/JOURNAL_WORLD" ]; then
        do_mkdir_p "$WORKSPACE_ROOT/JOURNAL_WORLD"
        echo "Created parent directory: $WORKSPACE_ROOT/JOURNAL_WORLD"
      fi
      if [ ! -d "$journal_root/02_coauthor_invites" ]; then
        do_mkdir_p "$journal_root/02_coauthor_invites"
        echo "Created category directory: $journal_root/02_coauthor_invites"
      fi
    fi
  fi
  
  # Algorithm: "02_coauthor_invites/{year}_{paper_name}/"
  echo "$journal_root/02_coauthor_invites/${year}_${sanitized_name}"
  return 0
}

# Construct journal service project path
# Returns the full path to the project directory
# Usage: path=$(construct_service_path <journal_name> <manuscript_id>)
construct_service_path() {
  local journal_name="$1"
  local manuscript_id="$2"
  local journal_root="${3:-}"
  
  # Validate inputs
  local sanitized_journal
  if ! sanitized_journal="$(validate_journal_name "$journal_name")"; then
    return 1
  fi
  
  if ! validate_manuscript_id "$manuscript_id"; then
    return 1
  fi
  
  # Use provided journal root or use WORKSPACE_ROOT
  if [ -z "$journal_root" ]; then
    journal_root="$WORKSPACE_ROOT/JOURNAL_WORLD"
    
    # Create parent directories if they don't exist
    if [ "$DRY_RUN" = false ]; then
      if [ ! -d "$WORKSPACE_ROOT/JOURNAL_WORLD" ]; then
        do_mkdir_p "$WORKSPACE_ROOT/JOURNAL_WORLD"
        echo "Created parent directory: $WORKSPACE_ROOT/JOURNAL_WORLD"
      fi
      if [ ! -d "$journal_root/03_journal_service" ]; then
        do_mkdir_p "$journal_root/03_journal_service"
        echo "Created category directory: $journal_root/03_journal_service"
      fi
      if [ ! -d "$journal_root/03_journal_service/${sanitized_journal}" ]; then
        do_mkdir_p "$journal_root/03_journal_service/${sanitized_journal}"
        echo "Created journal directory: $journal_root/03_journal_service/${sanitized_journal}"
      fi
    fi
  fi
  
  # Algorithm: "03_journal_service/{journal_lower}/{manuscript_id}/"
  echo "$journal_root/03_journal_service/${sanitized_journal}/${manuscript_id}"
  return 0
}

# Construct standard subdirectory paths for any journal project
# Returns array of subdirectory paths  
# Usage: subdirs=($(construct_standard_subdirs <project_path>))
construct_standard_subdirs() {
  local project_path="$1"
  
  if [ -z "$project_path" ]; then
    echo "Error: Project path cannot be empty" >&2
    return 1
  fi
  
  # Standard subdirectories according to contracts
  echo "$project_path/01_manuscript"
  echo "$project_path/02_reviews"
  echo "$project_path/03_correspondence"
  return 0
}

# Create standard subdirectories with comprehensive permission and conflict validation
# Returns 0 if successful, 1 if error (with detailed error messages to stderr)
# Usage: create_standard_subdirectories <project_path> [--force-overwrite]
create_standard_subdirectories() {
  local project_path="$1"
  local force_overwrite=false
  
  # Parse optional arguments
  shift
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --force-overwrite)
        force_overwrite=true
        ;;
      *)
        echo "Error: Unknown argument to create_standard_subdirectories: $1" >&2
        return 1
        ;;
    esac
    shift
  done
  
  if [ -z "$project_path" ]; then
    echo "Error: Project path cannot be empty" >&2
    return 1
  fi
  
  # Validate project path exists or can be created
  if [ "$DRY_RUN" = false ]; then
    if [ ! -d "$project_path" ]; then
      echo "Error: Project directory does not exist: $project_path" >&2
      return 1
    fi
    
    # Check write permission on project directory
    if [ ! -w "$project_path" ]; then
      echo "Error: No write permission for project directory: $project_path" >&2
      return 1
    fi
  fi
  
  # Get standard subdirectory paths
  local subdirs
  subdirs=($(construct_standard_subdirs "$project_path"))
  if [ $? -ne 0 ]; then
    return 1
  fi
  
  # Check for conflicts and permission issues
  local conflicts=()
  local permission_issues=()
  
  for subdir in "${subdirs[@]}"; do
    if [ "$DRY_RUN" = false ]; then
      # Check if subdirectory already exists
      if [ -d "$subdir" ]; then
        if [ "$force_overwrite" = false ]; then
          conflicts+=("$subdir")
        fi
      fi
      
      # Check if parent directory is writable
      local parent_dir
      parent_dir="$(dirname "$subdir")"
      if [ -d "$parent_dir" ] && [ ! -w "$parent_dir" ]; then
        permission_issues+=("$parent_dir (cannot create $subdir)")
      fi
      
      # Check if subdirectory exists but is not a directory (e.g., a file)
      if [ -e "$subdir" ] && [ ! -d "$subdir" ]; then
        echo "Error: Path exists but is not a directory: $subdir" >&2
        return 1
      fi
    fi
  done
  
  # Report conflicts if any
  if [ ${#conflicts[@]} -gt 0 ]; then
    echo "Error: Standard subdirectories already exist:" >&2
    for conflict in "${conflicts[@]}"; do
      echo "  $conflict" >&2
    done
    echo "Use --force-overwrite to proceed anyway, or remove existing directories." >&2
    return 1
  fi
  
  # Report permission issues if any
  if [ ${#permission_issues[@]} -gt 0 ]; then
    echo "Error: Permission denied for subdirectory creation:" >&2
    for issue in "${permission_issues[@]}"; do
      echo "  $issue" >&2
    done
    echo "Check directory permissions and ownership." >&2
    return 1
  fi
  
  # Create subdirectories
  for subdir in "${subdirs[@]}"; do
    do_mkdir_p "$subdir"
  done
  
  # Validate creation success (in non-dry-run mode)
  if [ "$DRY_RUN" = false ]; then
    local creation_failures=()
    for subdir in "${subdirs[@]}"; do
      if [ ! -d "$subdir" ]; then
        creation_failures+=("$subdir")
      fi
    done
    
    if [ ${#creation_failures[@]} -gt 0 ]; then
      echo "Error: Failed to create subdirectories:" >&2
      for failure in "${creation_failures[@]}"; do
        echo "  $failure" >&2
      done
      return 1
    fi
    
    # Verify permissions on created directories
    local permission_failures=()
    for subdir in "${subdirs[@]}"; do
      if [ ! -w "$subdir" ] || [ ! -r "$subdir" ]; then
        permission_failures+=("$subdir")
      fi
    done
    
    if [ ${#permission_failures[@]} -gt 0 ]; then
      echo "Warning: Created subdirectories have unexpected permissions:" >&2
      for failure in "${permission_failures[@]}"; do
        echo "  $failure (check read/write permissions)" >&2
      done
      # Don't return error for this - it's a warning
    fi
  fi
  
  return 0
}

# Validate role-based path structure
# Returns 0 if valid role-based path, 1 if invalid  
# Usage: validate_role_path <path>
validate_role_path() {
  local path="$1"
  
  if [ -z "$path" ]; then
    echo "Error: Path cannot be empty" >&2
    return 1
  fi
  
  # Check if path contains JOURNAL_WORLD
  if ! echo "$path" | grep -q "JOURNAL_WORLD"; then
    echo "Error: Path must be within JOURNAL_WORLD structure" >&2
    return 1
  fi
  
  # Check for valid role directory pattern
  if echo "$path" | grep -q "JOURNAL_WORLD/01_primary_authorship/[0-9]\{4\}_[a-z0-9_]\+"; then
    return 0  # Primary authorship path
  elif echo "$path" | grep -q "JOURNAL_WORLD/02_coauthor_invites/[0-9]\{4\}_[a-z0-9_]\+"; then
    return 0  # Co-author path
  elif echo "$path" | grep -q "JOURNAL_WORLD/03_journal_service/[a-z0-9_]\+/[a-zA-Z0-9._-]\+"; then
    return 0  # Journal service path
  elif echo "$path" | grep -q "JOURNAL_WORLD/00_admin"; then
    return 0  # Admin path (manual creation)
  else
    echo "Error: Path does not match any valid role-based pattern" >&2
    return 1
  fi
}

# Extract role type from journal path
# Returns role name (primary_authorship, coauthor_invites, journal_service, admin)
# Usage: role=$(extract_role_from_path <path>)
extract_role_from_path() {
  local path="$1"
  
  if [ -z "$path" ]; then
    echo "Error: Path cannot be empty" >&2
    return 1
  fi
  
  if echo "$path" | grep -q "/01_primary_authorship/"; then
    echo "primary_authorship"
  elif echo "$path" | grep -q "/02_coauthor_invites/"; then
    echo "coauthor_invites"
  elif echo "$path" | grep -q "/03_journal_service/"; then
    echo "journal_service"
  elif echo "$path" | grep -q "/00_admin/"; then
    echo "admin"
  else
    echo "Error: Cannot determine role from path: $path" >&2
    return 1
  fi
}

# Get the role directory for a given role type
# Returns the role directory name (e.g., "01_primary_authorship")
# Usage: role_dir=$(get_role_directory <role_name>)
get_role_directory() {
  local role_name="$1"
  
  case "$role_name" in
    primary_authorship|primary|first)
      echo "01_primary_authorship"
      ;;
    coauthor_invites|coauthor|collaboration)
      echo "02_coauthor_invites" 
      ;;
    journal_service|service|editorial)
      echo "03_journal_service"
      ;;
    admin|administrative)
      echo "00_admin"
      ;;
    *)
      echo "Error: Unknown role name: $role_name" >&2
      return 1
      ;;
  esac
}

create_conda_env() {
  local env_name="$1"; shift
  local py_ver="$1"; shift
  local packages="$*"
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create conda environment: $env_name (python=$py_ver)"
    fi
    return 0
  fi
  if ! command -v conda >/dev/null 2>&1; then
    echo "Conda not found in PATH ‚Äî skipping env creation (or use --no-conda to suppress)." >&2
    return 0
  fi
  if conda_env_exists "$env_name"; then
    echo "Conda environment '$env_name' already exists - skipping creation."
    return 0
  fi
  echo "Creating conda environment: $env_name"
  conda create -n "$env_name" python="$py_ver" $packages -y
}

export_environment_yaml() {
  local env_name="$1"; shift
  local dest="$1"; shift
  local py_ver="$1"; shift
  local packages="$*"
  do_mkdir_p "$(dirname "$dest")"
  write_file "$dest" <<EOF
name: $env_name
channels:
  - defaults
dependencies:
  - python=$py_ver
$(for p in $packages; do echo "  - $p"; done)
EOF
}

init_research() {
  local name="${NAME:-}" project_id="" study_name="" py_ver="${PY:-3.11}" no_conda=false extra_pkgs=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --name|-n) shift; name="$1";;
      --project|-p) shift; project_id="$1";;
      --study|-s) shift; study_name="$1";;
      --python) shift; py_ver="$1";;
      --no-conda) no_conda=true;;
      --conda-packages) shift; extra_pkgs="$1";;
      *) echo "Unknown arg: $1"; exit 1;;
    esac
    shift
  done
  
  # Determine operation mode
  if [ -n "$project_id" ] && [ -n "$study_name" ]; then
    # Study creation mode
    init_research_study --project "$project_id" --study "$study_name"
    return
  elif [ -n "$name" ] && [ -n "$study_name" ]; then
    # Combined project + study creation
    # First create project, then create study
    local args=()
    [ -n "$name" ] && args+=(--name "$name")
    [ -n "$py_ver" ] && args+=(--python "$py_ver")
    [ "$no_conda" = true ] && args+=(--no-conda)
    [ -n "$extra_pkgs" ] && args+=(--conda-packages "$extra_pkgs")
    init_research_project_only "${args[@]}"
    # Extract project ID from what was just created
    local id_raw
    id_raw=$(to_snake_case "$name")
    local year
    year=$(date +%Y)
    if [[ "$id_raw" =~ ^[0-9]{4}_ ]]; then
      project_id="$id_raw"
    else
      project_id="${year}_$id_raw"
    fi
    init_research_study --project "$project_id" --study "$study_name"
    return
  elif [ -n "$name" ]; then
    # Project creation mode
    local args=()
    [ -n "$name" ] && args+=(--name "$name")
    [ -n "$py_ver" ] && args+=(--python "$py_ver")
    [ "$no_conda" = true ] && args+=(--no-conda)
    [ -n "$extra_pkgs" ] && args+=(--conda-packages "$extra_pkgs")
    init_research_project_only "${args[@]}"
    return
  else
    show_research_missing_args_error "$PROG_NAME"
    exit 1
  fi
}

init_research_project_only() {
  local name="" py_ver="${PY:-3.11}" no_conda=false extra_pkgs=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --name|-n) shift; name="$1";;
      --python) shift; py_ver="$1";;
      --no-conda) no_conda=true;;
      --conda-packages) shift; extra_pkgs="$1";;
      *) echo "Unknown arg: $1"; exit 1;;
    esac
    shift
  done
  if [ -z "$name" ]; then
    read -r -p "Project name: " name
  fi
  local title="$name"  # Set title for template rendering
  local id_raw
  id_raw=$(to_snake_case "$name")
  # prefix with year if not present
  local year
  year=$(date +%Y)
  if [[ "$id_raw" =~ ^[0-9]{4}_ ]]; then
    PROJECT_ID="$id_raw"
  else
    PROJECT_ID="${year}_$id_raw"
  fi
  # conda env name
  local id_no_year
  id_no_year=$(strip_year_prefix "$PROJECT_ID")
  CONDA_NAME="research_${id_no_year}"

  RESEARCH_ROOT="$WORKSPACE_ROOT/RESEARCH_WORLD/$PROJECT_ID"
  
  # Create RESEARCH_WORLD parent directory if it doesn't exist
  if [ ! -d "$WORKSPACE_ROOT/RESEARCH_WORLD" ]; then
    do_mkdir_p "$WORKSPACE_ROOT/RESEARCH_WORLD"
    if [ "$DRY_RUN" = false ]; then
      echo "Created parent directory: $WORKSPACE_ROOT/RESEARCH_WORLD"
    fi
  fi
  
  if [ -d "$RESEARCH_ROOT" ]; then
    if [ "$FORCE" = false ] && [ "$BACKUP" = false ]; then
      echo "Project '$PROJECT_ID' already exists at $RESEARCH_ROOT" >&2
      echo "Use --force to overwrite or --backup to create a backup before overwriting" >&2
      exit 1
    fi
    
    # Prompt for confirmation unless --yes is set
    prompt_overwrite "$RESEARCH_ROOT"
    
    # Create backup if requested
    if [ "$BACKUP" = true ]; then
      backup_directory "$RESEARCH_ROOT"
    fi
    
    # Remove existing directory
    if [ "$DRY_RUN" = false ]; then
      rm -rf "$RESEARCH_ROOT"
    fi
  fi
  do_mkdir_p "$RESEARCH_ROOT"
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create directory: $RESEARCH_ROOT"
    fi
  else
    echo "Created directory: $RESEARCH_ROOT"
  fi

  # create numbered subfolders
  for d in 00_admin 01_project_management 02_studies; do
    do_mkdir_p "$RESEARCH_ROOT/$d"
  done

  # Create project management subdirectories
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/01_proposal/01_draft"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/01_proposal/02_submission"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/01_proposal/03_review"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/01_proposal/04_final"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/02_finance"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/03_reports"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/04_presentations"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/05_supervision/BSc_Thesis"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/05_supervision/MSc_Thesis"
  do_mkdir_p "$RESEARCH_ROOT/01_project_management/05_supervision/PhD_Supervision"

  # Create .integrity directories (constitution v1.0.22 with metadata files)
  do_mkdir_p "$RESEARCH_ROOT/.integrity/checksums"
  do_mkdir_p "$RESEARCH_ROOT/.integrity/manifests"

  # Create .integrity/project.yaml for v1.0.22 compliance
  local integrity_yaml="$RESEARCH_ROOT/.integrity/project.yaml"
  write_file "$integrity_yaml" <<EOF
name: "$title"
world_type: "RESEARCH_WORLD"
version: "1.0.22"
created: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
updated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
EOF

  # create README.md file
  write_file "$RESEARCH_ROOT/README.md" <<EOF
# $PROJECT_ID

Created: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
Conda env: $CONDA_NAME

## Project Structure

This research project follows the DirForge Constitution v1.0.17 study-based organization:

- \`00_admin/\` - Project contracts, ethics, agreements
- \`01_project_management/\` - Proposals, reports, budgets
- \`02_studies/\` - Container for individual research studies

## Creating Studies

Add studies to this project using:
\`\`\`bash
dirforge init research --project $PROJECT_ID --study "Study Name"
\`\`\`

Each study will be created in \`02_studies/<study_name>/\` with its own protocols, code, data, outputs, and publications.
EOF

  # Render project management templates
  render_template "$TEMPLATES_DIR/research/01_project_management/01_proposal/README.md.template" "$RESEARCH_ROOT/01_project_management/01_proposal/README.md" "PROJECT_NAME=$title" "PROJECT_ID=$PROJECT_ID"
  render_template "$TEMPLATES_DIR/research/01_project_management/02_finance/README.md.template" "$RESEARCH_ROOT/01_project_management/02_finance/README.md" "PROJECT_NAME=$title" "PROJECT_ID=$PROJECT_ID"
  render_template "$TEMPLATES_DIR/research/01_project_management/03_reports/README.md.template" "$RESEARCH_ROOT/01_project_management/03_reports/README.md" "PROJECT_NAME=$title" "PROJECT_ID=$PROJECT_ID"
  render_template "$TEMPLATES_DIR/research/01_project_management/04_presentations/README.md.template" "$RESEARCH_ROOT/01_project_management/04_presentations/README.md" "PROJECT_NAME=$title" "PROJECT_ID=$PROJECT_ID"
  render_template "$TEMPLATES_DIR/research/01_project_management/05_supervision/README.md.template" "$RESEARCH_ROOT/01_project_management/05_supervision/README.md" "PROJECT_NAME=$title" "PROJECT_ID=$PROJECT_ID"

  # Conda
  if [ "$no_conda" = false ]; then
    local base_pkgs="numpy matplotlib pandas jupyter pyyaml"
    if [ -n "$extra_pkgs" ]; then
      base_pkgs="$base_pkgs $extra_pkgs"
    fi
    create_conda_env "$CONDA_NAME" "$py_ver" $base_pkgs || true
    export_environment_yaml "$CONDA_NAME" "$RESEARCH_ROOT/environment.yaml" "$py_ver" $base_pkgs
    echo "Activate with: conda activate $CONDA_NAME"
  else
    if [ "$JSON_OUTPUT" = false ]; then
      echo "--no-conda specified: skipping conda creation"
    fi
  fi

  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create research project '$PROJECT_ID' in $RESEARCH_ROOT"
    fi
  else
    echo "Created research project '$PROJECT_ID' in $RESEARCH_ROOT"
  fi
}

init_research_study() {
  local project_id="" study_name=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --project|-p) shift; project_id="$1";;
      --study|-s) shift; study_name="$1";;
      *) echo "Unknown arg for study: $1"; exit 1;;
    esac
    shift
  done

  if [ -z "$project_id" ]; then
    show_required_arg_error "--project" "$PROG_NAME" "research"
    exit 1
  fi
  if [ -z "$study_name" ]; then
    show_required_arg_error "--study" "$PROG_NAME" "research"
    exit 1
  fi

  local PROJECT_ROOT="$WORKSPACE_ROOT/RESEARCH_WORLD/$project_id"
  
  # Check if project exists (skip in dry-run mode for combined operations)
  if [ "$DRY_RUN" = false ] && [ ! -d "$PROJECT_ROOT" ]; then
    show_project_not_found_error "$project_id" "$PROJECT_ROOT"
    exit 1
  fi
  
  # Sanitize study name
  local study_id
  study_id=$(to_snake_case "$study_name")
  
  local STUDY_ROOT="$PROJECT_ROOT/02_studies/$study_id"
  if [ -d "$STUDY_ROOT" ]; then
    if [ "$FORCE" = false ] && [ "$BACKUP" = false ]; then
      echo "Study '$study_id' already exists at $STUDY_ROOT" >&2
      echo "Use --force to overwrite or --backup to create a backup before overwriting" >&2
      exit 1
    fi
    
    prompt_overwrite "$STUDY_ROOT"
    
    if [ "$BACKUP" = true ]; then
      backup_directory "$STUDY_ROOT"
    fi
    
    if [ "$DRY_RUN" = false ]; then
      rm -rf "$STUDY_ROOT"
    fi
  fi
  
  do_mkdir_p "$STUDY_ROOT"
  
  # Create study subdirectories
  for d in 00_protocols 01_code 02_data 03_outputs 04_publication 05_presentations; do
    do_mkdir_p "$STUDY_ROOT/$d"
  done
  
  # Create study .integrity directories
  do_mkdir_p "$STUDY_ROOT/.integrity/checksums"
  do_mkdir_p "$STUDY_ROOT/.integrity/manifests"

  # Create .integrity/study.yaml for v1.0.22 compliance
  local study_integrity_yaml="$STUDY_ROOT/.integrity/study.yaml"
  write_file "$study_integrity_yaml" <<EOF
name: "$study_name"
version: "1.0.22"
created: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
updated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
EOF

  # Create study README.md
  write_file "$STUDY_ROOT/README.md" <<EOF
# $study_name ($study_id)

Created: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
Project: $project_id

## Study Overview

**Research Question:** [Brief description of the specific research question this study addresses]

**Methods:** [Brief description of experimental/computational methods]

**Expected Outcomes:** [What results or insights this study aims to produce]

## Directory Structure

- \`00_protocols/\` - Experimental protocols, calibration notes, instrument configurations
- \`01_code/\` - Analysis scripts, notebooks, environment.yml
- \`02_data/\` - Raw and processed datasets, metadata.yaml files
- \`03_outputs/\` - Processed results, figures, tables
- \`04_publication/\` - Manuscript drafts, supplementary materials
- \`05_presentations/\` - Slides and presentations for conferences, meetings
- \`.integrity/\` - Checksums and manifest validation files
EOF

  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create research study '$study_id' in $STUDY_ROOT"
    fi
  else
    echo "Created research study '$study_id' in $STUDY_ROOT"
  fi
}

init_lecture() {
  local name="" py_ver="${PY:-3.11}" no_conda=false extra_pkgs=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --name|-n) shift; name="$1";;
      --python) shift; py_ver="$1";;
      --no-conda) no_conda=true;;
      --conda-packages) shift; extra_pkgs="$1";;
      *) echo "Unknown arg for lecture: $1"; exit 1;;
    esac
    shift
  done
  if [ -z "$name" ]; then
    read -r -p "Lecture name: " name
  fi
  lecture_id=$(to_snake_case "$name")
  if [ "$JSON_OUTPUT" = false ]; then
    echo "Lecture name converted to ID: $lecture_id"
  fi

  LECTURE_ROOT="$WORKSPACE_ROOT/LECTURE_WORLD/$lecture_id"
  
  # Create LECTURE_WORLD parent directory if it doesn't exist
  if [ ! -d "$WORKSPACE_ROOT/LECTURE_WORLD" ]; then
    do_mkdir_p "$WORKSPACE_ROOT/LECTURE_WORLD"
    if [ "$DRY_RUN" = false ]; then
      echo "Created parent directory: $WORKSPACE_ROOT/LECTURE_WORLD"
    fi
  fi
  
  if [ -d "$LECTURE_ROOT" ]; then
    if [ "$FORCE" = false ] && [ "$BACKUP" = false ]; then
      echo "Lecture '$lecture_id' already exists at $LECTURE_ROOT" >&2
      echo "Use --force to overwrite or --backup to create a backup before overwriting" >&2
      exit 1
    fi
    
    # Prompt for confirmation unless --yes is set
    prompt_overwrite "$LECTURE_ROOT"
    
    # Create backup if requested
    if [ "$BACKUP" = true ]; then
      backup_directory "$LECTURE_ROOT"
    fi
    
    # Remove existing directory
    if [ "$DRY_RUN" = false ]; then
      rm -rf "$LECTURE_ROOT"
    fi
  fi
  do_mkdir_p "$LECTURE_ROOT"
  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create directory: $LECTURE_ROOT"
    fi
  else
    echo "Created lecture directory: $LECTURE_ROOT"
  fi

  for d in 00_admin 01_code 02_data/experimental_recordings 02_data/reference 03_slides 04_manuscript 05_exercises/problems 05_exercises/solutions 05_exercises/submissions 05_exercises/graded 06_exams/problems 06_exams/solutions 06_exams/submissions 06_exams/graded 07_grades; do
    do_mkdir_p "$LECTURE_ROOT/$d"
  done

  # Create .integrity directories (constitution v1.0.22 with metadata files)
  do_mkdir_p "$LECTURE_ROOT/.integrity/checksums"
  do_mkdir_p "$LECTURE_ROOT/.integrity/manifests"

  # Create .integrity/lecture.yaml for v1.0.22 compliance
  local lecture_integrity_yaml="$LECTURE_ROOT/.integrity/lecture.yaml"
  write_file "$lecture_integrity_yaml" <<EOF
name: "$name"
world_type: "LECTURE_WORLD"
version: "1.0.22"
created: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
updated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
EOF

  write_file "$LECTURE_ROOT/README.md" <<'EOF'
# $name ($lecture_id)

Created: $(date --iso-8601=seconds)
Conda env: lecture_$lecture_id
EOF

  write_file "$LECTURE_ROOT/project.yaml" <<'EOF'
course_code: "<COURSE_CODE>"
title: "$name"
term: "<TERM>"
instructor:
  name: "<Instructor Name>"
  email: "<email@example.org>"
sync_policy: "iCloud: slides/manuscript; External: raw_recordings_on_nas"
conda_env: "lecture_$lecture_id"
project_id: "$lecture_id"
created: "$(date +%Y-%m-%d)"
EOF

  # Conda
  if [ "$no_conda" = false ]; then
    local base_pkgs="numpy matplotlib pandas jupyter pyyaml scipy seaborn ipywidgets"
    # beamer is not a python package, leave as note
    if [ -n "$extra_pkgs" ]; then
      base_pkgs="$base_pkgs $extra_pkgs"
    fi
    CONDA_NAME="lecture_$lecture_id"
    create_conda_env "$CONDA_NAME" "$py_ver" $base_pkgs || true
    export_environment_yaml "$CONDA_NAME" "$LECTURE_ROOT/01_code/environment.yaml" "$py_ver" $base_pkgs
    echo "Conda environment created: $CONDA_NAME"
    echo "Activate with: conda activate $CONDA_NAME"
  else
    if [ "$JSON_OUTPUT" = false ]; then
      echo "--no-conda specified: skipping conda creation"
    fi
  fi

  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create lecture project '$lecture_id' in $LECTURE_ROOT"
    fi
  else
    echo "Created lecture project '$lecture_id' in $LECTURE_ROOT"
  fi
}

init_coding() {
  local language="" project="" py_ver="${PY:-3.11}" skip_conda=false skip_git=false
  local no_git=false no_conda=false
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --language|-l)
        shift; language=$(echo "$1" | tr '[:upper:]' '[:lower:]') ;;
      --project|-p)
        shift; project="$1" ;;
      --python)
        shift; py_ver="$1" ;;
      --no-conda)
        skip_conda=true ;;
      --no-git)
        skip_git=true ;;
      --help)
        if declare -F show_coding_help >/dev/null 2>&1; then
          show_coding_help
        else
          echo "Usage: $PROG_NAME init coding --language <lang> --project <name> [options]"
        fi
        return 0 ;;
      *) echo "Unknown arg for coding: $1"; exit 1 ;;
    esac
    shift
  done

  if [ -z "$language" ] || [ -z "$project" ]; then
    show_coding_missing_args_error "$language" "$project" "$skip_conda" "$skip_git" "$py_ver" "$PROG_NAME"
    return 1
  fi

  case "$language" in
    python|matlab|fortran|bash)
      ;; 
    *)
      show_unsupported_language_error "$language" "$PROG_NAME"
      return 1
      ;;
  esac

  proj_id=$(to_snake_case "$project")
  local ROOT="$WORKSPACE_ROOT/CODING_WORLD/${language}/${proj_id}"
  
  # Create CODING_WORLD and language parent directories if they don't exist
  if [ ! -d "$WORKSPACE_ROOT/CODING_WORLD" ]; then
    do_mkdir_p "$WORKSPACE_ROOT/CODING_WORLD"
    if [ "$DRY_RUN" = false ]; then
      echo "Created parent directory: $WORKSPACE_ROOT/CODING_WORLD"
    fi
  fi
  if [ ! -d "$WORKSPACE_ROOT/CODING_WORLD/${language}" ]; then
    do_mkdir_p "$WORKSPACE_ROOT/CODING_WORLD/${language}"
    if [ "$DRY_RUN" = false ]; then
      echo "Created language directory: $WORKSPACE_ROOT/CODING_WORLD/${language}"
    fi
  fi

  if [ -d "$ROOT" ]; then
    if [ "$FORCE" = false ] && [ "$BACKUP" = false ]; then
      show_project_exists_error "$proj_id" "$ROOT"
      return 1
    fi
    prompt_overwrite "$ROOT"
    if [ "$BACKUP" = true ]; then
      backup_directory "$ROOT"
    fi
    if [ "$DRY_RUN" = false ]; then
      rm -rf "$ROOT"
    fi
  fi

  case "$language" in
    python)
      init_coding_python "$ROOT" "$proj_id" "$py_ver" "$skip_conda" "$skip_git"
      ;;
    matlab)
      init_coding_matlab "$ROOT" "$proj_id" "$skip_git"
      ;;
    fortran)
      init_coding_fortran "$ROOT" "$proj_id" "$py_ver" "$skip_conda" "$skip_git"
      ;;
    bash)
      init_coding_bash "$ROOT" "$proj_id" "$skip_git"
      ;;
  esac

  if [ "$DRY_RUN" = true ]; then
    if [ "$JSON_OUTPUT" = false ]; then
      echo "DRY RUN: would create ${language} project at $ROOT"
    fi
  else
    echo "‚úì ${language} project created: ${ROOT}"
    if { [ "$language" = "python" ] || [ "$language" = "fortran" ]; } && [ "$skip_conda" = false ]; then
      echo "‚úì Conda environment: coding_${proj_id}"
      echo "Activate with: conda activate coding_${proj_id}"
    fi
  fi
}

# Language-specific initializers
init_coding_python() {
  local project_dir="$1" project_name="$2" py_ver="$3" skip_conda="$4" skip_git="$5"
  do_mkdir_p "$project_dir/src/$project_name" "$project_dir/tests" "$project_dir/docs"

  write_file "$project_dir/README.md" <<EOF
# $project_name

Created: $(date +%Y-%m-%d)
Language: Python
EOF

  write_file "$project_dir/pyproject.toml" <<'EOF'
[build-system]
requires = ["setuptools", "wheel"]
build-backend = "setuptools.build_meta"
EOF

  write_file "$project_dir/src/$project_name/__init__.py" <<EOF
"""$project_name package."""
__version__ = "0.1.0"
EOF

  write_file "$project_dir/tests/test_example.py" <<'EOF'
def test_smoke():
  assert True
EOF

  if [ "$skip_conda" = false ]; then
    local CONDA_NAME="coding_${project_name}"
    local base_pkgs="numpy matplotlib pandas jupyter pytest black flake8"
    create_conda_env "$CONDA_NAME" "$py_ver" $base_pkgs || true
    export_environment_yaml "$CONDA_NAME" "$project_dir/environment.yaml" "$py_ver" $base_pkgs
  fi

  if [ "$skip_git" = false ]; then
    init_git_repo() { :; } || true
    if [ "$DRY_RUN" = false ]; then
      (cd "$project_dir" && git init >/dev/null 2>&1 || true)
    fi
    write_file "$project_dir/.gitignore" <<'EOF'
__pycache__/
.pytest_cache/
*.pyc
.venv/
env/
EOF
  fi
}

init_coding_matlab() {
  local project_dir="$1" project_name="$2" skip_git="$3"
  do_mkdir_p "$project_dir/src" "$project_dir/functions" "$project_dir/tests" "$project_dir/data" "$project_dir/figures" "$project_dir/docs"

  write_file "$project_dir/README.md" <<EOF
# $project_name

Created: $(date +%Y-%m-%d)
Language: MATLAB
EOF

  write_file "$project_dir/src/main.m" <<'EOF'
% Main entry for $PROJECT_NAME
disp('Hello from MATLAB project')
EOF

  write_file "$project_dir/project.yaml" <<EOF
project:
  name: ${project_name}
  language: matlab
  created: $(date +%Y-%m-%d)
  owner: ${USER}
EOF

  touch "$project_dir/data/.gitkeep" || true
  touch "$project_dir/figures/.gitkeep" || true

  if [ "$skip_git" = false ]; then
    if [ "$DRY_RUN" = false ]; then
      (cd "$project_dir" && git init >/dev/null 2>&1 || true)
    fi
    write_file "$project_dir/.gitignore" <<'EOF'
*.asv
*.mat
slprj/
figures/*.png
EOF
  fi
}

init_coding_fortran() {
  local project_dir="$1" project_name="$2" py_ver="$3" skip_conda="$4" skip_git="$5"
  do_mkdir_p "$project_dir/src" "$project_dir/modules" "$project_dir/tests" "$project_dir/build" "$project_dir/docs"

  write_file "$project_dir/README.md" <<EOF
# $project_name

Created: $(date +%Y-%m-%d)
Language: Fortran
EOF

  write_file "$project_dir/Makefile" <<'EOF'
FC = gfortran
FCFLAGS = -O2 -fcheck=all
SRC = src/main.f90
all:
	$(FC) $(FCFLAGS) -o build/$(notdir $(SRC:.f90=)) $(SRC)
EOF

  write_file "$project_dir/src/main.f90" <<'EOF'
! Main program for $PROJECT_NAME
program main
  print *, 'Hello Fortran'
end program main
EOF

  if [ "$skip_conda" = false ]; then
    local CONDA_NAME="coding_${project_name}"
    local base_pkgs="gfortran numpy"
    create_conda_env "$CONDA_NAME" "$py_ver" $base_pkgs || true
    export_environment_yaml "$CONDA_NAME" "$project_dir/environment.yaml" "$py_ver" $base_pkgs
  fi

  if [ "$skip_git" = false ]; then
    if [ "$DRY_RUN" = false ]; then
      (cd "$project_dir" && git init >/dev/null 2>&1 || true)
    fi
    write_file "$project_dir/.gitignore" <<'EOF'
*.o
*.mod
build/
*.out
EOF
  fi
}

init_coding_bash() {
  local project_dir="$1" project_name="$2" skip_git="$3"
  do_mkdir_p "$project_dir/bin" "$project_dir/lib" "$project_dir/tests" "$project_dir/config" "$project_dir/docs"

  write_file "$project_dir/README.md" <<EOF
# $project_name

Created: $(date +%Y-%m-%d)
Language: Bash
EOF

  write_file "$project_dir/bin/${project_name}.sh" <<'EOF'
#!/usr/bin/env bash
echo "Hello from $PROJECT_NAME"
EOF

  if [ "$DRY_RUN" = false ]; then
    chmod +x "$project_dir/bin/${project_name}.sh" || true
  fi

  write_file "$project_dir/project.yaml" <<EOF
project:
  name: ${project_name}
  language: bash
  created: $(date +%Y-%m-%d)
  owner: ${USER}
EOF

  if [ "$skip_git" = false ]; then
    if [ "$DRY_RUN" = false ]; then
      (cd "$project_dir" && git init >/dev/null 2>&1 || true)
    fi
    write_file "$project_dir/.gitignore" <<'EOF'
*.log
tmp/
.env
*.bak
EOF
  fi
}

init_journal() {
  # Handle help flags first before processing any other arguments (T034)
  for arg in "$@"; do
    case "$arg" in
      --help|-h)
        # Short journal help
        if declare -F show_journal_help >/dev/null 2>&1; then
          show_journal_help "short"
        else
          echo "Usage: $PROG_NAME init journal [OPTIONS]"
          echo "Options:"
          echo "  --name <name>       Name for paper (authorship) or journal (service)"
          echo "  --first             Primary authorship flag"
          echo "  --coauthor          Co-author collaboration flag"  
          echo "  --service           Journal service flag (requires --id)"
          echo "  --year <YYYY>       Year for authorship projects (default: current/extracted)"
          echo "  --id <id>           Manuscript identifier (required with --service)"
        fi
        return 0
        ;;
      --help-long)
        # Detailed journal help
        if declare -F show_journal_help >/dev/null 2>&1; then
          show_journal_help "long"
        else
          echo "Journal Role-Based Organization (Detailed Help)"
          echo "============================================="
          echo ""
          echo "Creates role-based journal organization for managing academic publishing workflows."
          echo ""
          echo "Usage patterns:"
          echo "  Primary authorship: $PROG_NAME init journal --name <paper_name> --first [--year <YYYY>]"
          echo "  Co-author project:  $PROG_NAME init journal --name <paper_name> --coauthor [--year <YYYY>]"
          echo "  Journal service:    $PROG_NAME init journal --name <journal_name> --id <manuscript_id> --service"
          echo ""
          echo "For comprehensive help, ensure help system is properly installed."
        fi
        return 0
        ;;
    esac
  done
  
  # Parse command-line arguments for role-based journal structure
  local name="" manuscript_id="" year=""
  local is_first=false is_coauthor=false is_service=false
  
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --name|-n)
        shift
        if [ $# -eq 0 ] || [ -z "${1:-}" ]; then
          echo "Error: --name requires a value (paper name or journal name)" >&2
          echo "" >&2
          echo "Examples:" >&2
          echo "  dirforge init journal --name \"thermal_analysis\" --first" >&2
          echo "  dirforge init journal --name \"Geophysics\" --id \"GEO-2025-0451\" --service" >&2
          echo "" >&2
          echo "For help: dirforge init journal --help" >&2
          exit 1
        fi
        name="$1"
        ;;
      --first|-f)
        is_first=true
        ;;
      --coauthor|-c)
        is_coauthor=true
        ;;
      --service|-s)
        is_service=true
        ;;
      --year|-y)
        shift
        if [ $# -eq 0 ] || [ -z "${1:-}" ]; then
          echo "Error: --year requires a 4-digit year (YYYY)" >&2
          echo "" >&2
          echo "Examples:" >&2
          echo "  dirforge init journal --name \"my_paper\" --first --year 2024" >&2
          echo "  dirforge init journal --name \"collaboration\" --coauthor --year 2023" >&2
          echo "" >&2
          echo "Note: If not specified, current year (2025) will be used" >&2
          echo "      Year can also be embedded in paper name: '2024_paper_name'" >&2
          exit 1
        fi
        year="$1"
        ;;
      --id|-i)
        shift
        if [ $# -eq 0 ] || [ -z "${1:-}" ]; then
          echo "Error: --id requires a manuscript identifier" >&2
          echo "" >&2
          echo "Examples:" >&2
          echo "  dirforge init journal --name \"Geophysics\" --id \"GEO-2025-0451\" --service" >&2
          echo "  dirforge init journal --name \"Nature Geoscience\" --id \"REVIEWER_2024_Q4\" --service" >&2
          echo "" >&2
          echo "Valid ID formats: letters, numbers, hyphens, underscores, dots" >&2
          echo "Example IDs: GEO-2025-0451, REVIEWER_2024_Q4, SPECIAL-ISSUE-2025" >&2
          exit 1
        fi
        manuscript_id="$1"
        ;;
      --help|-h|--help-long)
        # Skip these as they're already handled above
        echo "Internal error: help flags should have been handled earlier" >&2
        exit 1
        ;;
      *)
        echo "Error: Unknown argument for journal command: $1" >&2
        echo "" >&2
        echo "Valid journal flags:" >&2
        echo "  --name <name>       Name for paper (authorship) or journal (service)" >&2
        echo "  --first             Primary authorship flag" >&2
        echo "  --coauthor          Co-author collaboration flag" >&2
        echo "  --service           Journal service flag (requires --id)" >&2
        echo "  --year <YYYY>       Year for authorship projects (optional)" >&2
        echo "  --id <manuscript_id> Manuscript identifier for service projects" >&2
        echo "  --help, -h          Show help" >&2
        echo "  --help-long         Show detailed help" >&2
        echo "" >&2
        echo "Usage patterns:" >&2
        echo "  Primary authorship: $PROG_NAME init journal --name <paper_name> --first [--year <YYYY>]" >&2
        echo "  Co-author project:  $PROG_NAME init journal --name <paper_name> --coauthor [--year <YYYY>]" >&2
        echo "  Journal service:    $PROG_NAME init journal --name <journal_name> --id <manuscript_id> --service" >&2
        echo "" >&2
        echo "For comprehensive help: $PROG_NAME init journal --help" >&2
        exit 1
        ;;
    esac
    shift
  done
  
  # Validate flag combinations and requirements
  local mode_count=0
  if [ "$is_first" = true ]; then mode_count=$((mode_count + 1)); fi
  if [ "$is_coauthor" = true ]; then mode_count=$((mode_count + 1)); fi
  if [ "$is_service" = true ]; then mode_count=$((mode_count + 1)); fi
  
  if [ $mode_count -eq 0 ]; then
    echo "Error: Must specify one journal role: --first, --coauthor, or --service" >&2
    echo "" >&2
    echo "Choose your journal role:" >&2
    echo "  --first      Primary authorship (your papers as lead author)" >&2
    echo "  --coauthor   Co-author collaboration (joint projects)" >&2
    echo "  --service    Journal service (reviews, editorial work)" >&2
    echo "" >&2
    echo "Complete command examples:" >&2
    echo "  $PROG_NAME init journal --name \"thermal_analysis\" --first" >&2
    echo "  $PROG_NAME init journal --name \"joint_study\" --coauthor" >&2
    echo "  $PROG_NAME init journal --name \"Geophysics\" --id \"GEO-2025-0451\" --service" >&2
    echo "" >&2
    echo "For detailed help: $PROG_NAME init journal --help" >&2
    exit 1
  fi
  
  if [ $mode_count -gt 1 ]; then
    echo "Error: Cannot combine multiple journal role flags (--first, --coauthor, --service)" >&2
    echo "" >&2
    echo "Journal roles are mutually exclusive. Choose exactly one:" >&2
    echo "" >&2
    echo "  For YOUR papers (lead author):" >&2
    echo "    $PROG_NAME init journal --name \"paper_name\" --first" >&2
    echo "" >&2
    echo "  For COLLABORATIVE projects:" >&2
    echo "    $PROG_NAME init journal --name \"project_name\" --coauthor" >&2
    echo "" >&2
    echo "  For JOURNAL SERVICE (reviews/editorial):" >&2
    echo "    $PROG_NAME init journal --name \"Journal Name\" --id \"MANUSCRIPT_ID\" --service" >&2
    echo "" >&2
    echo "Each command creates content in a different organizational directory." >&2
    echo "For help: $PROG_NAME init journal --help" >&2
    exit 1
  fi
  
  # Validate required arguments for each mode
  if [ "$is_first" = true ] || [ "$is_coauthor" = true ]; then
    if [ -z "$name" ]; then
      echo "Error: --name is required for primary authorship and co-author projects" >&2
      echo "" >&2
      echo "Provide a descriptive paper name:" >&2
      echo "  $PROG_NAME init journal --name \"thermal_conductivity_analysis\" --first" >&2
      echo "  $PROG_NAME init journal --name \"2024_joint_reservoir_study\" --coauthor" >&2
      echo "" >&2
      echo "Paper names are automatically formatted for directory structure." >&2
      echo "Special characters and spaces are converted to underscores." >&2
      echo "Embedded years (YYYY_) are automatically detected and extracted." >&2
      exit 1
    fi
    
    if [ -n "$manuscript_id" ]; then
      echo "Error: --id flag is only valid for journal service projects (--service)" >&2
      echo "" >&2
      echo "You're creating an authorship project. Remove --id and use:" >&2
      if [ "$is_first" = true ]; then
        echo "  $PROG_NAME init journal --name \"$name\" --first"
      else
        echo "  $PROG_NAME init journal --name \"$name\" --coauthor"
      fi
      echo "" >&2
      echo "Manuscript IDs are only needed for journal service activities:" >&2
      echo "  $PROG_NAME init journal --name \"Journal Name\" --id \"MANUSCRIPT_ID\" --service" >&2
      exit 1
    fi
  fi
  
  if [ "$is_service" = true ]; then
    if [ -z "$name" ] || [ -z "$manuscript_id" ]; then
      echo "Error: Journal service requires both --name and --id flags" >&2
      echo "" >&2
      echo "Required for journal service:" >&2
      echo "  --name <journal_name>     Name of the journal (e.g., \"Geophysics\")" >&2
      echo "  --id <manuscript_id>      Manuscript identifier from journal" >&2
      echo "" >&2
      echo "Complete examples:" >&2
      echo "  $PROG_NAME init journal --name \"Geophysics\" --id \"GEO-2025-0451\" --service" >&2
      echo "  $PROG_NAME init journal --name \"Nature Geoscience\" --id \"REVIEWER_2024_Q4\" --service" >&2
      echo "  $PROG_NAME init journal --name \"JGR Solid Earth\" --id \"EDITORIAL_BOARD_2025\" --service" >&2
      echo "" >&2
      echo "This creates: 03_journal_service/journal_name/MANUSCRIPT_ID/" >&2
      exit 1
    fi
    
    if [ -n "$year" ]; then
      echo "Error: --year flag is only valid for authorship projects (--first, --coauthor)" >&2
      echo "" >&2
      echo "Journal service projects don't use --year. Remove it:" >&2
      echo "  $PROG_NAME init journal --name \"$name\" --id \"$manuscript_id\" --service" >&2
      echo "" >&2
      echo "Year specification is for authorship projects only:" >&2
      echo "  $PROG_NAME init journal --name \"paper_name\" --first --year 2024" >&2
      echo "  $PROG_NAME init journal --name \"project_name\" --coauthor --year 2023" >&2
      echo "" >&2
      echo "Journal service uses manuscript IDs for temporal organization." >&2
      exit 1
    fi
  fi
  
  # Ensure JOURNAL_WORLD structure exists
  if ! is_in_journal_world; then
    # Create role-based structure
    create_journal_role_structure || exit 1
  fi
  
  # Handle year logic for authorship projects
  if [ "$is_first" = true ] || [ "$is_coauthor" = true ]; then
    local paper_name="$name"
    if [ -z "$year" ]; then
      # Extract year from paper name or use current year
      year=$(extract_year_from_paper_name "$paper_name")
      paper_name=$(strip_year_from_paper_name "$paper_name")
    fi
    
    # Execute the appropriate creation function for authorship
    if [ "$is_first" = true ]; then
      create_primary_authorship_project "$paper_name" "$year" || exit 1
    elif [ "$is_coauthor" = true ]; then
      create_coauthor_project "$paper_name" "$year" || exit 1
    fi
  elif [ "$is_service" = true ]; then
    # For service mode, name is the journal name
    local journal_name="$name"
    create_journal_service_project "$journal_name" "$manuscript_id" || exit 1
  fi
}

handle_help_request() {
  # Route help requests to appropriate help functions based on context
  # Usage: handle_help_request [command] [world-type-or-subcommand] [world-type]
  
  local cmd="${1:-}"
  local arg2="${2:-}"
  local arg3="${3:-}"
  
  # Determine if arg2 is a world type or subcommand
  local world=""
  local subcmd=""
  
  case "$arg2" in
    research|lecture|coding|journal|office|private)
      # arg2 is a world type
      world="$arg2"
      subcmd="${arg3:-}"
      ;;
    *)
      # arg2 is a subcommand or empty
      subcmd="$arg2"
      world="$arg3"
      ;;
  esac
  
  # DEBUG: uncomment for troubleshooting
  # echo "DEBUG: cmd='$cmd' subcmd='$subcmd' world='$world' (arg2='$arg2' arg3='$arg3')" >&2
  
  # Check if help system is available
  if ! declare -F show_global_help >/dev/null 2>&1; then
    # Fallback to basic usage if help system not available
    usage
    return
  fi
  
  case "$cmd" in
    ""|"help"|"--help"|"-h")
      # Default to short help for quick reference
      if declare -F show_global_help_short >/dev/null 2>&1; then
        show_global_help_short
      else
        show_global_help
      fi
      ;;
    "--help-long")
      # Detailed comprehensive help
      show_global_help
      ;;
    "init")
      if [ -n "$world" ]; then
        # World-specific help: dirforge init research --help
        if declare -F show_world_help >/dev/null 2>&1; then
          show_world_help "$world"
        else
          show_command_help "init"
        fi
      else
        # Command help: dirforge init --help
        if declare -F show_command_help >/dev/null 2>&1; then
          show_command_help "init"
        else
          show_global_help
        fi
      fi
      ;;
    "update")
      # Command help: dirforge update --help
      if declare -F show_update_command_help >/dev/null 2>&1; then
        show_update_command_help
      elif declare -F show_command_help >/dev/null 2>&1; then
        show_command_help "update"
      else
        show_global_help
      fi
      ;;
    "validate-config")
      # Command help: dirforge validate-config --help (short variant) or dirforge help validate-config (long variant)
      # Try YAML-based help first (Phase 8c integration)
      if declare -F get_command_help >/dev/null 2>&1; then
        get_command_help "validate-config" "short" 2>/dev/null || {
          # Fallback if YAML help unavailable
          if declare -F show_command_help >/dev/null 2>&1; then
            show_command_help "validate-config"
          else
            echo "Usage: dirforge validate-config [options] <config_file>"
            echo ""
            echo "Validate a world configuration file against schema."
            echo ""
            echo "Options:"
            echo "  --verbose, -v    Show detailed validation messages"
            echo "  --help, -h       Show this help message"
            echo ""
            echo "Examples:"
            echo "  dirforge validate-config templates/world-configs/coding.world.yaml"
            echo "  dirforge validate-config --verbose templates/world-configs/research.world.yaml"
          fi
        }
      elif declare -F show_command_help >/dev/null 2>&1; then
        show_command_help "validate-config"
      else
        # Fallback help
        echo "Usage: dirforge validate-config [options] <config_file>"
        echo ""
        echo "Validate a world configuration file against schema."
        echo ""
        echo "Options:"
        echo "  --verbose, -v    Show detailed validation messages"
        echo "  --help, -h       Show this help message"
        echo ""
        echo "Examples:"
        echo "  dirforge validate-config templates/world-configs/coding.world.yaml"
        echo "  dirforge validate-config --verbose templates/world-configs/research.world.yaml"
      fi
      ;;
    "list-configs")
      # Command help: dirforge list-configs --help (short variant) or dirforge help list-configs (long variant)
      # Try YAML-based help first (Phase 8c integration)
      if declare -F get_command_help >/dev/null 2>&1; then
        get_command_help "list-configs" "short" 2>/dev/null || {
          # Fallback if YAML help unavailable
          if declare -F show_command_help >/dev/null 2>&1; then
            show_command_help "list-configs"
          else
            echo "Usage: dirforge list-configs [options]"
            echo ""
            echo "List all available world configuration files."
            echo ""
            echo "Options:"
            echo "  --show-invalid   Show detailed error messages for invalid configs"
            echo "  --help, -h       Show this help message"
            echo ""
            echo "Examples:"
            echo "  dirforge list-configs"
            echo "  dirforge list-configs --show-invalid"
          fi
        }
      elif declare -F show_command_help >/dev/null 2>&1; then
        show_command_help "list-configs"
      else
        # Fallback help
        echo "Usage: dirforge list-configs [options]"
        echo ""
        echo "List all available world configuration files."
        echo ""
        echo "Options:"
        echo "  --show-invalid   Show detailed error messages for invalid configs"
        echo "  --help, -h       Show this help message"
        echo ""
        echo "Examples:"
        echo "  dirforge list-configs"
        echo "  dirforge list-configs --show-invalid"
      fi
      ;;
    "--version"|"-v")
      echo "$PROG_NAME (DirForge Constitution $CONSTITUTION_VERSION)"
      echo "Enhanced Terminal Help System"
      ;;
    *)
      # Unknown command - show contextual help
      echo "Unknown command: $cmd" >&2
      echo >&2
      if declare -F show_global_help >/dev/null 2>&1; then
        echo "Available commands:" >&2
        show_global_help | grep -A5 "Usage" || usage
      else
        usage
      fi
      exit 1
      ;;
  esac
}

init_all_worlds() {
  # Create top-level directory structure with all world types
  local target_path="."
  local auto_create=false
  
  # Parse arguments
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --auto|--yes|-y)
        auto_create=true
        shift
        ;;
      --here)
        target_path="."
        shift
        ;;
      --path=*)
        target_path="${1#--path=}"
        shift
        ;;
      -*)
        echo "Unknown option: $1" >&2
        echo "Usage: $PROG_NAME init [path] [--auto|--yes|-y] [--here] [--path=PATH]" >&2
        exit 1
        ;;
      *)
        # First non-option argument is the target path
        target_path="$1"
        shift
        ;;
    esac
  done
  
  # Convert to absolute path and normalize
  if [[ "$target_path" == "." ]]; then
    target_path="$(pwd)"
  elif [[ "$target_path" != /* ]]; then
    target_path="$(pwd)/$target_path"
  fi
  
  echo "Initializing DirForge workspace at: $target_path"
  echo
  
  # Check if target directory exists and is not empty
  if [ -d "$target_path" ] && [ "$(ls -A "$target_path" 2>/dev/null | wc -l)" -gt 0 ]; then
    if [ "$auto_create" = false ] && [ "$YES" = false ] && [ "$FORCE" = false ]; then
      echo "WARNING: Directory '$target_path' exists and is not empty." >&2
      echo "Contents will be preserved, but new world directories will be created alongside existing files." >&2
      read -r -p "Continue with initialization? [y/N] " response
      case "$response" in
        [yY][eE][sS]|[yY]) 
          ;;
        *)
          echo "Initialization cancelled." >&2
          exit 1
          ;;
      esac
    fi
  fi
  
  # Create base directory if it doesn't exist
  do_mkdir_p "$target_path"
  
  # Define all world types - per DirForge Constitution v1.0.17
  local worlds=(
    "CODING_WORLD"
    "JOURNAL_WORLD" 
    "LECTURE_WORLD"
    "LITERATURE_WORLD"
    "OFFICE_WORLD"
    "PRIVATE_WORLD"
    "RESEARCH_WORLD"
  )
  
  # Only OFFICE_WORLD and PRIVATE_WORLD get subfolders during workspace init
  # Other worlds remain empty until specific projects are created
  
  local office_dirs=(
    "00_admin"
    "01_finance"
    "02_hr_administration"
    "03_faculty"
    "04_inventory_equipment"
    "05_software_licenses"
    "06_public_relations"
    "90_archive"
  )
  
  local private_dirs=(
    "00_admin"
    "01_credentials"
    "02_id_contracts"
    "03_finance"
    "04_documents"
    "05_photos"
    "06_movies"
    "07_hiking"
    "09_installers"
    "90_archive"
  )
  
  # Create world directories
  for world in "${worlds[@]}"; do
    local world_path="$target_path/$world"
    do_mkdir_p "$world_path"
    
    # Per Constitution: Only OFFICE_WORLD and PRIVATE_WORLD get subfolders at init
    # All others remain empty until specific projects are created
    case "$world" in
      OFFICE_WORLD)
        for dir in "${office_dirs[@]}"; do
          do_mkdir_p "$world_path/$dir"
        done
        ;;
      PRIVATE_WORLD)
        for dir in "${private_dirs[@]}"; do
          do_mkdir_p "$world_path/$dir"
        done
        ;;
      CODING_WORLD|JOURNAL_WORLD|LECTURE_WORLD|RESEARCH_WORLD|LITERATURE_WORLD)
        # These remain empty - projects created by specific init commands
        ;;
    esac
  done
  
  
  if [ "$DRY_RUN" = true ]; then
    echo "DRY RUN: would create complete DirForge workspace at $target_path"
  else
    # Create workspace-level integrity metadata
    create_workspace_integrity_metadata "$target_path" "1.0.22" || {
      echo "Warning: Could not create workspace metadata" >&2
    }
    
    echo
    echo "‚úÖ Workspace initialized at: $target_path"
    echo
    echo "Created world directories:"
    echo "  CODING_WORLD/           (empty - use 'dirforge init coding' to create projects)"
    echo "  JOURNAL_WORLD/          (empty - use 'dirforge init journal' to create activities)"
    echo "  LECTURE_WORLD/          (empty - use 'dirforge init lecture' to create courses)"
    echo "  LITERATURE_WORLD/       (empty - user-managed)"
    echo "  OFFICE_WORLD/           (with 7 subfolders)"
    echo "  PRIVATE_WORLD/          (with 10 subfolders)"
    echo "  RESEARCH_WORLD/         (empty - use 'dirforge init research' to create projects)"
    echo
    echo "Constitution version: v1.0.22"
    echo
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo "‚ö° IMPORTANT: Configure workspace environment variable"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo
    echo "To use dirforge commands from anywhere in your system, add this to your shell:"
    echo
    echo "  echo 'export DIRFORGE_WORKSPACE_ROOT=\"$target_path\"' >> ~/.zshrc"
    echo "  source ~/.zshrc"
    echo
    echo "After configuration, you can run commands like:"
    echo "  dirforge init research --project myproject"
    echo "  dirforge init coding --language python --project mytool"
    echo
    echo "From anywhere, and projects will be created in: $target_path"
    echo
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo
    echo "Next steps:"
    echo "  ‚Ä¢ Create a research project: $PROG_NAME init research --name \"Project Name\""
    echo "  ‚Ä¢ Create a lecture: $PROG_NAME init lecture --name \"Course Name\""
    echo "  ‚Ä¢ Create a coding project: $PROG_NAME init coding --language python --project \"name\""
    echo "  ‚Ä¢ Create a journal activity: $PROG_NAME init journal --journal \"Journal Name\" --id \"MS-ID\""
  fi
}

suggest_world_help() {
  # Suggest valid world types for unknown world types
  local invalid_world="$1"
  local valid_worlds="research lecture coding journal office private"
  
  echo "Unknown world type: $invalid_world" >&2
  echo >&2
  echo "Valid world types:" >&2
  for world in $valid_worlds; do
    echo "  $world" >&2
  done
  echo >&2
  echo "For detailed help on a specific world type:" >&2
  echo "  $PROG_NAME init <world-type> --help" >&2
  echo >&2
  echo "Examples:" >&2
  echo "  $PROG_NAME init research --help" >&2
  echo "  $PROG_NAME init lecture --help" >&2
  echo >&2
  echo "To initialize a complete workspace with all worlds:" >&2
  echo "  $PROG_NAME init [path] [--auto]" >&2
}

usage() {
  cat <<EOF
Usage: 
  $PROG_NAME init <world> [options]        # Create specific world project
  $PROG_NAME init [path] [--auto]          # Initialize complete workspace with all worlds

World types: research, lecture, coding, journal, office, private

Global options:
  --dry-run, --preview    Preview changes without writing to filesystem
  --json                  Output machine-readable JSON plan (requires --dry-run)
  --force                 Overwrite existing projects without prompting
  --backup                Create timestamped backups before overwriting
  --yes, -y               Skip interactive prompts and proceed

Complete workspace initialization:
  path                    Target directory (default: current directory)
  --auto, --yes, -y       Create automatically without prompts
  --here                  Explicitly use current directory

Examples:
  # Initialize complete workspace
  $PROG_NAME init
  $PROG_NAME init /path/to/workspace --auto
  $PROG_NAME init ~/myworkspace
  
  # Create specific world projects
  $PROG_NAME init research --name "Thermal Model Analysis" --python 3.11
  $PROG_NAME init lecture --name "Digital Rock Physics"
  $PROG_NAME init coding --language python --project ml_toolkit
  
  # Preview changes
  $PROG_NAME --dry-run init ~/test-workspace
  $PROG_NAME --dry-run --json init research --name "Test" | jq .
EOF
}

output_json_plan() {
  # Output accumulated dry-run plan as JSON
  echo "{"
  echo '  "dry_run": true,'
  echo '  "directories": ['
  local first=true
  for dir in "${JSON_DIRS[@]}"; do
    if [ "$first" = false ]; then echo ","; fi
    printf '    "%s"' "$(json_escape "$dir")"
    first=false
  done
  echo ""
  echo '  ],'
  echo '  "files": ['
  first=true
  if [ "${#JSON_FILES[@]}" -gt 0 ]; then
    for file in "${JSON_FILES[@]}"; do
      if [ "$first" = false ]; then echo ","; fi
      printf '    "%s"' "$(json_escape "$file")"
      first=false
    done
  fi
  echo ""
  echo '  ]'
  echo "}"
}

# ============================================================================
# cmd_validate_config: Validate YAML config file against schema (T044-T047)
# ============================================================================
# Usage: cmd_validate_config [--verbose] [--help] <config_file>
# Returns: 0 on success, 1+ on validation errors
cmd_validate_config() {
  local verbose=false
  local config_file=""
  
  # Parse arguments
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --verbose|-v)
        verbose=true
        shift
        ;;
      --help|-h)
        show_command_help "validate-config"
        exit 0
        ;;
      -*)
        echo "Error: Unknown option: $1" >&2
        exit 1
        ;;
      *)
        config_file="$1"
        shift
        ;;
    esac
  done
  
  # Check if config file was provided
  if [ -z "$config_file" ]; then
    echo "Error: No config file specified." >&2
    echo "Usage: $PROG_NAME validate-config [options] <config_file>" >&2
    exit 1
  fi
  
  # Check if config file exists
  if [ ! -f "$config_file" ]; then
    echo "Error: Config file not found: $config_file" >&2
    exit 1
  fi
  
  # Source required libraries
  if [ ! -f "$LIB_DIR/config_schema.sh" ]; then
    echo "Error: Schema validation library not found at $LIB_DIR/config_schema.sh" >&2
    exit 1
  fi
  
  # Source dependencies
  source "$LIB_DIR/colors.sh"
  source "$LIB_DIR/yaml_utils.sh"
  source "$LIB_DIR/config_schema.sh"
  
  # Initialize colors
  if declare -f init_colors >/dev/null 2>&1; then
    init_colors
  fi
  
  # Run validation
  if [ "$verbose" = true ]; then
    validate_config_schema "$config_file" "--verbose"
  else
    validate_config_schema "$config_file" >/dev/null 2>&1
  fi
  
  local validation_result=$?
  
  if [ $validation_result -eq 0 ]; then
    if [ "$verbose" != true ]; then
      echo "‚úì Config validation passed: $(basename "$config_file")"
    fi
    exit 0
  else
    echo "‚úó Config validation failed: $(basename "$config_file")" >&2
    exit 1
  fi
}

# ============================================================================
# cmd_list_configs: List all available world config files (T048-T051)
# ============================================================================
# Usage: cmd_list_configs [--help] [--show-invalid]
# Returns: 0 if all configs valid or listing completed with warnings, non-zero on error
cmd_list_configs() {
  local show_invalid=false
  
  # Parse arguments
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --show-invalid)
        show_invalid=true
        shift
        ;;
      --help|-h)
        show_command_help "list-configs"
        exit 0
        ;;
      -*)
        echo "Error: Unknown option: $1" >&2
        exit 1
        ;;
      *)
        echo "Error: Unexpected argument: $1" >&2
        exit 1
        ;;
    esac
  done
  
  # Find config directory
  local config_dir="$TEMPLATES_DIR/world-configs"
  
  if [ ! -d "$config_dir" ]; then
    echo "Error: Config directory not found: $config_dir" >&2
    exit 1
  fi
  
  # Source required libraries
  if [ ! -f "$LIB_DIR/config_schema.sh" ]; then
    echo "Error: Schema validation library not found at $LIB_DIR/config_schema.sh" >&2
    exit 1
  fi
  
  source "$LIB_DIR/colors.sh"
  source "$LIB_DIR/yaml_utils.sh"
  source "$LIB_DIR/config_schema.sh"
  
  # Initialize colors
  if declare -f init_colors >/dev/null 2>&1; then
    init_colors
  fi
  
  # Collect configs sorted by world type
  local -a configs=()
  local found=false
  
  # Find all .world.yaml files
  while IFS= read -r config_file; do
    configs+=("$config_file")
    found=true
  done < <(find "$config_dir" -maxdepth 1 -name "*.world.yaml" | sort)
  
  if [ "$found" = false ]; then
    echo "No world config files found in $config_dir" >&2
    exit 1
  fi
  
  # Display configs with validation status
  local valid_count=0
  local invalid_count=0
  
  echo "Available World Configurations:"
  echo "================================"
  echo
  
  for config_file in "${configs[@]}"; do
    local config_name=$(basename "$config_file" .world.yaml)
    
    # Try to extract world type from config using yq
    local world_type=""
    if [ -f "$config_file" ]; then
      world_type=$(yq -r '.world.type' "$config_file" 2>/dev/null || echo "UNKNOWN")
    fi
    
    # Validate config
    if validate_config_schema "$config_file" >/dev/null 2>&1; then
      echo "  ‚úì $config_name ($world_type)"
      ((valid_count++))
    else
      echo "  ‚úó $config_name ($world_type) - INVALID"
      ((invalid_count++))
      
      if [ "$show_invalid" = true ]; then
        # Show validation errors for invalid configs
        if declare -f validate_config_schema >/dev/null 2>&1; then
          validate_config_schema "$config_file" 2>&1 | sed 's/^/      /' || true
        fi
      fi
    fi
  done
  
  echo
  echo "Summary:"
  echo "  Valid: $valid_count"
  echo "  Invalid: $invalid_count"
  echo "  Total: $((valid_count + invalid_count))"
  echo
  
  # Exit with appropriate code
  if [ $invalid_count -gt 0 ]; then
    if [ "$show_invalid" = false ]; then
      echo "Note: Use --show-invalid to see detailed error messages for invalid configs."
    fi
    exit 0  # Still exit 0 because listing completed; warnings don't cause failure
  else
    exit 0
  fi
}

main() {
  # Handle help and version flags first (before parsing other options)
  case "${1:-}" in
    --help|-h|help)
      handle_help_request
      exit 0
      ;;
    --version|-v|version)
      handle_help_request "--version"
      exit 0
      ;;
  esac

  # Global flags: support --dry-run or --preview anywhere in the args
  local new_args=()
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --dry-run|--preview)
        DRY_RUN=true; shift;;
      --json)
        JSON_OUTPUT=true; shift;;
      --force)
        FORCE=true; shift;;
      --backup)
        BACKUP=true; shift;;
      --yes|-y)
        YES=true; shift;;
      --help|-h)
        # Context-aware help handling
        if [ "${#new_args[@]}" -gt 0 ]; then
          handle_help_request "${new_args[@]}"
        else
          handle_help_request
        fi
        exit 0
        ;;
      *) new_args+=("$1"); shift;;
    esac
  done
  
  # Validate JSON requires dry-run
  if [ "$JSON_OUTPUT" = true ] && [ "$DRY_RUN" = false ]; then
    show_json_requires_dryrun_error
    exit 1
  fi
  
  # Restore positional params
  set -- "${new_args[@]:-}"
  if [ "$#" -lt 1 ]; then
    handle_help_request
    exit 1
  fi
  
  cmd="$1"; shift
  case "$cmd" in
    update)
      # Check if first argument is a help flag
      case "${1:-}" in
        --help|-h)
          handle_help_request "update"
          exit 0
          ;;
      esac
      cmd_update "$@"
      exit $?
      ;;
    init)
      # Check if there are any arguments
      if [ "$#" -eq 0 ]; then
        # No arguments - initialize complete workspace in current directory
        init_all_worlds "."
      else
        # Check if first argument is a help flag
        case "$1" in
          --help|-h)
            handle_help_request "init"
            exit 0
            ;;
          research|lecture|coding|journal|office|private)
            # Traditional world-specific init
            world="$1"
            shift
            
            # Check for help flags before processing world
            case "${1:-}" in
              --help|-h)
                # Short help for world type
                if declare -F show_world_help >/dev/null 2>&1; then
                  show_world_help "$world" "short"
                  exit 0
                fi
                ;;
              --help-long)
                # Long/detailed help for world type
                if declare -F show_world_help >/dev/null 2>&1; then
                  show_world_help "$world" "long"
                  exit 0
                fi
                ;;
            esac
            
            # Check for parent-only mode first
            if is_parent_only_mode "$world" "$@"; then
              create_world_parent "$world"
            else
              case "$world" in
                research) init_research "$@" ;;
                lecture) init_lecture "$@" ;;
                coding) init_coding "$@" ;;
                journal) init_journal "$@" ;;
                office)
                echo "Creating OFFICE_WORLD standard folders..."
                if [ ! -d "$WORKSPACE_ROOT/OFFICE_WORLD" ]; then
                  echo "Created parent directory: $WORKSPACE_ROOT/OFFICE_WORLD"
                fi
                for d in 00_admin 01_finance 02_hr_administration 03_faculty 04_inventory_equipment 05_software_licenses 06_public_relations; do
                  do_mkdir_p "$WORKSPACE_ROOT/OFFICE_WORLD/$d"
                done
                if [ "$DRY_RUN" = true ]; then
                  echo "DRY RUN: would create OFFICE_WORLD/"
                else
                  echo "Created OFFICE_WORLD/"
                fi ;;
              private)
                echo "Creating PRIVATE_WORLD standard folders..."
                if [ ! -d "$WORKSPACE_ROOT/PRIVATE_WORLD" ]; then
                  echo "Created parent directory: $WORKSPACE_ROOT/PRIVATE_WORLD"
                fi
                for d in 00_admin 01_credentials 02_id_contracts 03_finance 04_documents 05_photos 06_movies 07_hiking 09_installers 90_archive; do
                  do_mkdir_p "$WORKSPACE_ROOT/PRIVATE_WORLD/$d"
                done
                if [ "$DRY_RUN" = true ]; then
                  echo "DRY RUN: would create PRIVATE_WORLD/"
                else
                  echo "Created PRIVATE_WORLD/"
                fi ;;
              esac
            fi
            ;;
          *)
            # Initialize complete workspace (all worlds) - could be path or flags
            init_all_worlds "$@"
            ;;
        esac
      fi
      
      # Output JSON plan if requested
      if [ "$JSON_OUTPUT" = true ]; then
        output_json_plan
      fi
    ;;
    validate-config)
      # Check if first argument is a help flag
      case "${1:-}" in
        --help|-h)
          handle_help_request "validate-config"
          exit 0
          ;;
      esac
      cmd_validate_config "$@"
      exit $?
      ;;
    list-configs)
      # Check if first argument is a help flag
      case "${1:-}" in
        --help|-h)
          handle_help_request "list-configs"
          exit 0
          ;;
      esac
      cmd_list_configs "$@"
      exit $?
      ;;
    help)
      # Progressive disclosure: dirforge help <command> shows long-form help
      # This implements T209-T213: progressive disclosure pattern
      local help_cmd="${1:-}"
      
      if [ -z "$help_cmd" ]; then
        # dirforge help (no args) - show global help
        if declare -F get_global_help >/dev/null 2>&1; then
          get_global_help 2>/dev/null || handle_help_request
        else
          handle_help_request
        fi
        exit 0
      fi
      
      # dirforge help <command> - show long-form command help (T212-T213)
      case "$help_cmd" in
        validate-config)
          # Show long-form help for validate-config (T212)
          if declare -F get_command_help >/dev/null 2>&1; then
            get_command_help "validate-config" "long" 2>/dev/null || {
              echo "Usage: dirforge validate-config [options] <config_file>"
              echo ""
              echo "Validate a world configuration file against the YAML configuration schema."
              echo ""
              echo "DESCRIPTION"
              echo "  Validates the structure and content of a world configuration file"
              echo "  against the official schema. Checks for required fields, type"
              echo "  validation, and nested structure integrity."
              echo ""
              echo "OPTIONS"
              echo "  --verbose, -v    Show detailed validation messages including"
              echo "                   line numbers and specific field errors"
              echo "  --help, -h       Show this help message"
              echo ""
              echo "EXAMPLES"
              echo "  Validate a specific config file:"
              echo "    dirforge validate-config templates/world-configs/coding.world.yaml"
              echo ""
              echo "  Validate with detailed output:"
              echo "    dirforge validate-config --verbose templates/world-configs/research.world.yaml"
              echo ""
              echo "RELATED COMMANDS"
              echo "  dirforge list-configs      - List all available configurations"
              echo "  dirforge help yaml-config-system - Learn about YAML config system"
              echo ""
              echo "SEE ALSO"
              echo "  Schema specification: templates/world-configs/SCHEMA.md"
            }
          else
            echo "Usage: dirforge validate-config [options] <config_file>"
            echo ""
            echo "Validate a world configuration file against schema."
            echo ""
            echo "Options:"
            echo "  --verbose, -v    Show detailed validation messages"
            echo "  --help, -h       Show this help message"
          fi
          exit 0
          ;;
        list-configs)
          # Show long-form help for list-configs (T212)
          if declare -F get_command_help >/dev/null 2>&1; then
            get_command_help "list-configs" "long" 2>/dev/null || {
              echo "Usage: dirforge list-configs [options]"
              echo ""
              echo "List all available world configuration files with validation status."
              echo ""
              echo "DESCRIPTION"
              echo "  Scans the configuration directory and displays all available"
              echo "  world type configurations. Validates each configuration and"
              echo "  indicates which ones pass schema validation."
              echo ""
              echo "OPTIONS"
              echo "  --show-invalid   Show detailed error messages for any invalid"
              echo "                   configuration files instead of just status"
              echo "  --help, -h       Show this help message"
              echo ""
              echo "OUTPUT FORMAT"
              echo "  ‚úì config_name (WORLD_TYPE)  - Valid configuration"
              echo "  ‚úó config_name              - Invalid configuration"
              echo ""
              echo "EXAMPLES"
              echo "  List all configurations:"
              echo "    dirforge list-configs"
              echo ""
              echo "  Show validation errors for invalid configs:"
              echo "    dirforge list-configs --show-invalid"
              echo ""
              echo "RELATED COMMANDS"
              echo "  dirforge validate-config    - Validate a specific config file"
              echo "  dirforge help yaml-config-system - Learn about YAML config system"
            }
          else
            echo "Usage: dirforge list-configs [options]"
            echo ""
            echo "List all available world configuration files."
          fi
          exit 0
          ;;
        yaml-config-system|init-config)
          # Show system overview help for YAML config system (T213)
          if declare -F get_command_help >/dev/null 2>&1; then
            get_command_help "yaml-config-system" "long" 2>/dev/null || {
              echo "YAML Configuration System Overview"
              echo "===================================="
              echo ""
              echo "The YAML configuration system replaces hard-coded world structures"
              echo "with centralized, version-controlled configuration files. Each world"
              echo "type has a corresponding .world.yaml configuration file that defines"
              echo "the complete directory structure and metadata."
              echo ""
              echo "ARCHITECTURE"
              echo "  Configuration files:    templates/world-configs/*.world.yaml"
              echo "  Schema specification:   templates/world-configs/SCHEMA.md"
              echo "  Parser library:         lib/help_yaml_parser.sh"
              echo "  Help files:             templates/help/*.yaml"
              echo ""
              echo "KEY FEATURES"
              echo "  ‚Ä¢ Version-controlled structure definitions"
              echo "  ‚Ä¢ Schema validation to ensure consistency"
              echo "  ‚Ä¢ Dynamic scaffold generation"
              echo "  ‚Ä¢ Atomic transactions with rollback"
              echo "  ‚Ä¢ Inheritance of permissions from parents"
              echo "  ‚Ä¢ Progressive disclosure of help information"
              echo ""
              echo "SUPPORTED WORLD TYPES"
              echo "  CODING_WORLD     - Programming and development projects"
              echo "  RESEARCH_WORLD   - Research projects with studies"
              echo "  JOURNAL_WORLD    - Journal with role-based structure"
              echo "  LECTURE_WORLD    - Course/lecture materials"
              echo "  OFFICE_WORLD     - Business and office management"
              echo "  PRIVATE_WORLD    - Personal and private documents"
              echo "  LITERATURE_WORLD - Books, articles, and literature"
              echo ""
              echo "QUICK START"
              echo "  1. Create a workspace:    dirforge init"
              echo "  2. List configurations:   dirforge list-configs"
              echo "  3. Validate a config:     dirforge validate-config <file>"
              echo "  4. Create from config:    dirforge init <world-type>"
              echo ""
              echo "RELATED COMMANDS"
              echo "  dirforge validate-config  - Validate a configuration file"
              echo "  dirforge list-configs     - List available configurations"
              echo "  dirforge init <world>     - Initialize world with config"
            }
          else
            echo "YAML Configuration System Overview"
            echo "===================================="
            echo ""
            echo "The YAML configuration system centralizes world structure definitions."
          fi
          exit 0
          ;;
        custom-world)
          # Show custom world creation help (T213)
          if declare -F get_command_help >/dev/null 2>&1; then
            get_command_help "custom-world" "long" 2>/dev/null || {
              echo "Creating Custom World Configurations"
              echo "====================================="
              echo ""
              echo "You can create custom world configurations by copying and modifying"
              echo "existing configuration files to match your specific needs."
              echo ""
              echo "STEP-BY-STEP GUIDE"
              echo ""
              echo "1. Choose a base configuration:"
              echo "   Copy an existing config as a template"
              echo "   cp templates/world-configs/research.world.yaml my-custom.world.yaml"
              echo ""
              echo "2. Edit the configuration:"
              echo "   Update the world type and structure to match your needs"
              echo ""
              echo "3. Validate your configuration:"
              echo "   dirforge validate-config my-custom.world.yaml"
              echo ""
              echo "4. Use it to initialize:"
              echo "   dirforge init research --config my-custom.world.yaml"
              echo ""
              echo "YAML STRUCTURE"
              echo "  world:"
              echo "    type: CUSTOM_WORLD"
              echo "    version: '1.0.22'"
              echo "  parent_directories:"
              echo "    - name: 01_projects"
              echo "      subdirectories:"
              echo "        - name: active"
              echo "        - name: archive"
              echo ""
              echo "VALIDATION"
              echo "  Required fields:"
              echo "    ‚Ä¢ world.type"
              echo "    ‚Ä¢ world.version"
              echo "    ‚Ä¢ constitution_version"
              echo "    ‚Ä¢ parent_directories (array)"
              echo ""
              echo "EXAMPLES"
              echo "  See existing configs for reference:"
              echo "    ls -la templates/world-configs/"
              echo ""
              echo "RELATED COMMANDS"
              echo "  dirforge validate-config   - Validate your custom config"
              echo "  dirforge list-configs      - See available configs"
            }
          else
            echo "Creating Custom World Configurations"
          fi
          exit 0
          ;;
        init)
          # Show init help via YAML if available, or fallback
          if declare -F get_command_help >/dev/null 2>&1; then
            get_command_help "init-config" "long" 2>/dev/null || {
              handle_help_request "init"
            }
          else
            handle_help_request "init"
          fi
          exit 0
          ;;
        *)
          # Unknown help topic - try to show YAML help or fallback
          if declare -F get_command_help >/dev/null 2>&1; then
            get_command_help "$help_cmd" "long" 2>/dev/null && exit 0
          fi
          echo "Unknown topic: $help_cmd" >&2
          echo ""
          echo "Available help topics:"
          echo "  dirforge help validate-config     - Validate configurations"
          echo "  dirforge help list-configs        - List available configs"
          echo "  dirforge help yaml-config-system  - System overview"
          echo "  dirforge help custom-world        - Create custom configs"
          echo "  dirforge help init                - Initialize worlds"
          echo ""
          echo "For quick help, use --help flag:"
          echo "  dirforge <command> --help"
          exit 1
          ;;
      esac
      ;;
    *) 
      handle_help_request "$cmd"
      exit 1
      ;;
  esac
}

main "$@"
